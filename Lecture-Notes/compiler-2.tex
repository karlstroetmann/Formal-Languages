\section{Code Generation}
Next, we discuss the generation of code.  We structure our representation by discussing the code generation for
arithmetic expressions, Boolean expression, statements, and function definitions separately. 

\subsection{Translation of Arithmetic Expressions}
Given an arithmetic expression $e$, the translation of $e$ is supposed to generate some code that, when
executed, places the result of evaluating the expression $e$ onto the stack.  To this end we define a function
\mytt{compile} that has the following signature:
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile}: \textsl{Expr} \times \textsl{SymbolTable} \times \textsl{ClassName} \rightarrow 
                 \textsl{Pair}\mathtt{<}\textsl{List}\mathtt{<}\textsl{AsmCmd}\mathtt{>}, \mathbb{N}\mathtt{>}.$
\\[0.2cm]
A call to this function has the form
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile}(\mytt{expr}, \mytt{st}, \mytt{name})$.
\\[0.2cm]
The interpretation of the arguments is as follows:
\begin{enumerate}[(a)]
\item \mytt{expr} is the arithmetic expression that is to be translated into assembler code.
\item \mytt{st} is the \blue{symbol table}: \index{symbol table} Concretely, this is a dictionary that maps
      the variable names to their position on the stack.  For example, if \squoted{x} is a variable that is the
      third variable in the local variable frame, then we have
      \\[0.2cm]
      \hspace*{1.3cm}
      \mytt{st['x'] = 2},
      \\[0.2cm]
      because the first variable in the local variable frame has index 0.  We will discuss later how the 
      positions of the variables on the stack is fixed.
\item \mytt{name} is the name of the class that is to be used by our compiler.

     As we generate \textsl{Java} assembler and in \textsl{Java} every function has to be a part of a class,
     all functions that we create have to be static functions that are defined inside a class.  Therefore,
     \mytt{name} is the name of this class.

     This argument \mytt{name} is only needed when function calls are translated.
\end{enumerate}
The function \mytt{compile} returns a pair.  
\begin{enumerate}[(a)]
\item The first component of this pair is a list of \textsl{Java} 
      assembler commands that adhere to the syntax recognized by \textsl{Jasmin}.  In general, when the
      expression that is translated is complex, the execution of these assembler commands might need
      considerable room on the stack.  However, it has to be guaranteed that when the execution of theses
      commands finishes, the stack is back to its original height plus one because the net 
      effect of executing these commands must be to put the value of the expression on the stack.
\item The second component of the return value of \mytt{compile} is a natural number.
      This natural number tells us how much the stack might grow when \mytt{expr} is evaluated.
      This information is needed because the \textsl{Java} virtual machine needs this information in advance:
      In \textsl{Java}, every function has to declare how much space it might use on the stack.
      This declaration is done using the pseudo assembler command \mytt{.limit}.  Controlling the 
      maximum height of the stack is a security feature of \textsl{Java} that prevents those exploits that
      utilize stack overflows.
\end{enumerate}
In the following, we discuss the evaluation of the different arithmetic expressions one by one.


\subsubsection{Translation of a Variable}
If the expression that is to be compiled is a variable $v$, we have to load this variable on the stack using
the command \mytt{iload}.  This command has one parameter which is the index of the variable on the local
variable frame.  This index is stored in the symbol table \mytt{st}.  Since we just need one entry on the
stack to store the variable we have
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile}(v, \mytt{st}, \mytt{name}) = 
 \bigl\langle\mytt{[}\;\; \mytt{iload}\; \mytt{st[}v\mytt{]}\; \mytt{]}, \; 1\bigr\rangle$ \quad
 if $v$ is a variable.
\\[0.2cm]
The code for translating a variable is shown in Figure \ref{fig:Compiler.ipynb:compile:var} on page
\pageref{fig:Compiler.ipynb:compile:var}.

\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = 1,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
               ]{python3}
    def compile_expr(expr, st, class_name):
        if isinstance(expr, str):
            number = st[expr]
            Cmd    = indent(f'iload {number}')
            return [Cmd], 1
        ...
\end{minted}
\vspace*{-0.3cm}
\caption{Translation of a variable.}
\label{fig:Compiler.ipynb:compile:var}
\end{figure}

\subsubsection{Translation of a Constant}
We can load a constant $c$ onto the stack using the assembler command 
\\[0.2cm]
\hspace*{1.3cm}
\mytt{ldc} $c$.
\\[0.2cm]
As we only need the room to store $c$ on the stack, we have
\\[0.2cm]
\hspace*{1.3cm}
$\mytt{compile}(c, \mytt{st}, \mytt{name}) = 
 \bigl\langle\mytt{[}\;\; \mytt{ldc}\; c \;\mytt{]}, \; 1\bigr\rangle$ \quad
 if $c$ is a constant.
\\[0.2cm]
The code for translating a constant is shown in Figure \ref{fig:Compiler.ipynb:compile:const} on page
\pageref{fig:Compiler.ipynb:compile:const}.

\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = last,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
               ]{python3}
    def compile_expr(expr, st, class_name):
        ...
        elif expr[0] == 'Number':
            _, n = expr
            Cmd  = indent(f'ldc {n}')
            return [Cmd], 1
        ...
\end{minted}
\vspace*{-0.3cm}
\caption{Translation of a variable.}
\label{fig:Compiler.ipynb:compile:const}
\end{figure}

\subsubsection{Translation of an Arithmetic Operator}
In order to translate an expression of the form
\[ \textsl{lhs} \quoted{+} \textsl{rhs} \]
into assembler code, we first have to recursively translate the expressions \textsl{lhs} and
\textsl{rhs} into assembler code.  Later, when this code is executed the values of the expressions
\textsl{lhs} und \textsl{rhs} are placed on the stack.  We add these values using the command \mytt{iadd}.
If the evaluation of \textsl{lhs} needs $s_1$ words on the stack and the evaluation of \textsl{rhs} needs $s_2$
words on the stack, then the evaluation of $\textsl{lhs} + \textsl{rhs}$ needs 
\\[0.2cm]
\hspace*{1.3cm}
$\max(s_1, 1 + s_2)$
\\[0.2cm]
words on the stack, because when \textsl{rhs} is evaluated, the value of \textsl{lhs} occupies already one position
on the stack and hence the evaluation of \textsl{rhs} can only use the memory cells that are above the position
where \textsl{lhs} is stored. Therefore, the compilation of $\textsl{lhs} + \textsl{rhs}$ can be specified as
follows:
\\[0.2cm]
\hspace*{1.3cm}
$
\begin{array}[t]{cll}
        & \mytt{compile}(\textsl{lhs}, \mytt{st}, \mytt{name}) = \pair(L_1, s_1)  \\[0.1cm]
\wedge  & \mytt{compile}(\textsl{rhs}, \mytt{st}, \mytt{name}) = \pair(L_2, s_2)  \\[0.1cm]
\rightarrow & \mytt{compile}(\textsl{lhs} + \textsl{rhs}, \mytt{st}, \mytt{name}) = 
            \bigl\langle L1 + L2 + \mytt{[}\; \mytt{iadd} \;\mytt{]}, \max(s_1, 1+s_2) \bigr\rangle.
\end{array}$
\\[0.2cm]
Figure \ref{fig:Compiler.ipynb:compile:iadd} on page \pageref{fig:Compiler.ipynb:compile:iadd} shows how the
translation of the addition of expressions is implemented.  The translation of subtraction, multiplication, and
division is similar.

\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = last,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
               ]{python3}
    def compile_expr(expr, st, class_name):
        ...
        elif expr[0] == '+':
            _, lhs, rhs = expr
            L1, sz1 = compile_expr(lhs, st, class_name)
            L2, sz2 = compile_expr(rhs, st, class_name)
            Cmd     = indent('iadd')
            return L1 + L2 + [Cmd], max(sz1, 1 + sz2) 
        ...
\end{minted}
\vspace*{-0.3cm}
\caption{Translation of the addition of expressions.}
\label{fig:Compiler.ipynb:compile:iadd}
\end{figure}


\subsubsection{Translation of a Function Call}
In order to translate a function call of the form  $f(a_1, \cdots, a_n)$ we first have to translate the
arguments $a_1$, $\cdots$, $a_n$.  Then there are two cases:
\begin{enumerate}
\item $f$ is a user defined function.  In this case, the byte code treats $f$ as a static function of the
      class \mytt{class\_name}.  This static function can be called using the assembler command
      \mytt{invokestatic}.  In order to calculate the stack size that needs to be reserved for the evaluation
      of  $f(a_1, \cdots, a_n)$, let us assume that we have
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mytt{compile}(a_i, \mytt{st}, \mytt{class\_name}) = \pair(L_i, s_i)$,
      \\[0.2cm]
      i.e.~evaluation of the $i^\mathrm{th}$ argument is done by the list of assembler commands $L_i$ and
      needs a stack size of $s_i$.  As we are evaluating the arguments $a_i$ in the order from $a_1$ to $a_n$,
      the evaluation of $a_i$ needs a stack size of $i-1 + s_i$, since the results from the evaluation of
      the arguments $a_1$, $\cdots$, $a_{i-1}$ are already placed on the stack.  Therefore, if we define
      \\[0.2cm]
      \hspace*{1.3cm}
      $s := \max(s_1, 1 + s_2, \cdots, i - 1 + s_i, \cdots, n-1 + s_n)$,
      \\[0.2cm]
      then $s$ is the total amount of stack size needed to evaluate the arguments.  Furthermore, let us define
      the \blue{signature} of $f$ as the string
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mytt{fs} := \mytt{class\_name/}\mytt{f(}\underbrace{\mytt{I}\cdots\mytt{I}}_{n}\mytt{)I}$.
      \\[0.2cm]
      Then we can define the
      value of
      $\mytt{compile}\bigl(f(a_1,\cdots,a_n), \mytt{st}, \mytt{class\_name}\bigr)$ as follows:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mytt{compile}\bigl(f(a_1,\cdots,a_n), \mytt{st}, \mytt{class\_name}\bigr) :=
      \bigl\langle L_1 + \cdots + L_n + \mytt{[} \; \mytt{invokestatic}\; \mytt{fs} \;\mytt{]}, \max(s,1)\bigr\rangle$.
\item If $f$ is the function \mytt{println}, then \textsl{Jasmin} treats $f$ as a method of the
      predefined object \mytt{java.lang.System.out}.
      This method can be invoked using the assembler command
      \mytt{invokevirtual}.  As before, let us assume that we have
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mytt{compile}(a_i, \mytt{st}, \mytt{class\_name}) = \pair(L_i, s_i)$.
      \\[0.2cm]
      This time, we have to start by putting the object \mytt{java.lang.System.out} onto the stack before we
      can evaluate any of the arguments.  Therefore, in order to calculate the stack size we now define
      \\[0.2cm]
      \hspace*{1.3cm}
      $s := \max(1 + s_1, 2 + s_2, \cdots, i - 1 + s_i, \cdots, n + s_n)$.
      \\[0.2cm]
      In this case we have to define the \blue{signature} of $f$ as the string
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mytt{fs} := \mytt{java/io/PrintStream/println(}\underbrace{\mytt{I}\cdots\mytt{I}}_{n}\mytt{)V}$.
      \\[0.2cm]
      Furthermore, we define the command \mytt{gs} for putting the object \mytt{java.lang.System.out} onto the
      stack as 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mytt{gs} :=  \mytt{getstatic java/lang/System/out Ljava/io/PrintStream;}$.
      \\[0.2cm]
      Then we can define the
      value of
      $\mytt{compile}\bigl(f(a_1,\cdots,a_n), \mytt{st}, \mytt{class\_name}\bigr)$ as follows:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\mytt{compile}\bigl(f(a_1,\cdots,a_n), \mytt{st}, \mytt{class\_name}\bigr) := \\[0.1cm]
      \hspace*{2.8cm} \bigl\langle \mytt{[} \;\mytt{gs} \;\mytt{]} + L_1 + \cdots + L_n +
                   \mytt{[} \; \mytt{invokestatic}\; \mytt{fs} \;\mytt{]}, \max(s,1)\bigr\rangle$.
      \end{enumerate}

Figure \ref{fig:Compiler.ipynb:compile:iadd} on page \pageref{fig:Compiler.ipynb:compile:iadd} shows how the
translation of function calls is implemented.  

\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = last,
                 bgcolor       = sepia,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
               ]{python3}
    def compile_expr(expr, st, class_name):
        ...
        elif expr[0] == 'call' and expr[1] == 'println':
            _, _, *args = expr
            CmdLst    = ['getstatic java/lang/System/out Ljava/io/PrintStream;')
            stck_size = 0
            cnt       = 0
            for arg in args:
                L, sz_arg = compile_expr(arg, st, class_name)
                stck_size = max(stck_size, cnt + 1 + sz_arg)
                CmdLst   += L
                cnt      += 1
            CmdLst += [f'invokevirtual java/io/PrintStream/println({"I"*cnt})V']
            return CmdLst, stck_size
        elif expr[0] == 'call' and expr[1] != 'println':
            _, f, *args = expr
            CmdLst    = []
            stck_size = 0
            cnt       = 0
            for arg in args:
                L, sz_arg = compile_expr(arg, st, class_name)
                stck_size = max(stck_size, cnt + sz_arg)
                CmdLst   += L
                cnt      += 1
            CmdLst += [f'invokestatic {class_name}/{f}({"I"*cnt})I']
            return CmdLst, max(stck_size, 1)
        ...
\end{minted}
\vspace*{-0.3cm}
\caption{Translation of function calls.}
\label{fig:Compiler.ipynb:compile:call}
\end{figure}

\subsection{Übersetzung von Boole'schen Ausdrücken}
Boole'sche Ausdrücke werden aus Gleichungen und Ungleichungen mit Hilfe der logischen Operatoren
\qote{!} (Negation), \qote{\&\&} (Konjunktion) und \qote{||} (Disjunktion) aufgebaut.
Wir beginnen mit der Übersetzung von Gleichungen.

\subsubsection{Übersetzung von Gleichungen}
Bevor wir eine Gleichung der Form
\[ \textsl{lhs}\; \mytt{==} \;\textsl{rhs} \]
übersetzen können, müssen wir uns überlegen, was der erzeugte Code überhaupt erreichen soll.  Eine
naheliegende Forderung ist, dass am Ende auf dem Stack eine 1 abgelegt wird, wenn die Werte der
beiden Ausdrücke \textsl{lhs} und \textsl{rhs} übereinstimmen.  Andernfalls soll auf dem Stack eine
0 abgelegt werden.  Die Übersetzung kann unter diesen Annahmen wie folgt ablaufen:


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class Equation extends BoolExpr {
        private Expr mLhs;
        private Expr mRhs;
    
        public Equation(Expr lhs, Expr rhs) {
            mLhs = lhs;
            mRhs = rhs;
        }
        public List<AssemblerCmd> compile(Map<String, Integer> symbolTable) {
            List<AssemblerCmd> result = mLhs.compile(symbolTable);
            result.addAll(mRhs.compile(symbolTable));
            LABEL        trueLabel = new LABEL();
            LABEL        nextLabel = new LABEL();
            AssemblerCmd if_icmpeq = new IF_ICMPEQ(trueLabel.getLabel());
            AssemblerCmd bipush0   = new BIPUSH(0);
            AssemblerCmd gotoNext  = new GOTO(nextLabel.getLabel());
            AssemblerCmd bipush1   = new BIPUSH(1);
            result.add(if_icmpeq);
            result.add(bipush0);
            result.add(gotoNext);
            result.add(trueLabel);
            result.add(bipush1);
            result.add(nextLabel);
            return result;
        }
        public Integer stackSize() {
            return Math.max(mLhs.stackSize(), mRhs.stackSize() + 1);
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \mytt{Equation}.}
\label{fig:Expr:Equation.java}
\end{figure}

\begin{enumerate}
\item Zunächst erzeugen wir in den Zeilen 10 und 11 den Code zur Auswertung von \textsl{lhs} und \textsl{rhs}.
      Wenn dieser Code abgearbeitet worden ist, liegen die Werte von \textsl{lhs} und \textsl{rhs}
      auf dem Stack.
\item Anschließend überprüfen wir mit Hilfe des Befehls \mytt{if\_icmpeq}, ob die beiden Werte
      gleich sind.  Falls dies so ist, legen wir eine 1 auf den Stack, sonst eine 0.
\end{enumerate}
Damit hat der erzeugte Code insgesamt die folgende Form
\[
   \begin{array}[t]{lcl}
   \textsl{compile}(\textsl{lhs}\;\mytt{==}\;\textsl{rhs}) & = & 
         \textsl{lhs}.\textsl{compile}()  \\
   & + & \textsl{rhs}.\textsl{compile}()  \\
   & + & [ \;\mytt{if\_icmpeq}\; \textsl{true} \; ]  \\
   & + & [ \;\mytt{bipush}\;0\; ]  \\
   & + & [ \;\mytt{goto}\;\textsl{next}\; ]  \\
   & + & [ \;\textsl{true}\mytt{:}\; ]  \\
   & + & [ \;\mytt{bipush}\;1\; ]  \\
   & + & [ \;\textsl{next}\mytt{:}\; ]  \\
   \end{array}
\]
Diese Gleichung ist in der Methode $\textsl{compile}()$ der Klasse \mytt{Equation} eins zu eins umgesetzt worden.

\subsubsection{Übersetzung von negierten Gleichungen}
Die Übersetzung einer negierten Gleichung der Form
\[ \textsl{lhs}\;\mytt{!=}\;\textsl{rhs} \]
verläuft analog zu der Übersetzung einer Gleichung, denn wir müssen hier nur den Befehl \mytt{if\_icmpeq}
durch den Befehl \mytt{if\_icmpne} ersetzen.  Daher lautet die Spezifikation
\[
   \begin{array}[t]{lcl}
   \textsl{compile}(\textsl{lhs}\;\mytt{!=}\;\textsl{rhs}) & = & 
         \textsl{lhs}.\textsl{compile}()  \\
   & + & \textsl{rhs}.\textsl{compile}()  \\
   & + & [ \;\mytt{if\_icmpne}\; \textsl{true} \; ]  \\
   & + & [ \;\mytt{bipush}\;0\; ]  \\
   & + & [ \;\mytt{goto}\;\textsl{next}\; ]  \\
   & + & [ \;\textsl{true}\mytt{:}\; ]  \\
   & + & [ \;\mytt{bipush}\;1\; ]  \\
   & + & [ \;\textsl{next}\mytt{:}\; ]  \\
   \end{array}
\]
Dies kann wieder eins zu eins umgesetzt werden.  Aus Platzgründen verzichten wir darauf, die Klasse 
\mytt{Inequation} zu präsentieren.

\subsubsection{Übersetzung von Ungleichungen}
The compilation of inequations of the form 
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{lhs} \;\mytt{<=}\; \textsl{rhs}$, \quad 
$\textsl{lhs} \;\mytt{<}\; \textsl{rhs}$, \quad 
$\textsl{lhs} \;\mytt{>=}\; \textsl{rhs}$, \quad and \quad
$\textsl{lhs} \;\mytt{<}\; \textsl{rhs}$,
\\[0.2cm]
is essentially the same as the compilation of equations.  We only have to replace the assembler
command \mytt{if\_icmpeq} with either \mytt{if\_icmple}, \mytt{if\_icmplt},
\mytt{if\_icmpge}, or \mytt{if\_icmpgt}.

\subsubsection{Übersetzung von Konjunktionen}
Die Übersetzung einer Konjunktion der Form
\[ \textsl{lhs}\;\mytt{\&\&}\;\textsl{rhs} \]
kann wie folgt spezifiziert werden:
\[
   \begin{array}[t]{lcl}
   \textsl{compile}(\textsl{lhs}\;\mytt{\&\&}\;\textsl{rhs}) & = & 
         \textsl{lhs}.\textsl{compile}()  \\
   & + & \textsl{rhs}.\textsl{compile}()  \\
   & + & [ \;\mytt{iand}\; ]  
\end{array}
\]
Abbildung \ref{fig:Expr:Conjunction.java} zeigt die Umsetzung dieser Gleichung.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class Conjunction extends BoolExpr {
        private BoolExpr mLhs;
        private BoolExpr mRhs;
    
        public Conjunction(BoolExpr lhs, BoolExpr rhs) {
            mLhs = lhs;
            mRhs = rhs;
        }
        public List<AssemblerCmd> compile(Map<String, Integer> symbolTable) {
            List<AssemblerCmd> result = mLhs.compile(symbolTable);
            result.addAll(mRhs.compile(symbolTable));
            AssemblerCmd iand = new IAND();
            result.add(iand);
            return result;
        }
        public Integer stackSize() {
            return Math.max(mLhs.stackSize(), mRhs.stackSize() + 1);
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \mytt{Conjunction}.}
\label{fig:Expr:Conjunction.java}
\end{figure}

Die obige Umsetzung entspricht allerdings nicht dem, was in der Sprache \mytt{C}
tatsächlich passiert.  Dort wird die Auswertung eines Ausdrucks der Form 
\\[0.2cm]
\hspace*{1.3cm}
\textsl{lhs} \mytt{\&\&} \textsl{rhs}
\\[0.2cm]
abgebrochen, sobald das Ergebnis der Auswertung feststeht.  Liefert die Auswertung
von \textsl{lhs} als Ergebnis eine $0$, so wird der Ausdruck \textsl{rhs} nicht mehr
ausgewertet.  Falls dieser Ausdruck Seiteneffekte hat, ist das Ergebnis der Auswertung dann
also verschieden von unserer Auswertung.

Eine Disjunktion wird in analoger Weise auf den Assembler-Befehl \mytt{ior} zurück geführt.

\subsubsection{Übersetzung von Negationen}
Die Übersetzung einer Negation der Form $\mytt{!}\textsl{expr}$ kann nicht so geradlinig behandelt
werden wie die Übersetzung von Konjunktionen und Disjunktionen.  Das liegt daran, dass es einen
Assembler-Befehl \mytt{inot}, der den oben auf dem Stack liegenden Wert negiert, nicht gibt.
Aber es geht auch anders, denn weil wir die Wahrheitswerte durch 1 und 0 darstellen, können wir die
Negation arithmetisch wie folgt spezifizieren:
\[ \mytt{!}x = 1 - x. \]
Damit verläuft die Übersetzung einer Negation nach dem folgenden Schema:
\[
   \begin{array}[t]{lcl}
   \textsl{compile}(\mytt{!}\textsl{expr}) & = & 
         [\;\mytt{bipush}\;1\;]  \\
   & + & \textsl{expr}.\textsl{compile}()  \\
   & + & [\;\mytt{isub}\;]  
\end{array}
\]
Abbildung \ref{fig:Expr:Negation.java} zeigt die Umsetzung dieser Idee.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class Negation extends BoolExpr {
        private BoolExpr mExpr;
    
        public Negation(BoolExpr expr) {
            mExpr = expr;
        }
        public List<AssemblerCmd> compile(Map<String, Integer> symbolTable) {
            List<AssemblerCmd> result = new LinkedList<AssemblerCmd>();
            AssemblerCmd bipush1 = new BIPUSH(1);
            AssemblerCmd isub    = new ISUB();
            result.add(bipush1);
            result.addAll(mExpr.compile(symbolTable));
            result.add(isub);
            return result;
        }
        public Integer stackSize() {
            return mExpr.stackSize() + 1;
        }    
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \mytt{Negation}.}
\label{fig:Expr:Negation.java}
\end{figure}


\subsection{How to Compile a Statement}
Next, we show how statements are compiled.  First of all, we agree that the execution of a statement
must not change the size of the stack:  The size of stack before the execution of a statement must
be the same as the size of the stack after after the statement has been executed.
Of course, during the execution of the statement the stack may well
grow.  But once the execution of the statement has finished, the stack has to be cleaned from all
intermediate values that have been put on the stack during the execution of the statement.


\subsubsection{Übersetzung von Zuweisungen}
Wir untersuchen als erstes, wie eine Zuweisung der Form
\[ x \;\mytt{=}\; \textsl{expr} \]
übersetzt werden kann.  Die Grundidee besteht darin, zunächst den Ausdruck \textsl{expr}
auszuwerten.  Als Folge dieser Auswertung wird dann ein Wert auf dem Stack zurück bleiben, der das
Ergebnis dieser Auswertung ist.  Diesen Wert können wir mit dem Befehl \mytt{istore} unter der
Variable $x$ abspeichern.  Folglich kann die Übersetzung einer Zuweisung wie folgt spezifiziert werden:
\[
   \begin{array}[t]{lcl}
   \textsl{compile}(x \mytt{=} \textsl{expr}) & = & 
         \textsl{expr}.\textsl{compile}()  \\
   & + & [\;\mytt{istore}\;x\;]  
\end{array}
\]
Die Idee wird in der in Abbildung \ref{fig:Statement:Assign.java} gezeigten Klasse
\mytt{Assign} umgesetzt.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class Assign extends Statement {
        private String mVar;
        private Expr   mExpr;
    
        public Assign(String var, Expr expr) {
            mVar  = var;
            mExpr = expr;
        }
        public List<AssemblerCmd> compile(Map<String, Integer> symbolTable) {
            List<AssemblerCmd> result   = mExpr.compile(symbolTable);
            AssemblerCmd       storeCmd = new ISTORE(symbolTable.get(mVar));
            result.add(storeCmd);
            return result;
        }
        public Integer stackSize() {
            return mExpr.stackSize();
        }    
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \mytt{Assign}.}
\label{fig:Statement:Assign.java}
\end{figure}

\subsubsection{Übersetzung von Ausdrücken als Befehlen}
Die Übersetzung eines Ausdrucks, der als Befehl verwendet wird, birgt eine Tücke:
Die Übersetzung des Ausdrucks selber hinterlässt auf dem Stack einen Wert.  Dieser muss aber bei
Beendigung des Befehls vom Stack entfernt werden!  Daher müssen wir den Befehl \mytt{pop} an das
Ende der Liste der Assembler-Befehle anfügen, die bei der Übersetzung des Ausdrucks erzeugt werden.
Die Übersetzung eines  Befehls vom Typ \mytt{ExprStatement} wird also
wie folgt spezifiziert:
\[
   \begin{array}[t]{lcl}
   \textsl{compile}(\textsl{expr}\mytt{;}) & = & 
         \textsl{expr}.\textsl{compile}()  \\
   & + & [\;\mytt{pop}\;]  
\end{array}
\]
Abbildung \ref{fig:Statement:ExprStatement.java} zeigt die Klasse \mytt{ExprStatement}, in der
diese Überlegung umgesetzt wird.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class ExprStatement extends Statement {
        private Expr mExpr;
    
        public ExprStatement(Expr expr) {
            mExpr = expr;
        }
        public List<AssemblerCmd> compile(Map<String, Integer> symbolTable) {
            List<AssemblerCmd> result = mExpr.compile(symbolTable);
            AssemblerCmd       popCmd = new POP();
            result.add(popCmd);
            return result;
        }    
        public Integer stackSize() {
            return mExpr.stackSize();
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \mytt{ExprStatement}.}
\label{fig:Statement:ExprStatement.java}
\end{figure}

\subsubsection{Die Übersetzung von Verzweigungs-Befehlen}
Als nächstes überlegen wir, wie ein Verzweigungs-Befehl der Form
\[ \mytt{if}\; (\textsl{expr})\; \textsl{statement} \]
übersetzt werden kann.  Offenbar muss zunächst der Boole'sche Ausdruck \textsl{expr} übersetzt
werden.  Die Auswertung dieses Ausdrucks wird auf dem Stack entweder eine 1 oder eine 0
hinterlassen, je nachdem, ob die Bedingung des Tests wahr oder falsch wahr.  Mit dem Befehl
\mytt{ifeq} können wir überprüfen, welcher dieser beiden Fälle vorliegt.  
Das führt zu der folgenden Spezifikation:
\[
   \begin{array}[t]{lcl}
   \textsl{compile}\bigl(\mytt{if}\; (\textsl{expr})\;\textsl{statement}\bigr) & = & 
         \textsl{expr}.\textsl{compile}()  \\
   & + & [\;\mytt{ifeq}\;\textsl{else}\;] \\
   & + & \textsl{statement}.\textsl{compile}() \\
   & + & [\;\textsl{else}\mytt{:}\;]        
\end{array}
\]
Diese Spezifikation ist in der Abbildung \ref{fig:Statement:IfThen.java} umgesetzt worden.



\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class IfThen extends Statement {
        private BoolExpr  mBoolExpr;
        private Statement mStatement;
    
        public IfThen(BoolExpr boolExpr, Statement statement) {
            mBoolExpr = boolExpr;
            mStatement = statement;
        }
        public List<AssemblerCmd> compile(Map<String, Integer> symbolTable) {
            List<AssemblerCmd> result = mBoolExpr.compile(symbolTable);
            LABEL        elseLabel = new LABEL();
            AssemblerCmd ifeq      = new IFEQ(elseLabel.getLabel());
            result.add(ifeq);
            result.addAll(mStatement.compile(symbolTable));
            result.add(elseLabel);
            return result;
        }
        public Integer stackSize() {
            return Math.max(mBoolExpr.stackSize(), mStatement.stackSize());
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \mytt{IfThen.java}}
\label{fig:Statement:IfThen.java}
\end{figure}

\vspace*{0.1cm}

Die Übersetzung eines Verzweigungs-Befehls der Form
\[ \mytt{if}\; (\textsl{expr})\; \textsl{thenStmnt} \;\mytt{else}\; \textsl{elseStmnt} \]
erfolgt in analoger Art und Weise.  Diesmal lautet die Spezifikation:
\[
   \begin{array}[t]{lcl}
   \textsl{compile}\bigl(\mytt{if}\; (\textsl{expr})\;\textsl{thenStmnt}\;\mytt{else}\;\textsl{elseStmnt}\bigr) & = & 
         \textsl{expr}.\textsl{compile}()  \\
   & + & [\;\mytt{ifeq}\;\textsl{else}\;] \\
   & + & \textsl{thenStmnt}.\textsl{compile}() \\
   & + & [\;\mytt{goto}\;\textsl{next}\;]    \\    
   & + & [\;\textsl{else}\mytt{:}\;]         \\
   & + & \textsl{elseStmnt}.\textsl{compile}()\;]    \\    
   & + & [\;\textsl{next}\mytt{:}\;]         
\end{array}
\]
Diese Spezifikation ist in der Abbildung \ref{fig:Statement:IfThenElse.java} umgesetzt worden.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    public class IfThenElse extends Statement {
        private BoolExpr  mExpr;
        private Statement mThen;
        private Statement mElse;
    
        public IfThenElse(BoolExpr expr, Statement thenStmnt, Statement elseStmnt) {
            mExpr = expr;
            mThen = thenStmnt;
            mElse = elseStmnt;
        }
        public List<AssemblerCmd> compile(Map<String, Integer> symbolTable) {
            List<AssemblerCmd> result = mExpr.compile(symbolTable);
            LABEL        elseLabel = new LABEL();
            LABEL        nextLabel = new LABEL();
            AssemblerCmd ifeq      = new IFEQ(elseLabel.getLabel());
            AssemblerCmd gotoNext  = new GOTO(nextLabel.getLabel());
            result.add(ifeq);
            result.addAll(mThen.compile(symbolTable));
            result.add(gotoNext);
            result.add(elseLabel);
            result.addAll(mElse.compile(symbolTable));
            result.add(nextLabel);
            return result;
        }
        public Integer stackSize() {
            return Math.max(mExpr.stackSize(), Math.max(mThen.stackSize(), mElse.stackSize()));
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \mytt{IfThenElse}.}
\label{fig:Statement:IfThenElse.java}
\end{figure}

\subsubsection{Die Übersetzung einer Schleife}
Die Übersetzung einer \mytt{while}-Schleife der Form
\[ \mytt{while}\;(\textsl{cond})\;\textsl{statement} \]
orientiert sich an der folgenden Spezifikation:
\[
   \begin{array}[t]{lcl}
   \textsl{compile}\bigl(\mytt{while}\; (\textsl{cond})\;\textsl{stmnt}\bigr) & = & 
         [\;\textsl{loop}\mytt{:}\;]            \\
   & + & \textsl{cond}.\textsl{compile}()         \\
   & + & [\;\mytt{ifeq}\;\textsl{next}\;] \\
   & + & \textsl{stmnt}.\textsl{compile}()    \\    
   & + & [\;\mytt{goto}\;\textsl{loop}\;]    \\    
   & + & [\;\textsl{next}\mytt{:}\;]         
\end{array}
\]
Die Umsetzung dieser Spezifikation sehen Sie in Abbildung \ref{fig:Statement:While.java}.
 \begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class While extends Statement {
        private BoolExpr  mCondition;
        private Statement mStatement;
    
        public While(BoolExpr condition, Statement statement) {
            mCondition = condition;
            mStatement = statement;
        }
        public List<AssemblerCmd> compile(Map<String, Integer> symbolTable) {
            List<AssemblerCmd> result = new LinkedList<AssemblerCmd>();
            LABEL        loopLabel = new LABEL();
            LABEL        nextLabel = new LABEL();
            AssemblerCmd ifeq      = new IFEQ(nextLabel.getLabel());
            AssemblerCmd gotoLoop  = new GOTO(loopLabel.getLabel());
            result.add(loopLabel);
            result.addAll(mCondition.compile(symbolTable));
            result.add(ifeq);
            result.addAll(mStatement.compile(symbolTable));
            result.add(gotoLoop);
            result.add(nextLabel);
            return result;
        }
        public Integer stackSize() {
            return Math.max(mCondition.stackSize(), mStatement.stackSize());
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \mytt{While}.}
\label{fig:Statement:While.java}
\end{figure}

\subsubsection{Übersetzen einer Liste von Befehlen}
Eine in geschweiften Klammern eingeschlossene Liste von Befehlen der Form
\[ \{ \textsl{stmnt}_1\mytt{;}\; \cdots\; \textsl{stmnt}_n\mytt{;} \} \]
wird dadurch übersetzt, dass die Listen, die bei der Übersetzung der einzelnen Befehle
$\textsl{stmnt}_i$ entstehen, aneinander gehängt werden:
\[
   \begin{array}[t]{lcl}
   \textsl{compile}\bigl(\mytt{\{} \textsl{stmnt}_1\mytt{;}\; \cdots\; \textsl{stmnt}_n\mytt{;} \mytt{\}}\bigr) & = & 
         \textsl{compile}(\textsl{stmnt}_1) + \cdots + \textsl{compile}(\textsl{stmnt}_n).
   \end{array}
\]
Diese Idee ist in der Klasse \mytt{Block} realisiert worden. Abbildung
\ref{fig:Statement:Block.java} zeigt diese Klasse.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class Block extends Statement {
        private List<Statement> mStatementList;
    
        public Block(List<Statement> statementList) {
            mStatementList = statementList;
        }
        public List<AssemblerCmd> compile(Map<String, Integer> symbolTable) {
            List<AssemblerCmd> result = new LinkedList<AssemblerCmd>();
            for (Statement stmnt: mStatementList) {
                result.addAll(stmnt.compile(symbolTable));
            }
            return result;
        }
        public Integer stackSize() {
            Integer biggest = 0;
            for (Statement stmnt: mStatementList) {
                biggest = Math.max(biggest, stmnt.stackSize());
            }
            return biggest;
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \mytt{Block}.}
\label{fig:Statement:Block.java}
\end{figure}

\subsection{Zusammenspiel der Komponenten}
Nachdem wir jetzt gesehen haben, wie die einzelnen Teile eines Programms in Listen von
Assembler-Befehlen übersetzt werden können, müssen wir noch zeigen, wie die einzelnen Komponenten
unseres Programms zusammen spielen.  Dazu sind noch zwei Klassen zu diskutieren:
\begin{enumerate}
\item Die Klasse \mytt{Function} repräsentiert die Definition einer Funktion.
\item Die Klasse \mytt{Program}  repräsentiert das vollständige Programm.
\end{enumerate}
Wir beginnen mit der Diskussion der Klasse \mytt{Function}.  Abbildung
\ref{fig:Compiler:Function.java} zeigt die Klasse \mytt{Function}, allerdings ohne die
Implementierung der Methode $\textsl{compile}()$, die wir aus Platzgründen in die Abbildung
\ref{fig:Compiler:Function.compile} ausgelagert haben.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.3cm,
                  xrightmargin  = 0.3cm,
                ]
    public class Function {
        private String            mName;
        private List<String>      mParameterList;
        private List<Declaration> mDeclarations;
        private List<Statement>   mBody;
        
        private Integer           mLocals; // number of local variables
    
        public Function(String            name, 
                        List<String>      parameterList, 
                        List<Declaration> declarations, 
                        List<Statement>   body) 
        {
            mName          = name;
            mParameterList = parameterList;
            mDeclarations  = declarations;
            mBody          = body;
            mLocals        = mParameterList.size() + mDeclarations.size();
        }
        public List<AssemblerCmd> compile() { ... }
        public Integer stackSize() { ... }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \mytt{Function}.}
\label{fig:Compiler:Function.java}
\end{figure}


Die Klasse \mytt{Function} enthält vier Member-Variablen:
\begin{enumerate}
\item \mytt{mName} gibt den Namen der Funktion an.
\item \mytt{mParameterList} ist die Liste der Parameter, 
      mit der die Funktion aufgerufen wird.
\item \mytt{mDeclarations} ist die Liste der Variablen-Deklarationen.
\item \mytt{mBody} ist die Liste von Befehlen, die im Rumpf der Funktion
      ausgeführt werden.
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public List<AssemblerCmd> compile() {
        Map<String, Integer> symbolTable = new TreeMap();
        Integer count = 0;
        for (String var: mParameterList) {
            symbolTable.put(var, count);
            ++count;
        }
        for (Declaration decl: mDeclarations) {
            symbolTable.put(decl.getVar(), count);
            ++count;
        }
        Integer stackSize = 0;
        for (Statement stmnt: mBody) {
            stackSize = Math.max(stackSize, stmnt.stackSize());
        }
        List<AssemblerCmd> result = new LinkedList<AssemblerCmd>();
        AssemblerCmd nl = new NEWLINE();
        result.add(nl);
        if (mName.equals("main")) {
            AssemblerCmd main        = new MAIN();
            AssemblerCmd limitLocals = new LIMIT("locals", mLocals);
            AssemblerCmd limitStack  = new LIMIT("stack", stackSize);
            result.add(main);
            result.add(limitLocals);
            result.add(limitStack);
            for (Statement stmnt: mBody) {
                result.addAll(stmnt.compile(symbolTable));
            }
            AssemblerCmd myReturn = new RETURN();
            AssemblerCmd endMain  = new END_METHOD();
            result.add(myReturn);
            result.add(endMain);
        } else {
            AssemblerCmd method      = new METHOD(mName, mParameterList.size());
            AssemblerCmd limitLocals = new LIMIT("locals", mLocals);
            AssemblerCmd limitStack  = new LIMIT("stack", stackSize);
            result.add(method);
            result.add(limitLocals);
            result.add(limitStack);
            for (Statement stmnt: mBody) {
                result.addAll(stmnt.compile(symbolTable));
            }
            AssemblerCmd endMethod = new END_METHOD();
            result.add(endMethod);
        }
        return result;
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Methode $\textsl{compile}()$.}
\label{fig:Compiler:Function.compile}
\end{figure}

\vspace*{\fill}
\pagebreak

\vspace*{\fill}
\pagebreak

Die eigentliche Arbeit der Klasse \mytt{Funktion} wird in der Methode $\textsl{compile}()$, die in Abbildung
\ref{fig:Compiler:Function.compile} gezeigt ist, geleistet.  Es sind zwei Fälle zu unterscheiden:
\begin{enumerate}
\item Falls die zu übersetzende Funktion den Namen \squoted{main} hat, so hat der erzeugte
      Code die folgende Form:

      \begin{Verbatim}[ frame         = lines, 
                        framesep      = 0.3cm, 
                        labelposition = bottomline,
                        numbers       = left,
                        numbersep     = -0.2cm,
                        xleftmargin   = 0.8cm,
                        xrightmargin  = 0.8cm,
                        commandchars  = \\\{\},
                        codes={\catcode`$=3\catcode`^=7\catcode`_=8}
                      ]
            .method public static main([Ljava/lang/String;)V
            .limit locals \(l\) 
            .limit stack \(s\)
               \(s_1\)
               \(\vdots\)
               \(s_n\)
               return
            .end-main
       \end{Verbatim}
       % \$

       Hier bezeichnet $l$ die Anzahl der in der Funktion \mytt{main} verwendeten lokalen Variablen,
       $s$ ist die maximale Höhe des Stacks
       und $s_1$, $\cdots$, $s_n$ bezeichnen die einzelnen Assemblerbefehle, die bei der Übersetzung
       des Rumpfes der Funktion erzeugt werden.

\item Andernfalls hat der erzeugte Code die folgende Form:

      \begin{Verbatim}[ frame         = lines, 
                        framesep      = 0.3cm, 
                        labelposition = bottomline,
                        numbers       = left,
                        numbersep     = -0.2cm,
                        xleftmargin   = 0.8cm,
                        xrightmargin  = 0.8cm,
                        commandchars  = \\\{\},
                        codes={\catcode`$=3\catcode`^=7\catcode`_=8}
                      ]
            .method public static \(f\)(I\(\cdots\)I)I
            .limit locals \(l\) 
            .limit stack \(s\)
               \(s_1\)
               \(\vdots\)
               \(s_n\)
            .end-method
       \end{Verbatim}
       % $
       
       Hier bezeichnet $f$ den Namen der Funktion,  $l$ ist die Anzahl der in der Funktion verwendeten lokalen Variablen
       und $s$ ist die maximale Höhe des Stacks.
       Weiter sind $s_1$, $\cdots$, $s_n$ die Assemblerbefehle des Rumpfes der Funktion.
\end{enumerate}
Abbildung \ref{fig:Compiler:Function.stackSize} zeigt die Implementierung der Funktion
\mytt{stackSize}. Da die einzelnen Befehle nichts auf dem Stack zurück lassen dürfen, ergibt sich
die Höhe des Stacks, der zur Ausführung aller Befehle benötigt wird, als das Maximum der Höhen der
einzelnen Befehle.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public Integer stackSize() {
        Integer biggest = 0;
        for (Statement stmnt: mBody) {
            biggest = Math.max(biggest, stmnt.stackSize());
        }
        return biggest;
    }    
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Computing the size of the stack}
\label{fig:Compiler:Function.stackSize}
\end{figure}


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.5cm,
                  xrightmargin  = 0.5cm,
                ]    
    public class Program {
        private List<Function> mFunctionList;
    
        public Program(List<Function> functionList) {
            mFunctionList = functionList;
        }
        public List<AssemblerCmd> compile() {
            List<AssemblerCmd> fctList = new LinkedList<AssemblerCmd>();
            int indexMain = mFunctionList.size() - 1;
            Function main = mFunctionList.get(indexMain);
            fctList.addAll(main.compile());
            for (int i = 0; i < indexMain; ++i) {
                Function f = mFunctionList.get(i);
                fctList.addAll(f.compile());
            }
            return fctList;
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \mytt{Program}.}
\label{fig:Program.java}
\end{figure}
 
\noindent
Zum Abschluss diskutieren wir die Klasse \mytt{Program}, die in Abbildung
\ref{fig:Program.java} gezeigt wird.  Diese Klasse verwaltet in der Member-Variablen
\mytt{mFunctionList} die Liste aller zu übersetzenden Funktionen.  

Bei der Übersetzung der Funktionen ist darauf zu achten, dass zuerst die Funktion $\textsl{main}()$
übersetzt wird, denn diese muss am Anfang der erzeugten Assembler-Datei stehen.  In der
\mytt{C}-Datei ist die Funktion $\textsl{main}()$ aber die letzte Funktion, denn in der Sprache
\mytt{C} müssen alle Funktionen vor ihrer Verwendung deklariert worden sein.

Wie übersetzen in Zeile 11 als erstes die Funktion $\textsl{main}()$.  Anschließend werden in der
Schleife, die sich von Zeile 12 bis 15 erstreckt, die restlichen Funktionen übersetzt.
Der erzeugte Code befindet sich dann in der Liste \mytt{fctList}, die als Ergebnis zurück gegeben wird.  


Übersetzen wir die in Abbildung
\ref{fig:sum.c} gezeigte Funktion zur Berechnung der Summe $\sum_{i=1}^n i$ mit dem Compiler, so
erhalten wir die in Abbildungen \ref{fig:sum.jas} gezeigte Assembler-Datei, bei der wir zur Vereinfachung den
Code zur Initialisierung, der immer gleich ist, weggelassen haben.
Vergleichen wir dieses Programm mit dem in Abbildung \ref{fig:sum.jas} gezeigten
Assembler-Programm, das wir von Hand geschrieben haben, so fällt auf, dass das vom Compiler erzeugte Programm 
deutlich länger ist.  Es wäre nun Aufgabe eines Code-Optimierers, den erzeugten Code zu verkürzen
und dadurch zu optimieren.  Eine Diskussion von Techniken zur Code-Optimierung geht allerdings über
den Rahmen der Vorlesung heraus. 

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                 framesep      = 0.3cm, 
                 firstnumber   = 1,
                 numbers       = left,
                 numbersep     = -0.2cm,
                 xleftmargin   = 0.8cm,
                 xrightmargin  = 0.8cm,
               ]
    .method public static main([Ljava/lang/String;)V
    .limit locals 1
    .limit stack  2
            ldc 6
            ldc 6
            imul
            istore 0
            getstatic java/lang/System/out Ljava/io/PrintStream;
            iload 0
            invokestatic MySum/sum(I)I
            invokevirtual java/io/PrintStream/println(I)V
            bipush 42
            pop
            return
    .end method
      
    .method public static sum(I)I
    .limit locals 2
    .limit stack  2
            ldc 0
            istore 1
        l3:
            iload 0
            ldc 0
            if_icmpne l1
            bipush 0
            goto l2
        l1:
            bipush 1
        l2:
            ifeq l4
            iload 1
            iload 0
            iadd
            istore 1
            iload 0
            ldc 1
            isub
            istore 0
            goto l3
        l4:
            iload 1
            ireturn
    .end method
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Der von unserem Compiler erzeugte Code.}
\label{fig:sum.jas}
\end{figure}

\exerciseEng
The goal of this exercise is to extend the language supported by the compiler presented in this chapter.
\begin{enumerate}
\item[(a)] Extend the compiler so that \mytt{for}-loops are supported.  The syntax of these \mytt{for}-loops
           should be similar to the syntax of \mytt{for}-loops in the programming language \mytt{C}.
\item[(b)] Extend the compiler so that increment and decrement statements of the form
           \\[0.2cm]
           \hspace*{1.3cm}
           \mytt{++}\textsl{var}\mytt{;}  \quad and \quad
           \mytt{--}\textsl{var}\mytt{;}  
           \\[0.2cm]
           are supported.  As we only intend to use these statements in the update statement of a
           \mytt{for}-loop, there is no need to support these operators inside expressions. 
\end{enumerate}
In order to test your version of the compiler, rewrite the example integer-\mytt{C} program
presented in this chapter to use both a \mytt{for}-loop and the increment operator.  \eox


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "formal-languages"
%%% End: 
