\chapter{Der Parser-Generator \textsc{Cup} \label{chapter:cup} \label{chapter:ply}}
LALR-Parser erlauben es, die Grammatiken vieler Programmiersprachen in nat\"urlicher Weise
zu parsen.  Da die meisten von Ihnen in der Praxis vermutlich mit \textsl{Java} arbeiten, 
m\"ochte ich Ihnen in diesem Kapitel einen LALR-Parser-Generator vorstellen, der einen Parser f\"ur die
Programmiersprache \textsl{Java} erzeugt.  Dieses Kapitel gibt daher eine
Einf\"uhrung in die Verwendung des Parser-Generators \textsc{Cup} \cite{hudson:1999}, der auch
unter dem Namen \textsl{JavaCup} bekannt ist.
\textsc{Cup} selber ist nur ein Parser-Generator.  Da wir
zus\"atzlich einen Scanner ben\"otigen, werden wir diesen in unseren Beispielen von \textsl{JFlex}
erzeugen lassen.  Wir werden die Version 0.11b des Parser-Generators \textsc{Cup} 
verwenden.  Sie finden diese Version im Netz unter 
\\[0.2cm]
\hspace*{1.3cm}
\href{http://www2.cs.tum.edu/projects/cup/}{\texttt{http://www2.cs.tum.edu/projects/cup/}}.
\\[0.2cm]
Sie finden dort eine komprimierte ``\texttt{.tar}''-Datei, in der sich zwei
``\texttt{.jar}''-Dateien befinden.
\begin{enumerate}
\item Die Datei \texttt{java-cup-11b.jar} beinhaltet das ausf\"uhrbare Programm.
\item Die Datei \texttt{java-cup-11b-runtime.jar} enth\"alt die Klassen, die Sie beim \"Ubersetzen des
      von \textsc{Cup} erzeugten Parsers ben\"otigen.
\end{enumerate}

\section{Spezifikation einer Grammatik f\"ur  \textsc{Cup}}
Eine \textsc{Cup}-Spezifikation besteht aus vier Teilen.
\begin{enumerate}
\item Der erste Teil enth\"alt eine (optionale) Paket-Deklaration sowie die ben\"otigten
      Import-Deklarationen.  Au{\ss}erdem k\"onnen wir hier den Namen der Klasse spezifizieren, die den
      von \textsc{Cup} erzeugten Parser enth\"alt.
\item Der zweite Teil deklariert die verwendeten Symbole.  Hier werden also die Terminale
      und die syntaktischen Variablen spezifiziert.
\item Der dritte Teil ist wieder optional und spezifiziert die Pr\"azedenzen und Assoziativit\"aten 
      der verwendeten Operator-Symbolen.
\item Der vierte Teil enth\"alt die Grammatik-Regeln.
\end{enumerate}
Abbildung \ref{fig:calc.cup} auf Seite \pageref{fig:calc.cup} zeigt eine \textsl{Cup}-Spezifikation,
mit deren Hilfe arithmetische Ausdr\"ucke ausgewertet werden k\"onnen.  In dieser
\textsl{Cup}-Spezifikation sind die Schl\"usselw\"orter unterstrichen.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                  commandchars  = \\\{\}
                ]
    import java_cup.runtime.*;
    \underline{class} ExprParser;
    
    \underline{terminal}            SEMI, PLUS, MINUS, TIMES, DIVIDE, MOD;
    \underline{terminal}            LPAREN, RPAREN;
    \underline{terminal} Integer    NUMBER;
    
    \underline{nonterminal}         expr_list, expr_part;
    \underline{nonterminal} Integer expr, prod, fact;
    
    \underline{start} \underline{with} expr_list;

    expr_list ::= expr_list expr_part 
               |  expr_part
               ;
    
    expr_part ::= expr:e \{: System.out.println("result = " + e); :\} SEMI 
               ;
    
    expr ::= expr:e PLUS  prod:p \{: \underline{RESULT} = e + p; :\} 
          |  expr:e MINUS prod:p \{: \underline{RESULT} = e - p; :\} 
          |  prod:p              \{: \underline{RESULT} = p;     :\}
          ;
    
    prod ::= prod:p TIMES  fact:f \{: \underline{RESULT} = p * f; :\}
          |  prod:p DIVIDE fact:f \{: \underline{RESULT} = p / f; :\} 
          |  prod:p MOD    fact:f \{: \underline{RESULT} = p % f; :\} 
          |  fact:f               \{: \underline{RESULT} = f;     :\}
          ;
    
    fact ::= LPAREN expr:e RPAREN \{: \underline{RESULT} = e;   :\} 
          |  MINUS  fact:e        \{: \underline{RESULT} = - e; :\} 
          |  NUMBER:n             \{: \underline{RESULT} = n;   :\} 
          ;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\textsc{Cup}-Spezifikation eines Parsers f\"ur arithmetische Ausdr\"ucke}
\label{fig:calc.cup}
\end{figure}

\begin{enumerate}
\item Die gezeigte \textsc{Cup}-Spezifikation enth\"alt keine Paket-Deklarationen.
\item Die Spezifikation beginnt in Zeile 1 mit dem Import der Klassen von
      \texttt{java\_cup.runtime}.  Dieses Paket muss immer importiert werden, denn dort wird
      beispielsweise die Klasse \texttt{Symbol} 
      definiert, die wir auch sp\"ater noch in dem in Abbildung \ref{fig:calc.jflex} gezeigten Scanner
      verwenden werden.

      W\"urden noch weitere Pakete ben\"otigt, so k\"onnten diese hier ebenfalls importiert werden.
\item In Zeile 2 spezifizieren wir, dass die erzeugte Parser-Klasse den Namen \texttt{ExprParser}
      haben soll.
\item In den Zeilen 4 bis 6 werden die Terminale deklariert.  Es gibt zwei Arten von Terminalen:
      \begin{enumerate}
      \item Terminale, die keinen zus\"atzlichen Wert haben.  Hierbei handelt es sich 
            um die Operator-Symbole, die beiden Klammer-Symbole und das Semikolon.  Die Syntax zur
            Deklaration solcher Terminale ist 
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{terminal} $t_1$, $\cdots$, $t_n$;
            \\[0.2cm]
            Durch diese Deklaration werden die Symbole $t_1$, $\cdots$, $t_n$ als Terminale
            deklariert.
      \item Terminale, denen ein Wert zugeordnet ist.  In diesem Fall muss der Typ
            dieses Wertes deklariert werden.  Die Syntax daf\"ur ist 
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{terminal} \textsl{type} $t_1$, $\cdots$, $t_n$;
            \\[0.2cm]
            Hierbei spezifiziert \textsl{type} den Typ, der den Terminalen $t_1$, $\cdots$, $t_n$
            zugeordnet wird.
            
            Bei der Spezifikation eines Typs ist es wichtig zu beachten, dass zwischen dem Typ und
            dem ersten Terminal kein Komma steht, denn sonst w\"urde der Typ ebenfalls als Terminal
            interpretiert.  
            
            In Zeile 6 spezifizieren wir beispielsweise, dass dem Terminal \texttt{NUMBER} ein
            Wert vom Typ \texttt{Integer} zugeordnet ist.  Damit das funktioniert, muss der Scanner
            jedes Mal,
            wenn er ein Terminal \texttt{NUMBER} an den Parser zur\"uck geben soll, ein Objekt der
            Klasse  \texttt{Symbol} erzeugen, dass die entsprechende Zahl als Wert beinhaltet.
            In dem auf Seite \pageref{fig:calc.jflex}
            in Abbildung \ref{fig:calc.jflex} gezeigten Scanner geschieht dies beispielsweise
            in dadurch, dass mit Hilfe der Methode $\texttt{symbol}()$ der Konstruktor der
            Klasse \texttt{Symbol} aufgerufen wird, dem als zus\"atzliches Argument der Wert der Zahl
            \"ubergeben wird.
      \end{enumerate}
\item In den Zeilen 8 und 9 werden die syntaktischen Variablen, die wir auch als Nicht-Terminale
      bezeichnen, deklariert.  Die Syntax ist dieselbe wie bei der Deklaration der Terminale, nur
      dass wir jetzt das Schl\"usselwort ``\texttt{nonterminal}'' an Stelle von ``\texttt{terminal}''
      verwenden.  Auch hier gibt es wieder zwei F\"alle:  Den in Zeile 8 deklarierten Nicht-Terminalen
      \texttt{expr\_list} und \texttt{expr\_part} wird kein Wert zugeordnet, w\"ahrend wir dem
      Nicht-Terminal \textsl{expr} einen Wert vom Typ \texttt{Integer} zuordnen, der sich aus der
      Auswertung des entsprechenden arithmetischen Ausdrucks ergibt.
\item Der letzte Teil einer \textsc{Cup}-Grammatik-Spezifikation enth\"alt die Grammatik-Regeln. 
      Die allgemeine Form einer \textsc{Cup}-Grammatik-Regel ist
      \\[0.2cm]
      \hspace*{1.3cm}
      \textsl{var} \qote{::=} \textsl{body}$_1$ \qote{\{:} \textsl{action}$_1$ \qote{:\}} \\[0.1cm]
      \hspace*{2.05cm} \qote{|} \ \ \textsl{body}$_2$ \qote{\{:} \textsl{action}$_2$ \qote{:\}} \\[0.1cm]
      \hspace*{2.25cm} $\vdots$ \ \ \\[0.1cm]
      \hspace*{2.05cm} \qote{|} \ \ \textsl{body}$_n$ \qote{\{:} \textsl{action}$_n$ \qote{:\}}  \\[0.1cm]
      \hspace*{2.05cm} \qote{;} \\[0.1cm]
      Dabei gilt
      \begin{enumerate}
      \item \textsl{var} ist die syntaktische Variable, die von dieser Regel erzeugt wird.
      \item \textsl{body}$_i$ ist der Rumpf der $i$-ten Grammatik-Regel, der aus einer
            Liste von Terminalen und syntaktischen Variablen besteht.
      \item \textsl{action}$_i$ ist eine durch Semikolons getrennte Folge von \textsl{Java}-Anweisungen,
            die ausgef\"uhrt werden, falls der Stack des Shift/Reduce-Parsers, der die
            Symbole enth\"alt, mit der zugeh\"origen Regel reduziert wird.
      \end{enumerate}
      Bei der Spezifikation einer Grammatik-Regel mit \textsc{Cup} weicht die Syntax von der
      Syntax, die in \textsc{Antlr} verwendet wird, an mehreren Stellen ab: 
      \begin{enumerate}
      \item Statt eines einfachen Doppelpunkts ``\texttt{:}'' wird die Zeichenreihe ``\texttt{::=}''
            verwendet, um die zu definierende Variable vom Rumpf der Grammatik-Regel zu trennen.
      \item Die Kommandos werden bei \textsc{Cup} in den Zeichenreihen ``\texttt{\{:}'' und
            ``\texttt{:\}}'' eingeschlossen, w\"ahrend bei \textsc{Antlr} die geschweiften Klammern
            ``\texttt{\{}'' und ``\texttt{\}}'' ausgereicht haben.
      \item Um auf die Werte, die einem Terminal oder einer syntaktischen Variablen zugeordnet sind,
            zuzugreifen, hatten wir bei \textsc{Antlr} Zuweisungen  verwendet.
            Stattdessen m\"ussen wir nun jedem Symbol, 
            dessen Wert wir verwenden wollen, eine eigene Variable zuordnen, deren Namen wir
            getrennt von einem Doppelpunkt hinter das Symbol schreiben.  Um der durch die
            Grammatik-Regel definierten syntaktischen Variablen einen Wert zuzuweisen, verwenden wir
            das Schl\"usselwort ``\texttt{RESULT}''.  Betrachten wir als Beispiel die folgende Regel:
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{expr ::= expr:e PLUS prod:p \{: RESULT = e + p; :\};}
            \\[0.2cm]
            Mit \texttt{expr:e} sucht der Parser nach einem arithmetischen Ausdruck, dessen Wert in
            der Variablen \texttt{e} gespeichert wird.  Anschlie{\ss}end wird ein Plus-Zeichen gelesen
            und darauf folgt wieder ein Produkt, dessen Wert jetzt in \texttt{p}
            gespeichert wird.  Der Wert des insgesamt gelesenen Ausdrucks wird dann durch die Zuweisung
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{RESULT = e + p;}
            \\[0.2cm]
            berechnet und der linken Seite der Grammatik-Regel zugewiesen.
      \item Ein weiterer Unterschied zwischen \textsc{Cup} und \textsc{Antlr} besteht darin,
            dass Nicht-Terminale nicht mehr durch den ihnen zugeordneten String repr\"asentiert werden
            k\"onnen.  Daher k\"onnen wir den String ``\texttt{PLUS}'' nicht durch den String
            ``\texttt{'+'}'' ersetzen.  
            An dieser Stelle sind \textsc{Cup}-Grammatiken leider nicht so gut lesbar wie die
            entsprechenden \textsc{Antlr}-Grammatiken.
            Der Grund daf\"ur ist, dass bei  \textsc{Cup} zum Scannen ein separates
            Werkzeug, n\"amlich \textsl{JFlex}, zum Scannen verwendet wird.  Demgegen\"uber
            wird bei \textsc{Antlr} der Scanner zusammen mit dem Parser in derselben
            Datei spezifiziert und das Werkzeug \textsc{Antlr} erzeugt aus dieser Datei
            sowohl einen Parser als auch einen Scanner.
      \item Ein weiterer wichtiger Unterschied zwischen \textsc{Cup} und \textsc{Antlr} besteht
            darin, dass \textsc{Cup} im Gegensatz zu \textsc{Antlr} keine \textsc{Ebnf}-Grammatiken
            akzeptiert sondern nur gew\"ohnliche kontextfreie Grammatiken verarbeiten kann.  Damit stehen
            uns die Operatoren ``\texttt{*}'', ``\texttt{+}'' und ``\texttt{?}'' bei der
            Spezifikation der Grammatik nicht zur Verf\"ugung.
      \end{enumerate}
\end{enumerate}
Um aus der in Abbildung \ref{fig:calc.cup} gezeigten \textsc{Cup}-Spezifikation einen Parser zu
erzeugen, m\"ussen wir diese zun\"achst mit dem Befehl
\\[0.2cm]
\hspace*{1.3cm}
\texttt{java -jar /usr/local/lib/java-cup-11b.jar calc.cup}
\\[0.2cm]
\"ubersetzen.  Damit dies funktioniert m\"ussen Sie die Datei
\\[0.2cm]
\hspace*{1.3cm}
 \texttt{java-cup-11b.jar} 
\\[0.2cm]
in dem Verzeichnis 
\\[0.2cm]
\hspace*{1.3cm}
\texttt{/usr/local/lib}
\\[0.2cm]
ablegen.  Sollten Sie unter \textsl{Windows} arbeiten, m\"ussen Sie stattdessen ein geeignetes anderes
Verzeichnis w\"ahlen.  Eine M\"oglichkeit, den Aufruf zu vereinfachen, besteht unter Unix darin, dass Sie sich
eine Datei \texttt{cup} mit folgendem Inhalt irgendwo in Ihrem Pfad ablegen:
\begin{verbatim}
    #!/bin/bash 
    java -jar /usr/local/lib/java-cup-11b.jar  $@
\end{verbatim} %$
Unter \textsl{Windows} k\"onnen Sie sich stattdessen eine entsprechende \texttt{.bat}-Datei anlegen.
Danach k\"onnen Sie \textsc{Cup} einfacher mit dem Befehl
\\[0.2cm]
\hspace*{1.3cm}
\texttt{cup} \textsl{calc.cup}
\\[0.2cm]
aufrufen.  Dieser Befehl erzeugt verschiedene \textsl{Java}-Dateien.
\begin{enumerate}
\item Die Datei \texttt{ExprParser.java} enth\"alt die Klasse \texttt{ExprParser}, die den eigentlichen
      Parser enth\"alt.  Wenn Sie diese Klassse sp\"ater \"ubersetzen wollen, m\"ussen Sie daf\"ur
      sorgen, dass die Datei \texttt{java-cup-11b-runtime.jar} im \texttt{CLASSPATH} liegt.
\item Die Datei \texttt{ExprParserSym.java} enth\"alt die Klasse \texttt{ExprParserSym}, welche die verschiedenen
      Symbole als statische Konstanten  der  Klasse \texttt{ExprParserSym} definiert.  
      Diese Konstanten werden sp\"ater im von \textsl{JFlex} erzeugten Scanner verwendet. Abbildung
      \ref{fig:sym.java} auf Seite \pageref{fig:sym.java} zeigt diese Klasse.
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class ExprParserSym {
      /* terminals */
      public static final int MINUS   = 4;
      public static final int DIVIDE  = 6;
      public static final int NUMBER  = 10;
      public static final int MOD     = 7;
      public static final int SEMI    = 2;
      public static final int EOF     = 0;
      public static final int PLUS    = 3;
      public static final int error   = 1;
      public static final int RPAREN  = 9;
      public static final int TIMES   = 5;
      public static final int LPAREN  = 8;
      public static final String[] terminalNames = new String[] {
          "EOF",
          "error",
          "SEMI",
          "PLUS",
          "MINUS",
          "TIMES",
          "DIVIDE",
          "MOD",
          "LPAREN",
          "RPAREN",
          "NUMBER"
      };
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{ExprParserSym}.}
\label{fig:sym.java}
\end{figure}

\noindent
Neben dem Parser wird noch ein Scanner ben\"otigt.  Diesen werden wir im n\"achsten Abschnitt pr\"asentieren.
Um mit dem Parser arbeiten zu k\"onnen, brauchen wir eine Klasse, welche die Methode
$\texttt{main}()$ enth\"alt.  Abbildung \ref{fig:Calculator.java} auf Seite
\pageref{fig:Calculator.java} zeigt eine solche Klasse.  Wir
erzeugen dort in Zeile 7 einen \texttt{InputStream}, der aus der Datei liest, deren Name wir als
erstes Argument \"ubergeben.   In der darauf folgenden Zeile wird der \texttt{InputStream} in einen
\texttt{Reader} verwandelt.  Aus dem \texttt{Reader} erzeugen wir einen \texttt{Scanner}.  Mit
diesem \texttt{Scanner} k\"onnen wir schlie{\ss}lich den Parser erzeugen, den wir dann in Zeile 11 mit
Hilfe der Methode \texttt{parse()} starten, wobei eventuelle Ausnahmen noch abgefangen werden m\"ussen.
Falls mit dem Start-Symbol der Grammatik ein Wert assoziert ist, so wird dieser Wert von
der Methode $\texttt{parse}()$ als Ergebnis zur\"uck gegeben, andernfalls gibt die Methode den Wert
\texttt{null} zur\"uck.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    import java_cup.runtime.*;
    import java.io.*;
    
    public class Calculator {
        public static void main(String[] args) {
            try {
                InputStream fileStream = new FileInputStream(args[0]);
                Reader      reader     = new InputStreamReader(fileStream);
                Scanner     scanner    = new Yylex(reader);
                ExprParser  parser     = new ExprParser(scanner); 
                parser.parse(); 
            } catch (Exception e) {}
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die Klasse \texttt{Calculator}.}
\label{fig:Calculator.java}
\end{figure}
\vspace*{\fill}
\pagebreak

\vspace*{\fill}
\pagebreak


\section{Generierung eines \textsc{Cup}-Scanner mit Hilfe von \textsl{Flex}}
Wir zeigen in diesem Abschnitt, wie wir mit Hilfe von \textsl{JFlex} einen Scanner
f\"ur den im letzten Abschnitt erzeugten Parser erstellen k\"onnen.
Der Scanner, den wir ben\"otigen, muss in der Lage sein, Zahlen und arithmetische
Operatoren zu erkennen.  Abbildung \ref{fig:calc.jflex} auf Seite 
\pageref{fig:calc.jflex} zeigt einen solchen Scanner, den wir jetzt im Detail diskutieren.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    import java_cup.runtime.*;
          
    %%
       
    %char
    %line
    %column
    %cupsym ExprParserSym
    %cup
    %unicode
       
    %{   
        private Symbol symbol(int type) {
            return new Symbol(type, yychar, yychar + yylength());
        }
        
        private Symbol symbol(int type, Object value) {
            return new Symbol(type, yychar, yychar + yylength(), value);
        }
    %}
    
    %eofval{
        return new Symbol(ExprParserSym.EOF);
    %eofval}
       
    %%
       
    ";"           { return symbol( ExprParserSym.SEMI   ); } 
    "+"           { return symbol( ExprParserSym.PLUS   ); }
    "-"           { return symbol( ExprParserSym.MINUS  ); }
    "*"           { return symbol( ExprParserSym.TIMES  ); }
    "/"           { return symbol( ExprParserSym.DIVIDE ); }
    "%"           { return symbol( ExprParserSym.MOD    ); }
    "("           { return symbol( ExprParserSym.LPAREN ); }
    ")"           { return symbol( ExprParserSym.RPAREN ); }
    
    0|[1-9][0-9]* { return symbol(ExprParserSym.NUMBER, new Integer(yytext())); }
    
    [ \t\v\n\r]   { /* skip white space */ }   
    
    [^]           { throw new Error("Illegal character '" + yytext() + 
                                    "' at line " + yyline + 
                                    ", column "  + yycolumn); }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Ein Scanner f\"ur arithmetische Ausdr\"ucke}
\label{fig:calc.jflex}
\end{figure}

\begin{enumerate}
\item In Zeile 1 importieren wir alle Klassen des Paketes \texttt{java\_cup.runtime}.
      Dieses Paket enth\"alt insbesondere die Definition der Klasse \texttt{Symbol}, mit der 
      in einem \textsc{Cup}-Parser Terminale und Nicht-Terminale beschrieben werden.
      Daher muss dieses Paket bei jedem Scanner importiert werden, der an einen von
      \textsc{Cup} erzeugten Parser angeschlossen werden soll.
\item In den Zeilen 5 bis 7 spezifizieren wir, dass der Scanner die Anzahl der insgesamt
      gelesenen Zeichen, die Anzahl der gelesenen Zeilen und die Anzahl der in der aktuellen Zeile
      gelesenen Zeichen automatisch berechnen soll.  Dadurch k\"onnen wir sp\"ater im Parser
      Syntax-Fehler pr\"azise lokalisieren.
\item Zeile 8 spezifiziert mit dem Schl\"usselwort ``\texttt{\%cupsym}'', 
      dass die vom Scanner zur\"uckzugebenden Symbole in der Klasse \texttt{ExprParserSym} definiert
      werden.  Diese Klasse wurde von \textsc{Cup} erzeugt.  Der Name dieser Klasse ergibt sich aus
      dem Namen der Klasse des Parsers durch Anh\"angen von ``\texttt{Sym}'', das f\"ur \emph{Symbol} steht.
      Die Klasse des Parsers hatten wir seinerzeit in der Datei ``\texttt{calc.cup}''  mit Hilfe 
      des Schl\"usselworts ``\texttt{class}'' spezifiziert.
\item Zeile 9 spezifiziert mit dem Schl\"usselwort ``\texttt{\%cup}'', 
      dass der Scanner an einen \textsc{Cup}-Parser angeschlossen  werden soll.
\item In den Zeilen 12 bis 20 definieren wir zwei Hilfs-Methoden, die Objekte vom Typ 
      \texttt{Symbol} erzeugen.  Der Scanner muss Objekte von diesem Typ an den Parser zur\"uck
      liefern.  Die in dem Paket \texttt{java\_cup.runtime} definierte Klasse \texttt{Symbol} stellt
      verschiedene Konstruktoren f\"ur diese Klasse zur Verf\"ugung.  Wir stellen die wichtigsten 
      Konstruktoren vor.
      \begin{enumerate}
      \item \texttt{public Symbol(int \textsl{symbolID});}

            Dieser Konstruktor bekommt als Argument eine nat\"urliche Zahl, die festlegt,
            welche Art von Symbol 
            definiert werden soll.  Diese Zahl bezeichnen wir als \emph{Symbol-Nummer}.
            Jedem Terminal und jeder syntaktische Variablen entspricht genau Symbol-Nummer. 
            Die Kodierung der Symbol-Nummern wird von dem Parser-Generator \textsc{Cup} 
            in der Klasse \texttt{ExprParserSym} festgelegt.  Abbildung \ref{fig:sym.java}
            auf Seite \pageref{fig:sym.java} zeigt diese von \textsc{Cup} erzeugte Klasse.
      \item \texttt{public Symbol(int \textsl{symbolID}, Object \textsl{value});}

            Dieser Konstruktor bekommt zus\"atzlich zur Symbol-Nummer einen \emph{Wert}, der im Symbol
            abgespeichert wird. Dieser Wert hat den Typ \texttt{Object}, wodurch der Typ so
            allgemein wie m\"oglich ist.  Dieser
            Konstruktor wird benutzt, wenn Terminale, die einen Wert haben, wie beispielsweise
            Zahlen, vom Scanner an den Parser zur\"uck gegeben werden sollen.
      \item \texttt{public Symbol(int \textsl{symbolID}, int \textsl{start}, int \textsl{end})}

            Dieser Konstruktor hat zus\"atzlich zur Symbol-Nummer die Argumente \texttt{start}  und
            \texttt{stop}, die den Anfang und das Ende des erkannten Terminals festlegen.  Die Variable
            \texttt{start} gibt die Position des ersten Zeichens im Text an, w\"ahrend \texttt{end}
            die Position des letzten Zeichens des Tokens angibt.  Diese Information ist n\"utzlich,
            um sp\"ater im Parser Syntax-Fehler besser lokalisieren zu k\"onnen.
      \item \texttt{public Symbol(int \textsl{symbolID}, int  \textsl{start}, int \textsl{end},
                    Objekt \textsl{value})}

            Dieser Konstruktor erh\"alt zus\"atzlich zur Symbol-Nummer und Position des gelesenen Tokens noch
            den Wert, der diesem Token zugeordnet ist.
      \end{enumerate}
      Bei der Implementierung der beiden Hilfs-Methoden mit dem Namen $\texttt{symbol}()$ verwenden
      wir die Funktion $\texttt{yylength}()$.  Diese Funktion wird von \textsl{jflex} zur Verf\"ugung
      gestellt und gibt die L\"ange des Strings zur\"uck, der dem zuletzt erkannten Tokens entspricht.
\item In den Zeilen 28 bis 35 erkennen wir die arithmetischen Operatoren und die Klammer-Symbole.
      Zur Spezifikation des zur\"uckgegebenen Token verwenden wir dabei die in der Klasse \texttt{ExprParserSym}
      definierten Konstanten \texttt{SEMI}, \texttt{PLUS}, etc. 
\item In Zeile 37 erkennen wir mit dem regul\"aren Ausdruck ``\texttt{0|[1-9][0-9]*}'' eine nat\"urliche
      Zahl.  Diese wandeln wir durch den Konstruktor-Aufruf 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{new Integer(yytext())}
      \\[0.2cm]
      in ein Objekt vom Typ \texttt{Integer} um, wobei der String, der in eine Zahl umgewandelt wird, von der
      Funktion $\texttt{yytext}()$ geliefert wird.  Anschlie{\ss}end geben wir ein Objekt der Klasse \texttt{Symbol} zur\"uck,
      in dem diese Zahl als mit dem Symbol assoziierter Wert abgespeichert wird.
\item In Zeile 39 \"uberlesen wir Leerzeichen, Tabulatoren und Zeilen-Umbr\"uche.
      Das \"Uberlesen geschieht dadurch, dass wir in diesem Fall kein Symbol an den Parser zur\"uck
      geben, denn die semantische Aktion enth\"alt keinen \texttt{return}-Befehl.
\item Falls ein beliebiges anderes Zeichen gelesen wird, geben wir mit der Regel, die in Zeile 41 
      beginnt, eine Fehlermeldung aus.  Dabei greifen wir auf die Variablen 
      \texttt{yyline} und \texttt{yycolumn} zur\"uck, damit der Fehler lokalisiert werden kann.
\end{enumerate}
Durch den Aufruf
\\[0.2cm]
\hspace*{1.3cm}
\texttt{jflex calc.jflex}
\\[0.2cm]
erzeugt \textsl{JFlex} aus der Datei \texttt{clac.jflex} den Scanner in der Klasse \texttt{Yylex}.
Wir hatten in Abbildung 
\ref{fig:Calculator.java} gesehen, wie diese Klasse an den Parser angebunden wird.



\section{Shift/Reduce und Reduce/Reduce-Konflikte}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                  commandchars  = \\\{\}
                ]
    import java_cup.runtime.*;
    
    terminal           PLUS, MINUS, TIMES, DIVIDE, MOD;
    terminal           UMINUS, LPAREN, RPAREN;
    terminal Integer   NUMBER;
    
    nonterminal Integer expr;
    
    expr ::= expr PLUS   expr
          |  expr MINUS  expr
          |  expr TIMES  expr
          |  expr DIVIDE expr
          |  expr MOD    expr
          |  NUMBER               
          |  MINUS expr
          |  LPAREN expr RPAREN   
          ;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{\textsc{Cup}-Spezifikation eines Parsers f\"ur arithmetische Ausdr\"ucke}
\label{fig:calc-ambiguous.cup}
\end{figure}

Wir betrachten nun ein weiteres Beispiel.  Abbildung \ref{fig:calc-ambiguous.cup} zeigt eine 
\textsc{Cup}-Spezifikation einer Grammatik, die offenbar mehrdeutig ist, da die Pr\"azedenzen der
arithmetischen Operatoren durch diese Grammatik nicht festgelegt werden.
  Mit dieser Grammatik ist beispielsweise nicht klar, ob der String
\\[0.2cm]
\hspace*{1.3cm} 
``\texttt{1 + 2 * 3}'' \quad als \quad  ``\texttt{(1 + 2) * 3}'' \quad oder als \quad ``\texttt{1 + (2 * 3)}''
\\[0.2cm]
interpretiert werden soll.   Wir hatten im letzten Kapitel schon gesehen, dass es in einer
mehrdeutigen Grammatik immer Shift/Reduce- oder Reduce/Reduce-Konflikte geben muss, denn jede
LALR-Grammatik ist eindeutig.  Wenn wir versuchen, die Grammatik aus Abbildung
\ref{fig:calc-ambiguous.cup} mit \textsc{Cup} zu \"ubersetzen und wenn wir dabei zus\"atzlich die Option 
``\texttt{-dump}'' angeben, der Aufruf von \textsc{Cup} hat dann die Form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{cup -dump calc.cup}
\\[0.2cm]
so erhalten wir eine gro{\ss}e Zahl von Shift/Reduce-Konflikten angezeigt.
Beispielsweise erhalten wir die folgende Fehlermeldung:
\begin{verbatim}
    Warning : *** Shift/Reduce conflict found in state #12
      between expr ::= expr MINUS expr (*) 
      and     expr ::= expr (*) PLUS expr 
      under symbol PLUS
      Resolved in favor of shifting.
\end{verbatim}
Statt des Zeichens ``$\bullet$'' benutzt \textsc{Cup} den String
``\texttt{(*)}'' zur Darstellung der Position in einer markierten Regel.
Die obige Fehlermeldung zeigt uns an, dass es zwischen der markierten Regel
\\[0.2cm]
\hspace*{1.3cm}
$R_1 \;:=\; 
\Bigl(\textsl{expr} \rightarrow \textsl{expr} \quoted{-} \textsl{expr}\;\bullet\Bigr)$
\\[0.2cm]
und der markierten Regel
\\[0.2cm]
\hspace*{1.3cm}
$R_2 \; := \; 
\Bigl(\textsl{expr} \rightarrow \textsl{expr} \bullet \quoted{+} \textsl{expr}\Bigr)$
\\[0.2cm]
einen Shift/Reduce-Konflikt gibt:  Die beiden markierten  Regeln $R_1$ und $R_2$
sind Elemente eines Zustands, der von \textsc{Cup} intern mit der Nummer 12 versehen
worden ist.  Der Zustand mit der Nummer 12 hat folgende Form:
\begin{verbatim}
    lalr_state [12]: {
      [expr ::= expr (*) MOD expr ,    {EOF PLUS MINUS TIMES DIVIDE MOD RPAREN }]
      [expr ::= expr (*) MINUS expr ,  {EOF PLUS MINUS TIMES DIVIDE MOD RPAREN }]
      [expr ::= expr (*) DIVIDE expr , {EOF PLUS MINUS TIMES DIVIDE MOD RPAREN }]
      [expr ::= expr (*) TIMES expr ,  {EOF PLUS MINUS TIMES DIVIDE MOD RPAREN }]
      [expr ::= expr (*) PLUS expr ,   {EOF PLUS MINUS TIMES DIVIDE MOD RPAREN }]
      [expr ::= expr MINUS expr (*) ,  {EOF PLUS MINUS TIMES DIVIDE MOD RPAREN }]
    }
\end{verbatim}
Damit k\"onnen wir jetzt den
Shift/Reduce-Konflikt interpretieren: Im Zustand 12 ist der Parser entweder dabei, die
Eingabe mit der Regel 
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{expr} \rightarrow \textsl{expr} \quoted{-} \textsl{expr}$
\\[0.2cm]
zu reduzieren, oder der Parser ist gerade dabei, die rechte Seite der Regel 
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{expr} \rightarrow \textsl{expr} \quoted{+} \textsl{expr}$
\\[0.2cm]
zu erkennen, wobei er bereits eine \textsl{expr} erkannt hat und nun als n\"achstes das
Token ``\texttt{+}'' erwartet wird.  Da das Token ``\texttt{+}'' auch in der Follow-Menge der
erweiterten markierten Regel $R_1$ liegen kann, ist an dieser Stelle unklar, ob das Token
``\texttt{+}'' auf den 
Stack geschoben werden soll, oder ob stattdessen mit der Regel $R_1$ reduziert werden
muss.  Bei einem Shift/Reduce-Konflikt entscheidet sich der von \textsc{Cup} erzeugte
Parser immer daf\"ur, das Token auf den Stack zu schieben.


\section{Operator-Pr\"azendenzen \label{section:operator-precedence}}
Es ist mit   \textsc{Cup} m\"oglich, Shift/Reduce-Konflikte durch die Angabe von
\emph{Operator-Pr\"azedenzen} 
aufzul\"osen.  Abbildung \ref{fig:calc-precedence.cup} zeigt die Spezifikation einer Grammatik zur
Erkennung arithmetischer Ausdr\"ucke, die aus Zahlen und den bin\"aren Operatoren ``\texttt{+}'',
``\texttt{-}'', ``\texttt{*}'', ``\texttt{/}'' und ``\texttt{\symbol{94}}'' aufgebaut sind.   Mit
Hilfe der Schl\"usselw\"orter 
\\[0.2cm]
\hspace*{1.3cm}
``\texttt{precedence left}'' \quad und \quad ``\texttt{precedence right}'' 
\\[0.2cm]
haben wir festgelegt, dass die Operatoren ``\texttt{+}'', ``\texttt{-}'', ``\texttt{*}'' und
``\texttt{/}'' \emph{links-assoziativ} sind, ein Ausdruck der Form 
\\[0.2cm]
\hspace*{1.3cm}
$3 - 2 - 1$ \quad wird also als \quad $(3 - 2) - 1$ \quad und nicht als \quad $3 - (2-1)$
\\[0.2cm]
gelesen.  Demgegen\"uber ist der Operator ``\texttt{\symbol{94}}'', der in der \textsc{Cup}-Grammatik
mit ``\texttt{POW}'' bezeichnet wird und die Potenzbildung bezeichnet,
\emph{rechts-assoziativ}, der Ausdruck 
\\[0.2cm]
\hspace*{1.3cm}
$4 \texttt{\symbol{94}} 3 \texttt{\symbol{94}} 2$ \quad wird daher als \quad
$4^{\mbox{(}3^2\mbox{)}}$ \quad  und nicht als \quad $\bigl(4^3\bigr)^2$
\\[0.2cm]
interpretiert.   Die Reihenfolge, in der die Assoziativit\"at der Operatoren spezifiziert werden, legt die
\emph{Pr\"azedenzen}, die auch als \emph{Bindungsst\"arken} bezeichnet werden, fest.  Dabei ist die
Bindungsst\"arke umso gr\"o{\ss}er, je sp\"ater der Operator spezifiziert wird.  In unserem konkreten Beispiel bindet
der Exponentiations-Operator ``\texttt{\symbol{94}}'' also am st\"arksten, w\"ahrend die Operatoren ``\texttt{+}'' und
``\texttt{-}'' am schw\"achsten binden.  Bei der in Abbildung \ref{fig:calc-precedence.cup} gezeigten Grammatik
ordnet \textsc{Cup} den Operatoren die Bindungsst\"arke nach der folgenden Tabelle zu:

\begin{center}
\begin{tabular}[t]{|c|c|c|}
\hline
Operator       & Bindungsst\"arke & Assoziativit\"at \\
\hline
\hline
``\texttt{+}''  & 1             &  links         \\
\hline
``\texttt{-}''  & 1             &  links         \\
\hline
``\texttt{*}''  & 2             &  links         \\
\hline
``\texttt{/}''  & 2             &  links         \\
\hline
``\texttt{\symbol{94}}'' & 3             &  rechts        \\
\hline
\end{tabular}
\end{center}


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    import java_cup.runtime.*;
    class  ExprParser;
    
    terminal         SEMI, PLUS, MINUS, TIMES, DIVIDE, MOD, POW;
    terminal         UMINUS, LPAREN, RPAREN;
    
    terminal Double  NUMBER;
    
    nonterminal        expr_list, expr_part;
    nonterminal Double expr;
    
    precedence left   PLUS, MINUS;
    precedence left   TIMES, DIVIDE, MOD;
    precedence right  UMINUS, POW;
    
    start with expr_list;
    
    expr_list ::= expr_list expr_part 
               |  expr_part
               ;
    
    expr_part ::= expr:e {: System.out.println("result = " + e); :} SEMI 
               ;
    
    expr ::= expr:e1 PLUS   expr:e2 {: RESULT = e1 + e2; :} 
          |  expr:e1 MINUS  expr:e2 {: RESULT = e1 - e2; :} 
          |  expr:e1 TIMES  expr:e2 {: RESULT = e1 * e2; :}
          |  expr:e1 DIVIDE expr:e2 {: RESULT = e1 / e2; :} 
          |  expr:e1 MOD    expr:e2 {: RESULT = e1 % e2; :} 
          |  expr:e1 POW    expr:e2 {: RESULT = Math.pow(e1, e2); :} 
          |  NUMBER:n               {: RESULT = n;       :} 
          |  MINUS expr:e           {: RESULT = - e;     :} %prec UMINUS
          |  LPAREN expr:e RPAREN   {: RESULT = e;       :} 
          ;
\end{Verbatim}
%$
\vspace*{-0.3cm}
\caption{Aufl\"osung der Shift/Reduce-Konflikte durch Operator-Pr\"azedenzen.}
\label{fig:calc-precedence.cup}
\end{figure}

Wie erl\"autern nun, wie diese Bindungsst\"arken benutzt werden, um Shift/Reduce-Konflikte aufzul\"osen.
\textsc{Cup} geht folgenderma{\ss}en vor:
\begin{enumerate}
\item Zun\"achst wird jeder Grammatik-Regel eine \emph{Pr\"azedenz} zugeordnet.
      Die Pr\"azedenz ist dabei die Bindungsst\"arke des letzten in der Regel auftretenden Operators.
      F\"ur den Fall, dass eine Regel mehrere Operatoren enth\"alt, f\"ur die eine Bindungsst\"arke spezifiziert
      wurde, wird zur Festlegung der Bindungsst\"arke also der Operator herangezogen, der in
      der Regel am weitesten 
      rechts steht.  In unserem Beispiel haben die einzelnen Regeln damit die folgenden Pr\"azedenzen:
      \begin{center}
        \begin{tabular}[t]{|l|c|}
          \hline
          Regel                          & Pr\"azedenz  \\
          \hline
          \hline
          $E \rightarrow E \quoted{+} E$ & 1          \\
          \hline
          $E \rightarrow E \quoted{-} E$ & 1          \\
          \hline
          $E \rightarrow E \quoted{*} E$ & 2          \\
          \hline
          $E \rightarrow E \quoted{/} E$ & 2          \\
          \hline
          $E \rightarrow E \quoted{\symbol{94}} E$ & 3 \\
          \hline
          $E \rightarrow \quoted{(} E \quoted{)}$ & --- \\
          \hline
          $E \rightarrow N$ & --- \\
          \hline
        \end{tabular}
      \end{center}
      F\"ur die Regeln, die keinen Operator enthalten, f\"ur den eine Bindungsst\"arke spezifiziert ist,
      bleibt die Pr\"azedenz unspezifiziert.
\item Ist $s$ ein Zustand, in dem zwei Regeln $r_1$ und $r_2$ der Form
      \\[0.2cm]
      \hspace*{1.3cm}
      $r_1 = (a \rightarrow \beta \bullet o \;\delta:L_1)$ \quad und \quad
      $r_2 = (c \rightarrow \gamma \bullet : L_2)$ \quad mit \quad $o \in L_2$
      \\[0.2cm]
      vorkommen, so gibt es bei der Berechnung von 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{action}(s, o)$
      \\[0.2cm]
      zun\"achst einen Shift/Reduce-Konflikt.  Falls dem Operator $o$ die Pr\"azedenz $p(o)$
      zugeordnet worden ist und wenn au{\ss}erdem die Regel $r_2$, mit der reduziert werden w\"urde, die
      Pr\"azedenz  $p(r_2)$ hat, so wird der Shift/Reduce-Konflikt in Abh\"angigkeit von der relativen
      Gr\"o{\ss}e   der beiden Zahlen $p(o)$ und $p(r_2)$ aufgel\"ost.  Hier werden f\"unf F\"alle unterschieden:
      \begin{enumerate}
      \item $p(o) > p(c \rightarrow \gamma)$: 
            In diesem Fall bindet der Operator $o$ st\"arker.  Daher wird das Token $o$  
            in diesem Fall auf den Stack geschoben:
            \hspace*{1.3cm}
            \\[0.2cm]
            $\textsl{action}(s,o) = \langle \texttt{shift}, \textsl{goto}(s,o) \rangle$.
            \\[0.2cm]
            Dass diese Regel sinnvoll ist, sehen wir, wenn wir beispielsweise den Eingabe-String
            \\[0.2cm]
            \hspace*{1.3cm}
            $\texttt{1+2*3}$
            \\[0.2cm]
            mit den Grammatik-Regeln 
            \\[0.2cm]
            \hspace*{1.3cm}
            $E \rightarrow E \quoted{+} E \mid E \quoted{*} E \mid \textsc{Number}$
            \\[0.2cm]
            parsen.  Betrachten wir die Situation, bei der der Teilstring ``\texttt{1+2}''
            bereits gelesen wurde und nun als n\"achstes das Token ``\texttt{*}''
            verarbeitet werden soll.  Der LALR-Parser ist dann in dem folgenden Zustand:
            \\[0.2cm]
            \hspace*{1.3cm}
            $ 
            \begin{array}[t]{llcll}
            \bigl\{ 
            & E & \rightarrow & E \bullet \squoted{*} E: \{\symbol{36}, \squoted{*}, \squoted{+} \}, 
            & \\
            & E & \rightarrow & E \bullet \squoted{+} E: \{\symbol{36}, \squoted{*}, \squoted{+} \}, 
            & \\
            & E & \rightarrow & E \squoted{+} E \;\bullet: \{\symbol{36}, \squoted{*}, \squoted{+} \}
            & \bigr\}.
            \end{array}
            $
            \\[0.2cm]
            Wenn in diesem Zustand als n\"achstes Zeichen ein ``\texttt{*}'' gelesen wird, so darf der
            bisher gelesene String ``\texttt{1+2}'' nicht mit der Regel 
            $E \rightarrow E \squoted{+} E$ reduziert werden, denn wir wollen die 2 ja zun\"achst mit 3 
            multiplizieren.  Stattdessen muss also das Zeichen 
            ``\texttt{*}'' auf den Stack geschoben werden.
      \item $p(o) < p(c \rightarrow \gamma)$: 
            Jetzt bindet der Operator, der in der Regel $r_2$ auftritt, st\"arker als der
            Operator $o$.  Daher wird in diesem Fall zun\"achst mit der Regel $r_2$ reduziert, wir haben 
            also 
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{action}(s,o) = \langle \texttt{reduce}, r_2 \rangle$.
            \\[0.2cm]
            Dass diese Regel sinnvoll ist, sehen wir, wenn wir beispielsweise den Eingabe-String
            \\[0.2cm]
            \hspace*{1.3cm}
            $\texttt{1*2+3}$
            \\[0.2cm]
            mit den Grammatik-Regeln 
            \\[0.2cm]
            \hspace*{1.3cm}
            $E \rightarrow E \quoted{+} E \mid E \quoted{*} E \mid \textsc{Number}$
            \\[0.2cm]
            parsen.  Betrachten wir die Situation, bei der der Teilstring ``\texttt{1*2}''
            bereits gelesen wurde und nun als n\"achstes das Token ``\texttt{+}''
            verarbeitet werden soll.  Der LALR-Parser ist dann in dem folgenden Zustand:
            \\[0.2cm]
            \hspace*{1.3cm}
            $ 
            \begin{array}[t]{llcll}
         \bigl\{ 
            & E & \rightarrow & E \bullet \squoted{*} E: \{\symbol{36}, \squoted{*}, \squoted{+} \}, 
            & \\
            & E & \rightarrow & E \bullet \squoted{+} E: \{\symbol{36}, \squoted{*}, \squoted{+} \}, 
            & \\
            & E & \rightarrow & E \squoted{*} E \;\bullet: \{\symbol{36}, \squoted{*}, \squoted{+} \}
            & \bigr\}.
            \end{array}
            $
            \\[0.2cm]
            Wenn in diesem Zustand als n\"achstes Zeichen ein ``\texttt{+}'' gelesen wird, so soll
            der bisher gelesene String ``\texttt{1*2}''  mit der Regel 
            $E \rightarrow E \squoted{*} E$ reduziert werden, denn wir wollen die 1 ja zun\"achst mit 2 
            multiplizieren.  
      \item $p(o) = p(c \rightarrow \gamma)$ und der Operator $o$ ist links-assoziativ:
            Dann wird zun\"achst mit der Regel $r_2$ reduziert, wir haben
            also 
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{action}(s,o) = \langle \texttt{reduce}, r_2 \rangle$.
            \\[0.2cm]
            Dass diese Regel sinnvoll ist, sehen wir, wenn wir beispielsweise den Eingabe-String
            \\[0.2cm]
            \hspace*{1.3cm}
            $\texttt{1-2-3}$
            \\[0.2cm]
            mit den Grammatik-Regeln 
            \\[0.2cm]
            \hspace*{1.3cm}
            $E \rightarrow E \quoted{+} E \mid E \quoted{-} E \mid \textsc{Number}$
            \\[0.2cm]
            parsen.  Betrachten wir die Situation, bei der der Teilstring ``\texttt{1-2}''
            bereits gelesen wurde und nun als n\"achstes das Token ``\texttt{-}''
            verarbeitet werden soll.  Der LALR-Parser ist dann in dem folgenden Zustand:
            \\[0.2cm]
            \hspace*{1.3cm}
            $ 
            \begin{array}[t]{llcll}
         \bigl\{ 
            & E & \rightarrow & E \bullet \squoted{-} E: \{\symbol{36}, \squoted{-}, \squoted{+} \}, 
            & \\
            & E & \rightarrow & E \bullet \squoted{+} E: \{\symbol{36}, \squoted{-}, \squoted{+} \}, 
            & \\
            & E & \rightarrow & E \squoted{-} E \;\bullet: \{\symbol{36}, \squoted{-}, \squoted{+} \}
            & \bigr\}.
            \end{array}
            $
            \\[0.2cm]
            Wenn in diesem Zustand als n\"achstes Zeichen ein ``\texttt{-}'' gelesen wird, so soll
            der bisher gelesene String ``\texttt{1-2}'' mit der Regel 
            $E \rightarrow E \squoted{-} E$ reduziert werden, denn wir wollen von der Zahl 1 ja
            zun\"achst die Zahl 2 subtrahieren.  
      \item $p(o) = p(c \rightarrow \gamma)$ und der Operator $o$ ist rechts--assoziativ:
            In diesem Fall wird $o$ auf den
            Stack geschoben:
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{action}(s,o) = \langle \texttt{shift}, \textsl{goto}(s,o) \rangle$.
            \\[0.2cm]
            Wenn wir diesen Fall verstehen wollen, reicht es aus, den String
            \\[0.2cm]
            \hspace*{1.3cm}
            $\texttt{2\symbol{94}3\symbol{94}4}$
            \\[0.2cm]
            mit den Grammatik-Regeln
            \\[0.2cm]
            \hspace*{1.3cm}
            $E \rightarrow E \,\texttt{\symbol{94}}\, E \mid \textsc{Number}$
            \\[0.2cm]
            zu parsen und die Situation zu betrachten, bei der der Teilstring
            ``\texttt{1\symbol{94}2}'' bereits verarbeitet wurde und als n\"achstes Zeichen nun
            der Operator ``\texttt{\symbol{94}}'' gelesen wird.
            Der LALR-Parser ist dann in dem folgenden Zustand:
            \\[0.2cm]
            \hspace*{1.3cm}
            $\bigl\{ 
             E  \rightarrow E \bullet \quoted{\texttt{\symbol{94}}} E:
             \{\symbol{36},\quoted{\texttt{\symbol{94}}} \},\;  E \rightarrow  E
             \squoted{\texttt{\symbol{94}}} E \;\bullet: \{\symbol{36},\quoted{\texttt{\symbol{94}}}\}
            \bigr\}.
            $
            \\[0.2cm]
            Hier muss als n\"achstes das Token \quoted{\texttt{\symbol{94}}} auf den Stack geschoben
            werden, denn wir wollen ja zun\"achst den Ausdruck ``$3 \texttt{\symbol{94}} 4$'' berechnen.
      \item $p(o) = p(c \rightarrow \gamma)$ und der Operator $o$ hat keine Assoziativit\"at:
            In diesem Fall liegt ein Syntax-Fehler vor:
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{action}(s,o) = \textsl{error}$.
            \\[0.2cm]
            Diesen Fall verstehen Sie, wenn Sie versuchen, einen String der Form
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{1 < 1 < 1}
            \\[0.2cm]
            mit den Grammatik-Regeln
            \\[0.2cm]
            \hspace*{1.3cm}
            $E \rightarrow E \quoted{<} E \mid E \quoted{+} E \mid \textsc{Number}$
            \\[0.2cm]
            %$
            zu parsen.  In dem Moment, in dem Sie den Teilstring ``\texttt{1 < 1}'' gelesen haben
            und nun das n\"achste Token das Zeichen ``\texttt{<}'' ist, erkennen Sie, 
            dass es ein Problem gibt.  

            \remark
            Beachten Sie, dass auch in diesem Fall der Shift/Reduce-Konflikt aufgel\"ost
            wird, denn den Syntax-Fehler erhalten Sie erst beim Parsen,  w\"ahrend die
            Erstellung des Parsers selber fehlerfrei (sprich: ohne verbleibende Konflikte)
            verl\"auft.

            Um in \textsc{Cup} einen Operator $o$ als nicht-assoziativ zu deklarieren, 
            schreiben Sie:
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{precedence nonassoc $o$}
      \item $p(o)$ ist undefiniert oder $p(c \rightarrow \gamma)$ ist undefiniert.

            In diesem Fall erzeugt \textsc{Cup} einen Shift/Reduce-Konflikt und gibt bei der
            Erzeugung des Parsers eine entsprechende Warnung aus.  Diese Warnung wird als Fehler
            gewertet,  wenn sie nicht durch Angabe der Option 
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{-expect} $n$
            \\[0.2cm]
            beim Aufruf von \textsc{Cup} unterdr\"uckt wird.  Bei dieser Option ist $n$ die Anzahl der
            vom Benutzer erwarteten Konflikte. In diesem Fall wird der Konflikt dann per Default
            dadurch aufgel\"ost,  dass das betreffende Token auf den Stack geschoben wird. 
            Wir werden dieses Verhalten im n\"achsten Abschnitt anhand eines Beispiels im Detail 
            diskutieren. 
      \end{enumerate}

\end{enumerate}
Die von \textsc{Cup} mit der Option ``\texttt{-dump}'' erzeugte Ausgabe zeigt im Detail, wie die
Shift/Reduce-Konflikt Konflikte aufgel\"ost worden sind.  Wir betrachten exemplarisch zwei Zust\"ande in
der Datei, die f\"ur die in Abbildung \ref{fig:calc-precedence.cup} gezeigte Grammatik erzeugt wird.
\begin{enumerate}
\item Der Zustand Nummer 14 hat die in Abbildung \ref{fig:state14} gezeigte Form.
      Hier gibt es unter anderem einen Shift/Reduce-Konflikt zwischen den beiden markierten Regeln
      \\[0.2cm]
      \hspace*{1.3cm}
      $E \rightarrow E \bullet \quoted{+} E$ \quad und \quad
      $E \rightarrow E \quoted{*} E \bullet$, 
      \\[0.2cm]
      denn die erste Regel verlangt nach einem Shift, w\"ahrend die zweite Regel eine Reduktion fordert.
      Da die Regel $E \rightarrow E \quoted{*} E$ dieselbe Pr\"azedenz wie der Operator ``\texttt{*}''
      und dieser eine h\"ohere Pr\"azedenz als $\quoted{+}$ hat, wird beispielsweise beim Lesen des Zeichens
      ``\texttt{+}'' mit der Regel $E \rightarrow E \quoted{*} E$ reduziert.
      Wird hingegen das Zeichen ``\texttt{\^}'' gelesen, so wird dieses geshiftet, denn
      dieses Zeichen hat eine h\"ohere Priorit\"at als die Regel
       $E \rightarrow E \quoted{*} E$.
    \begin{figure}[!ht]
    \centering
    \begin{Verbatim}[ frame         = lines, 
                      framesep      = 0.3cm, 
                      labelposition = bottomline,
                      numbers       = left,
                      numbersep     = -0.2cm,
                      xleftmargin   = 0.8cm,
                      xrightmargin  = 0.8cm,
                    ]
    lalr_state [14]: {
      [expr ::= expr (*) PLUS expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr TIMES expr (*) , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr (*) POW expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr (*) TIMES expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr (*) MOD expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr (*) MINUS expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr (*) DIVIDE expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
    }

    From state #14
     [term 2:REDUCE(with prod 7)] [term 3:REDUCE(with prod 7)]
     [term 4:REDUCE(with prod 7)] [term 5:REDUCE(with prod 7)]
     [term 6:REDUCE(with prod 7)] [term 7:REDUCE(with prod 7)]
     [term 8:SHIFT(to state 9)] [term 11:REDUCE(with prod 7)]
    \end{Verbatim} 
    %$
    \vspace*{-0.3cm}
    \caption{Der Zustand Nummer 14.}
    \label{fig:state14}
  \end{figure}
      Weiterhin gibt es einen Shift/Reduce-Konflikt zwischen den beiden markierten Regeln
      \\[0.2cm]
      \hspace*{1.3cm}
      $E \rightarrow E \bullet \quoted{*} E$ \quad und \quad
      $E \rightarrow E \quoted{*} E \bullet$.
      \\[0.2cm]
      Hier haben beide Regeln die gleiche Pr\"azedenz.  Daher entscheidet die  Assoziativit\"at.
      Da der Operator ``\texttt{*}'' links-assoziativ ist, wird mit der Regel
      $E \rightarrow E \quoted{*} E$ reduziert, falls das n\"achste Zeichen ein Multiplikations-Operator
      ``\texttt{*}'' ist.
\item Der Zustand Nummer 18 hat die in Abbildung \ref{fig:state18} gezeigte Form.
      Zun\"achst gibt es hier einen Shift/Reduce-Konflikt zwischen den Regeln
      \\[0.2cm]
      \hspace*{1.3cm}
      $E \rightarrow E \bullet \quoted{\symbol{94}} E$ \quad und \quad
      $E \rightarrow E \quoted{\symbol{94}} E  \bullet$,
      \\[0.2cm]
      wenn das n\"achste Token der Operator ``\texttt{\symbol{94}}'' ist.  Da der Operator 
      dieselbe Pr\"azedenz 
      hat wie die Regel, entscheidet die Assoziativit\"at.  Nun ist der Operator
      ``\texttt{\symbol{94}}'' rechts-assoziativ, daher wird in diesem Fall geshiftet.

    \begin{figure}[!ht]
    \centering
    \begin{Verbatim}[ frame         = lines, 
                      framesep      = 0.3cm, 
                      labelposition = bottomline,
                      numbers       = left,
                      numbersep     = -0.2cm,
                      xleftmargin   = 0.8cm,
                      xrightmargin  = 0.8cm,
                    ]
    lalr_state [18]: {
      [expr ::= expr POW expr (*) , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr (*) PLUS expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr (*) POW expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr (*) TIMES expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr (*) MOD expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr (*) MINUS expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
      [expr ::= expr (*) DIVIDE expr , {SEMI PLUS MINUS TIMES DIVIDE MOD POW RPAREN }]
    }

    From state #18
     [term 2:REDUCE(with prod 10)] [term 3:REDUCE(with prod 10)]
     [term 4:REDUCE(with prod 10)] [term 5:REDUCE(with prod 10)]
     [term 6:REDUCE(with prod 10)] [term 7:REDUCE(with prod 10)]
     [term 8:SHIFT(to state 9)] [term 11:REDUCE(with prod 10)]
    \end{Verbatim} 
    %$
    \vspace*{-0.3cm}
    \caption{Der Zustand Nummer 18.}
    \label{fig:state18}
  \end{figure}

      Hier gibt es noch viele andere Shift/Reduce-Konflikte, die aber alle dieselbe Struktur haben.
      Exemplarisch betrachten wir den Shift/Reduce-Konflikt zwischen den Regeln
      \\[0.2cm]
      \hspace*{1.3cm}
      $E \rightarrow E \bullet \quoted{+} E$ \quad und \quad
      $E \rightarrow E \quoted{\symbol{94}} E  \bullet$,
      \\[0.2cm]
      der auftritt, wenn das n\"achste Token ein ``\texttt{+}'' ist.  Da die Regel 
      $E \rightarrow E \quoted{\symbol{94}} E$ die Pr\"azedenz 3 hat, die gr\"o{\ss}er ist als die Pr\"azedenz 1 des
      Operators ``\texttt{+}'' wird dieser Konflikt dadurch aufgel\"ost, dass mit der Regel 
      $E \rightarrow E \quoted{\symbol{94}} E$ reduziert wird. 
\end{enumerate}    
\vspace*{\fill} \pagebreak

\exercise
Implementieren Sie einen \textsc{Cup}-Parser, der in der Lage ist, eine
\textsc{Cup}-Grammatik zu lesen und zus\"atzlich die folgenden Anforderungen erf\"ullt:
\begin{enumerate}
\item Die Grammatik soll intern in Form eines abstrakten Syntax-Baums abgespeichert werden.  
      In dem Verzeichnis 
      \\[0.2cm]
      \hspace*{1.3cm}
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Exercises/Grammar2HTML-Cup/}{
\texttt{Exercises/Grammar2HTML-Cup/}}
      \\[0.2cm]
      finden Sie verschiedene \textsl{Java}-Klassen, mit denen Sie einen solchen Syntax-Baum
      darstellen k\"onnen.  Diese Klassen implementieren eine Methode \texttt{toString()}, mit deren
      Hilfe sich der Syntax-Baum bequem im \textsc{Html}-Format ausgeben l\"asst.  Au{\ss}erdem enth\"alt
      das Verzeichnis auch die Datei 
      \href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Exercises/Grammar2HTML-Cup/Grammatik.java}{\texttt{Grammatik.java}},
      welche die Klasse \texttt{Grammatik}
      implementiert.  Diese Klasse enth\"alt eine Methode \texttt{main}, mit der Sie Ihren Parser
      testen k\"onnen.
\item Die semantischen Aktionen der gelesenen Grammatik sollen unterdr\"uckt werden.
\item Testen Sie Ihr Programm, indem Sie es sowohl auf sich selbst als auch auf die im Unterricht
      vorgestellte Grammatik f\"ur arithmetische Ausdr\"ucke anwenden.
      Zus\"atzlich k\"onnen Sie es auch auf die \texttt{C}-Grammatik, die Sie unter
      \\[0.2cm]
      \hspace*{1.3cm}
      \href{https://github.com/karlstroetmann/Formal-Languages/blob/master/Cup/Grammars/c-grammar.cup}{https://github.com/karlstroetmann/Formal-Languages/blob/master/Cup/Grammars/c-grammar.cup}
      \\[0.2cm]
      im Netz finden, anwenden.
\end{enumerate}


\section{Das \emph{Dangling-Else}-Problem}
\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    class Dangling;
    
    terminal LPAREN, RPAREN, IF, ELSE, WHILE, LBRACE, RBRACE, ASSIGN, SEMI;
    terminal EQUAL, ID;
    
    nonterminal stmnt, stmntList, expr;
    
    start with stmnt;
    
    stmnt ::= IF LPAREN expr RPAREN stmnt
           |  IF LPAREN expr RPAREN stmnt ELSE stmnt
           |  WHILE LPAREN expr RPAREN stmnt
           |  LBRACE stmntList RBRACE
           |  ID ASSIGN expr SEMI
           ;
      
    stmntList ::= stmntList stmnt
               |  /* epsilon */
               ;
    
    expr ::= ID EQUAL ID
           | ID
           ;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Fragment einer Grammatik f\"ur die Sprache \texttt{C}}
\label{fig:dangling-else.y}
\end{figure}

\noindent
Bei der syntaktischen Beschreibung von Befehlen der Sprache \texttt{C} tritt bei der Behandlung
von \emph{if-then-else} Konstrukten ein Shift/Reduce-Konflikt auf, den wir jetzt analysieren wollen.
Abbildung \ref{fig:dangling-else.y} zeigt die Grammatik 
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Cup/DanglingElse/dangling.cup}{\texttt{dangling.cup}},
die einen Teil der Syntax von Befehlen der Sprache \texttt{C} beschreibt.  Um uns auf das
Wesentliche konzentrieren zu k\"onnen, sind dort die Ausdr\"ucke nur Gleichungen und Variablen.  Das
Token ``\texttt{ID}'' (Abk\"urzung f\"ur \textsl{Identifier}) steht f\"ur eine Variable, die Grammatik
beschreibt also Befehle, die aus Zuweisungen, \emph{If-Abfragen}, \emph{If-Else-Abfragen} und
\emph{While-Schleifen} aufgebaut sind.  \"Ubersetzen wir diese Grammatik mit \textsc{Cup}, so erhalten
wir den in Abbildung \ref{fig:dangling-else.output} ausschnittsweise gezeigten 
Shift/Reduce-Konflikt. 

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    Warning : *** Shift/Reduce conflict found in state #10
      between stmnt ::= IF LPAREN expr RPAREN stmnt (*) 
      and     stmnt ::= IF LPAREN expr RPAREN stmnt (*) ELSE stmnt 
      under symbol ELSE
      Resolved in favor of shifting.

    lalr_state [10]: {
      [stmnt ::= IF LPAREN expr RPAREN stmnt (*) , {EOF IF ELSE WHILE LBRACE RBRACE ID }]
      [stmnt ::= IF LPAREN expr RPAREN stmnt (*) ELSE stmnt , {EOF IF ELSE WHILE LBRACE RBRACE ID }]
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Ein Shift/Reduce-Konflikt.}
\label{fig:dangling-else.output}
\end{figure}
%$

Der Konflikt entsteht bei der Berechnung von
 $\texttt{action}(\mbox{``\texttt{state \#10}''}, \mbox{``\texttt{else}''})$ zwischen den
beiden markierten Regeln
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{stmnt} \rightarrow \quoted{if} \quoted{(} \textsl{expr} \quoted{)} \textsl{stmnt}\;\; \bullet$ 
\quad und
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{stmnt} \rightarrow 
\quoted{if} \quoted{(} \textsl{expr} \quoted{)} \textsl{stmnt} \;\bullet \quoted{else} \textsl{stmnt}$.
\\[0.2cm]
Die erste Regel verlangt nach einer Reduktion, die zweite Regel sagt, dass das Token 
\texttt{else} geshiftet werden soll.  Das dem Konflikt zu Grunde liegende Problem ist, dass die in Abbildung
\ref{fig:dangling-else.y} gezeigte Grammatik mehrdeutig ist, denn ein \textsl{stmnt} der Form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{if (a == b) if (c == d) s = t; else u = v;}
\\[0.2cm]
kann auf die folgenden beiden Arten gelesen werden:
\begin{enumerate}
\item Die erste (und nach der Spezifikation der Sprache \texttt{C} auch korrekte) Interpretation 
      besteht darin, dass wir den Befehl wie folgt klammern:
      \begin{verbatim}
      if (a == b) {
          if (c == d) {
              s = t; 
          } else {
              u = v;
          }
      }
      \end{verbatim}
      \vspace*{-0.7cm}
\item Die zweite Interpretation, die nach der in Abbildung
      \ref{fig:dangling-else.y} gezeigten Grammatik ebenfalls zul\"assig w\"are,
      w\"urde den Befehl in der folgenden Form interpretieren:
      \begin{verbatim}
      if (a == b) {
          if (c == d) {
              s = t; 
          }
      } else {
          u = v;
      }
      \end{verbatim}
      \vspace*{-0.5cm}

      Hier wird das ``\texttt{else}'' dem \"au{\ss}eren ``\texttt{if}'' zugeordnet, was nicht der
      Spezifikation der Sprache \texttt{C} entspricht. 
\end{enumerate}
Es gibt vier M\"oglichkeiten, das Problem zu l\"osen.
\begin{enumerate}
\item Tritt ein Shift/Reduce-Konflikt auf, der nicht durch Operator-Pr\"azedenzen gel\"ost wird,
      so ist der Default, dass das n\"achste Token auf den Stack geschoben wird.  In dem konkreten
      Fall ist dies genau das, was wir wollen, weil dadurch das ``\texttt{else}'' immer mit dem letzten
      ``\texttt{if}'' assoziert wird.  Um die normalerweise bei Konfliken von \textsc{Cup}
      ausgel\"oste Fehlermeldung zu unterdr\"ucken, m\"ussen wir \textsc{Cup} mit der Option
      ``\texttt{-expect}'' wie folgt aufrufen:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{cup -expect 1 -dump dangling.cup}
      \\[0.2cm]
      Die Zahl \texttt{1} gibt hier die Anzahl der Konflikte an, die wir erwarten.
      So lange die spezifizierte Zahl der Konflikte mit der tats\"achlich gefundenen Zahl \"ubereinstimmt,
      wird von \textsc{Cup} nur eine Warnung und keine Fehlermeldung ausgegeben. Insbesondere wird
      in diesem Fall ein Parser erzeugt.
\item Die zweite M\"oglichkeit besteht darin, die Grammatik so umzuschreiben, dass die Mehrdeutigkeit
      verschwindet.   Die grunds\"atzliche Idee ist hier, zwischen zwei Arten von Befehlen zu
      unterscheiden.
      \begin{enumerate}
      \item[(a)] Einerseits gibt es Befehle, bei denen jedem ``\texttt{if}'' auch ein ``\texttt{else}''
            zugeordnet ist.  Zwischen einem ``\texttt{if}'' und einem ``\texttt{else}'' d\"urfen nur
            solche Befehle auftreten.

            Wir bezeichnen Befehle dieser Form als \emph{geschlossene Befehle}.  Die Idee bei dieser
            Sprechweise besteht darin, dass ``\texttt{if}'' als \"offnende Klammer zu interpretieren,
            w\"ahrend das ``\texttt{else}'' einer schlie{\ss}enden Klammer entspricht.  Bei einem
            geschlossenen Befehl entspricht jeder \"offnenden Klammer eine schlie{\ss}ende Klammer.
     \item[(b)] Andererseits gibt es Befehle, bei denen dem letzten ``\texttt{if}'' kein
            ``\texttt{else}'' zugeordnet ist.  Solche Befehle bezeichnen wir als \emph{offene Befehle}.
            Offene Befehle d\"urfen nicht zwischen einem ``\texttt{if}'' und einem ``\texttt{else}''
            auftreten, denn dann m\"usste das ``\texttt{else}'' dem ``\texttt{if}'' des offenen
            Befehls zugeordnet werden und der offene Befehl w\"are in Wahrheit geschlossen.
     \end{enumerate}
      Abbildung \ref{fig:dangling-else-correct.cup} zeigt die Grammatik
      \href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Cup/DanglingMatched/dangling.cup}{\texttt{dangling.cup}},
      die diese Idee umsetzt.  In der Abbildung sind nur noch die Grammatik-Regeln gezeigt, denn die
      Deklaration der Terminale und syntaktischen Variablen hat sich gegen\"uber der urspr\"unglichen
      Grammatik nicht ver\"andert. Die syntaktische Kategorie \textsl{matchedStmnt} beschreibt dabei
      die Befehle, bei denen jedem ``\texttt{if}'' ein ``\texttt{else}'' zugeordnet ist, w\"ahrend die
      Kategorie \textsl{unMatchedStmnt} die restlichen Befehle erfasst.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    stmnt ::= matchedStmnt
           |  unmatchedStmnt
           ;
    
    matchedStmnt ::= IF LPAREN expr RPAREN matchedStmnt ELSE matchedStmnt
                  |  WHILE LPAREN expr RPAREN matchedStmnt
                  |  LBRACE stmntList RBRACE
                  |  ID ASSIGN expr SEMI
                  ;
    
    unmatchedStmnt ::= IF LPAREN expr RPAREN stmnt
                    |  IF LPAREN expr RPAREN matchedStmnt ELSE unmatchedStmnt
                    |  WHILE LPAREN expr RPAREN unmatchedStmnt
                    ;
          
    stmntList ::= stmntList stmnt 
               |  /* epsilon */
               ;
    
    expr ::= ID EQUAL ID
           | ID
           ;
    \end{Verbatim}
    \vspace*{-0.3cm}
    \caption{Eine eindeutige Grammatik f\"ur \texttt{C}-Befehle.}
    \label{fig:dangling-else-correct.cup}
\end{figure}

      Aus theoretischer Sicht ist das Umschreiben der Grammatik der sauberste Weg.  
      Aus diesem Grund haben die Entwickler der Sprache \textsl{Java} \cite{gosling:96} bei der
      \href{http://titanium.cs.berkeley.edu/doc/java-langspec-1.0/14.doc.html#5991}{Spezifikation}
      der Syntax den oben skizzierten Weg beschritten.   
      Der Nachteil ist allerdings, dass bei diesem Vorgehen die Grammatik aufgebl\"aht wird. 
\item Die n\"achste M\"oglichkeit um das \emph{Dangling-Else}-Problem zu l\"osen, besteht darin, dass
      wir ``\texttt{if}'' und ``\texttt{else}'' als Operatoren auffassen, denen wir eine Pr\"azedenz
      zuordenen.  Abbildung \ref{fig:dangling-else-precedence.cup} zeigt die Grammatik
      \href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Cup/DanglingOperator/dangling.cup}{\texttt{dangling.cup}},
      bei der dieser Weg beschritten wurde.
      \begin{enumerate}
      \item[(a)] Zun\"achst haben wir in den Zeilen 1 und 2 die Terminale ``\texttt{IF}'' und
            ``\texttt{ELSE}''  als
            nicht-assoziative Operatoren deklariert, wobei ``\texttt{ELSE}'' die h\"ohere Pr\"azedenz
            hat.  Dadurch erreichen wir, dass ein ``\texttt{ELSE}'' auf den Stack geschoben wird,
            wenn der Parser in dem in Abbildung \ref{fig:dangling-else.output} gezeigten Zustand ist.
      \item[(b)] In Zeile 6 haben wir der Regel
            \\[0.2cm]
            \hspace*{1.3cm}
            \textsl{stmnt} \texttt{::=} \texttt{IF} \texttt{LPAREN} \textsl{expr} \texttt{RPAREN} \textsl{stmnt}
            \\[0.2cm]      
            explizit mit Hilfe der nachgestellten Option
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{\symbol{37}prec IF}
            \\[0.2cm]
            die Pr\"azedenz des Operators ``\texttt{IF}'' zugewiesen.  Dies ist notwendig, weil 
            der letzte Operator, der in dieser Regel auftritt, die schlie{\ss}ende runde Klammer
            ``\texttt{RPAREN}'' ist, der wir keine Priorit\"at zugewiesen haben.  Der Klammer eine Priorit\"at
            zuzuweisen w\"are einerseits kontraintuitiv, andererseits problematisch, da die Klammer ja
            auch noch an anderen Stellen verwendet werden k\"onnte.  Mit Hilfe der
            ``\texttt{\symbol{37}prec}''-Deklaration k\"onnen wir einer Regel unmittelbar die Pr\"azedenz
            eines Operators zuweisen und so das Problem umgehen.

            In dem vorliegenden Fall ist die Pr\"azedenz des Operators ``\texttt{ELSE}''
            h\"oher als die Pr\"azedenz von ``\texttt{IF}'', so dass der Shift/Reduce-Konflikt
            dadurch aufgel\"ost wird, dass das Token ``\texttt{ELSE}'' auf den Stack
            geschoben wird, wodurch eine ``\texttt{else}''-Klausel tats\"achlich mit der unmittelbar davor stehenden
            ``\texttt{if}''-Klausel verbunden wird, wie es die Definition der Sprache \texttt{C} fordert.
      \end{enumerate}


            \begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    precedence nonassoc IF;
    precedence nonassoc ELSE;

    start with stmnt;

    stmnt ::= IF LPAREN expr RPAREN stmnt            %prec IF
           |  IF LPAREN expr RPAREN stmnt ELSE stmnt
           |  WHILE LPAREN expr RPAREN stmnt
           |  LBRACE stmntList RBRACE
           |  ID ASSIGN expr SEMI
           ;
      
    stmntList ::= stmntList stmnt
               |  /* epsilon */
               ;
    
    expr ::= ID EQUAL ID
           | ID
           ;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Aufl\"osung des Shift/Reduce-Konflikts mit Hilfe von Operator-Pr\"azedenzen.}
\label{fig:dangling-else-precedence.cup}
\end{figure}

      Operator-Pr\"azedenzen sind ein m\"achtiges Mittel um eine Grammatik zu strukturieren.  Sie
      sollten allerdings mit Vorsicht eingesetzt werden, denn Sprachen wie die
      Programmier-Sprache \texttt{C}, bei der es 15 verschiedene Operator-Pr\"azendenzen gibt, \"uberfordern
      die meisten Benutzer.
\item Die letzte M\"oglichkeit, das \emph{Dangling-Else}-Problem zu l\"osen, besteht darin, dass wir
      fordern, dass die Befehle, die in einem ``\texttt{if}''-Befehl verwendet werden, immer in den geschweiften
      Klammern ``\texttt{\{}'' und ``\texttt{\}}'' eingeschlossen werden.  Dies ist allerdings nur
      dann eine Option, wenn wir die Syntax der Sprache selber definieren k\"onnen.  Bei der Sprache
      \href{http://randoom.org/Software/SetlX}{\textsc{SetlX}}
      wurde dieser Weg beschritten.  Abbildung \ref{fig:dangling-else-brace.cup} auf Seite
      \pageref{fig:dangling-else-brace.cup} zeigt die Grammatik
      \href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Cup/DanglingBrace/no-dangling.cup}{\texttt{no-dangling.cup}},
      bei der durch die Verwendung von geschweiften Klammern erreicht wurde, dass keine
      Mehrdeutigkeit mehr auftritt. 

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    stmnt ::= IF LPAREN expr RPAREN block            
           |  IF LPAREN expr RPAREN block ELSE block
           |  WHILE LPAREN expr RPAREN stmnt
           |  block
           |  ID ASSIGN expr SEMI
           ;
    
    block ::= LBRACE stmntList RBRACE
           ;
    
    stmntList ::= stmntList stmnt
               |  /* epsilon */
               ;    

    expr ::= ID EQUAL ID
           | ID
           ;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Eine Grammatik ohne das \emph{Dangling-Else}-Problem.}
\label{fig:dangling-else-brace.cup}
\end{figure}

\end{enumerate}
 


\section{Aufl\"osung von Reduce/Reduce-Konflikten}
Im Gegensatz zu Shift/Reduce-Konflikten k\"onnen Reduce/Reduce-Konflikte nicht durch Operator-Pr\"azedenzen
aufgel\"ost werden.  Wir diskutieren in diesem Abschnitt die M\"oglichkeiten, die wir haben um
Reduce/Reduce-Konflikte aufzul\"osen.  Wir beginnen unsere Diskussion damit, dass wir die
Reduce/Reduce-Konflikte in verschiedene Kategorien einteilen. 
\begin{enumerate}
\item \emph{Mehrdeutigkeits-Konflikte} sind Reduce/Reduce-Konflikte, die ihre Ursache in einer Mehrdeutigkeit
      der zu Grunde liegenden Grammatik haben.  Solche Konflikte weisen damit auf ein tats\"achliches
      Problem der Grammatik hin.  Wir hatten ein Beispiel f\"ur solche Konflikte gesehen, als wir in
      Abbildung \ref{fig:calc-ambiguous.cup} in der Grammatik
      \href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Cup/Calculator-Ambiguous/calc.cup}{\texttt{calc.cup}} 
      versucht hatten, die Syntax arithmetischer Ausdr\"ucke ohne die syntaktischen
      Kategorien \textsl{product} und \textsl{factor} zu beschreiben.

      Wir hatten damals bereits gesehen, dass wir das Problem durch die Einf\"uhrung von
      Operator-Pr\"azedenzen l\"osen k\"onnen.  Falls dies nicht m\"oglich ist, dann bleibt nur das
      Umschreiben der Grammatik.
\item \emph{Look-Ahead-Konflikte} sind Reduce/Reduce-Konflikte, bei denen die Grammatik zwar
      einerseits eindeutig ist, f\"ur die aber andererseits
      ein Look-Ahead von einem Token aber nicht ausreichend ist um den Konflikt zu l\"osen.
\item \emph{Mysteri\"ose Konflikte} entstehen erst beim \"Ubergang von den LR-Zust\"anden zu den LALR-Zust\"anden 
      durch das Zusammenfassen von Zust\"anden mit dem gleichen Kern.  Diese Konflikte treten also
      genau dann auf, wenn das Konzept einer LALR-Grammatik nicht ausreichend ist um die Syntax der
      zu parsenden Sprache zu beschreiben.
\end{enumerate}
Wir betrachten die letzten beiden F\"alle nun im Detail und zeigen Wege auf, wie die Konflikte gel\"ost
werden k\"onnen.

\subsection{Look-Ahead-Konflikte}
Ein Look-Ahead-Konflikt liegt dann vor, wenn die Grammatik zwar eindeutig ist, aber ein Look-Ahead von einem
Token nicht ausreicht um zu entscheiden,  mit welcher Regel reduziert werden soll.  Abbildung 
\ref{fig:lr-conflict.g} zeigt die Grammatik 
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Cup/LookAheadConflict/lookAhead.cup}{\texttt{lookAhead.cup}}\footnote{ 
Diese Grammatik habe ich im Netz auf der Seite von Pete Jinks unter der Adresse
\\[0.1cm]
\hspace*{1.3cm}
\href{http://www.cs.man.ac.uk/~pjj/cs212/ho/node19.html}{\texttt{http://www.cs.man.ac.uk/\symbol{126}pjj/cs212/ho/node19.html}}
\\[0.1cm]
gefunden.},
die zwar eindeutig ist, aber nicht die LR(1)-Eigenschaft hat.  

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    terminal    U, V, W, X;
    nonterminal a, b, c;

    a ::= b U V
       |  c U W
       ;    
    b ::= X
       ;
    c ::= X 
       ;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Eine eindeutige Grammatik ohne die LR(1)-Eigenschaft.}
\label{fig:lr-conflict.g}
\end{figure}


Berechnen wir die LR-Zust\"ande dieser Grammatik,
so finden wir unter anderem den folgenden Zustand:
\\[0.2cm]
\hspace*{1.3cm}
$\{ b \rightarrow \;\squoted{X} \bullet: \squoted{U},\; c \rightarrow \;\squoted{X} \bullet: \squoted{U} \}$.
\\[0.2cm]
Da die Menge der Folge-Token f\"ur beide Regeln gleich sind, haben wir hier einen Reduce/Reduce-Konflikt.
Dieser Konflikt hat seine Ursache darin, dass der Parser mit einem Look-Ahead von nur einem Token nicht
entscheiden kann, ob ein $\squoted{X}$ als ein $b$ oder als ein $c$ zu interpretieren ist, denn dies
entscheidet sich erst, wenn das auf $\squoted{U}$ folgende Zeichen gelesen wird:  Handelt es sich hierbei
um ein $\squoted{V}$, so wird insgesamt die Regel
\\[0.2cm]
\hspace*{1.3cm}
$a \rightarrow b\; \squoted{U} \squoted{V}$
\\[0.2cm]
verwendet werden und folglich ist das $\squoted{X}$ als ein $b$ zu interpretieren. Ist das zweite Token
hinter dem $\squoted{X}$ hingegen ein  $\squoted{W}$, so ist die zu verwendende Regel
\\[0.2cm]
\hspace*{1.3cm}
$a \rightarrow c \;\squoted{U} \squoted{W}$
\\[0.2cm]
und folglich ist das $\quoted{X}$ als  $c$ zu lesen.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    a ::= b V
       |  c W
       ;
    b ::= X U
       ;
    c ::= X U
       ;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Eine zu \ref{fig:lr-conflict.g} \"aquivalente LR(1)-Grammatik.}
\label{fig:lr-conflict-resolved.g}
\end{figure}

Das Problem bei dieser Grammatik ist, dass sie versucht, abh\"angig vom Kontext ein $\squoted{X}$ wahlweise
als ein $b$ oder als ein $c$ zu interpretieren.  Es ist offensichtlich, wie das Problem gel\"ost werden
kann:  Wenn der Kontext ``\texttt{U}'', der sowohl auf $b$ als auch auf $c$ folgt, mit in
die Regeln f\"ur $b$ und $c$ aufgenommen wird, dann verschwindet der Konflikt, denn dann hat der
Zustand, in dem fr\"uher der Konflikt auftrat, die Form
\\[0.2cm]
\hspace*{1.3cm}
$\{ b \rightarrow \;\squoted{X} \squoted{U}\bullet: \squoted{V},\; 
    c \rightarrow \;\squoted{X} \squoted{U}\bullet: \squoted{W} 
\}
$.
\\[0.2cm]  
Hier entscheidet sich nun anhand des n\"achsten Tokens, mit welcher Regel wir in diesem Zustand
reduzieren m\"ussen:  Ist das n\"achste Token ein $\squoted{V}$, so reduzieren wir mit der Regel
\\[0.2cm]
\hspace*{1.3cm}
$b \rightarrow \;\squoted{X} \squoted{U}$,
\\[0.2cm]
ist das n\"achste Token hingegen der Buchstabe $\squoted{W}$, so nehmen wir stattdessen die Regel
\\[0.2cm]
\hspace*{1.3cm}
$c \rightarrow \;\squoted{X} \squoted{U}\bullet: \squoted{W}$.
\\[0.2cm]
Abbildung
\ref{fig:lr-conflict-resolved.g} zeigt die entsprechend modifizierte Grammatik
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Cup/LookAheadConflict/solved.cup}{\texttt{solved.cup}},

\subsection{Mysteri\"ose Reduce/Reduce-Konflikte}
Wir sprechen dann von einem \emph{mysteri\"osen Reduce/Reduce-Konflikt}, wenn die gegebene Grammatik eine
LR(1)-Grammatik ist, sich aber beim \"Ubergang von den LR-Zust\"anden zu den LALR-Zust\"anden Reduce/Reduce-Konflikte
ergeben.  Die in Abbildung \ref{fig:mysterious.cup} gezeigte Grammatik 
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Cup/MysteriousConflict/mysterious.cup}{\texttt{mysterious.cup}}
habe ich dem 
\href{http://www.gnu.org/software/bison/manual/}{\textsl{Bison}-Handbuch} entnommen. 


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    terminal    ID, COMMA, COLON;
    nonterminal def, param_spec, return_spec, type, name_list, name;
    
    def   
        ::= param_spec return_spec COMMA
         ;
    param_spec
        ::= type
         |  name_list COLON type
         ;    
    return_spec
        ::= type
         |  name COLON type
         ;
    type  
        ::= ID
         ;    
    name
        ::= ID
         ;
    name_list
        ::= name
         |  name COMMA name_list
         ;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Eine \textsc{Cup}-Grammatik mit einem mysteri\"osen Reduce/Reduce-Konflikt.}
\label{fig:mysterious.cup}
\end{figure}
\vspace*{0.3cm}

\"Ubersetzen wir diese Grammatik mit \textsc{Cup}, so erhalten wir unter anderem den folgenden Zustand:
\begin{verbatim}
    lalr_state [1]: {
      [name ::= ID (*) , {COMMA COLON }]
      [type ::= ID (*) , {ID COMMA }]
    }
\end{verbatim}
Da in beiden Mengen von Folgetoken das Token \texttt{COMMA} auftritt, gibt es hier offensichtlich einen
Reduce/Reduce-Konflikt.   Um diesen Konflikt besser zu verstehen, berechnen wir zun\"achst die Zust\"ande
eines kanonischen LR-Parsers f\"ur diese Grammatik.
Wir erhalten dann eine Menge von Zust\"anden, von denen die f\"ur den sp\"ateren Konflikt urs\"achlichen 
Zust\"anden in Abbildung \ref{fig:mysterious.txt} gezeigt sind.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    s0 = { S -> <*> def: [$],
           def -> <*> param_spec return_spec ',': [$],
           param_spec -> <*> name_list ':' type: [ID],
           param_spec -> <*> type: [ID],
           name_list -> <*> name: [':'],
           name_list -> <*> name ',' name_list: [':'],
           name -> <*> ID: [',', ':'],
           type -> <*> ID: [ID]
         }
    s2 = { def -> param_spec <*> return_spec ',': [$],
           return_spec -> <*> name ':' type: [','],
           return_spec -> <*> type: [','],
           name -> <*> ID: [':'],
           type -> <*> ID: [',']
         }
    s7 = { name -> ID <*>: [',', ':'],
           type -> ID <*>: [ID]
         }
    s8 = { name -> ID <*>: [':'],
           type -> ID <*>: [',']
         }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{LR-Zust\"ande der in Abbildung \ref{fig:mysterious.cup} gezeigten Grammatik.}
\label{fig:mysterious.txt}
\end{figure} %\$

Analysieren wir die Zust\"ande, so stellen wir fest, dass beim \"Ubergang von LR-Zust\"anden zu den
LALR-Zust\"anden die beiden Zust\"ande $s_7$ und $s_8$ zu einem Zustand zusammengefasst werden, denn diese
beiden Zust\"ande haben den selben Kern.  Bei der Zusammenfassung entsteht der Zustand, der von
\textsc{Cup} als ``\texttt{lalr\_state [1]}'' bezeichnet hat.  Die Zust\"ande $s_7$ und $s_8$ selber haben
noch keinen Konflikt, weil dort die Mengen der Folgetoken disjunkt sind.  Der Konflikt tritt erst durch
die Vereinigung dieser beiden Mengen auf, denn dadurch ist das Token ``$\texttt{,}$'' als Folgetoken f\"ur
beide in dem Zustand enthaltenen Regeln zul\"assig.   Um den Konflikt aufzul\"osen m\"ussen wir verhindern, dass
die beiden Zust\"ande $s_7$ und $s_8$ zusammengefasst werden.  Dazu analysieren wir zun\"achst, wo diese
Zust\"ande herkommen.
\begin{enumerate}
\item Den Zustand $s_7$ erhalten wir, wenn wir im Zustand $s_0$ das Token \texttt{ID} lesen, denn
      es gilt 
      \\[0.2cm]
      \hspace*{1.3cm}
      $s_7 = \textsl{goto}(s_0, \mathtt{ID})$.
\item Der Zustand $s_8$ entsteht, wenn das Token \texttt{ID} im Zustand $s_2$ gelesen wird, wir haben
      \\[0.2cm]
      \hspace*{1.3cm}
      $s_8 = \textsl{goto}(s_2, \mathtt{ID})$.
\end{enumerate}
Die Idee zur Aufl\"osung des Konflikts ist, dass wir den Zustand $s_2$ so \"andern, dass die Kerne von
$s_7 = \textsl{goto}(s_0, \mathtt{ID})$ und $s_8 = \textsl{goto}(s_0, \mathtt{ID})$ unterschiedlich werden.  
Die erweiterten markierten Regeln in den Zust\"anden $s_0$ und $s_2$, die letztlich f\"ur den Konflikt verantwortlich
sind, sind die Grammatik-Regeln f\"ur die syntaktische Variablen \textsl{param\_spec} und
\textsl{return\_spec}, denn von diesen Regeln werden die  Zust\"ande $s_7$ und $s_8$ abgeleitet.
Um zu verhindern, dass diese Zust\"ande zusammengefasst werde, \"andern wir die Regeln f\"ur die
syntaktische Variable \textsl{return\_spec} wie in der in Abbildung \ref{fig:myst-solved.g}
gezeigten Grammatik
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Cup/MysteriousConflict/mysterious-solved.cup}{\texttt{mysterious-solved.cup}}
 ab,
indem wir eine zus\"atzliche Grammatik-Regel 
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{return\_spec} \rightarrow \mathtt{ID}\;\, \mathtt{BOGUS}$
\\[0.2cm]
einf\"uhren.  Wenn das Terminal \texttt{BOGUS} nie vom Scanner erzeugt werden kann, dann \"andert sich durch
die Hinzunahme dieser Regel die von der Grammatik erzeugte Sprache nicht.  Allerdings \"andern sich nun die
LR-Zust\"ande.  Abbildung \ref{fig:myst-solved.txt} zeigt, wie sich die entsprechenden Zust\"ande \"andern.
Insbesondere sehen wir, dass der Zustand $s_8$ nun eine weitere markierte Regel enth\"alt, zu der es in dem
Zustand $s_7$ kein \"aquivalent gibt.  Die Konsequenz ist, dass diese Zust\"ande beim \"Ubergang von den
LR-Zust\"anden zu den LALR-Zust\"anden nicht mehr zusammengefasst werden k\"onnen, da sie unterschiedliche
Kerne haben.  Daher gibt es dann auch keinen Konflikt mehr. 

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    def : param_spec return_spec ','
        ;    
    param_spec
        : type
        |  name_list ':' type
        ;
    return_spec
        : type
        | name ':' type
        | ID BOGUS      // this never happens
        ;
    type: ID
        ;
    name: ID
        ;
    name_list
        : name
        | name ',' name_list
        ;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Aufl\"osung des mysteri\"osen Reduce/Reduce-Konflikts.}
\label{fig:myst-solved.g}
\end{figure}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    s0 = { S -> <*> def: [$],
           def -> <*> param_spec return_spec ',': [$],
           name -> <*> ID: [',', ':'],
           name_list -> <*> name: [':'],
           name_list -> <*> name ',' name_list: [':'],
           param_spec -> <*> name_list ':' type: [ID],
           param_spec -> <*> type: [ID],
           type -> <*> ID: [ID]
         }    
    s2 = { def -> param_spec <*> return_spec ',': [$],
           name -> <*> ID: [':'],
           return_spec -> <*> ID BOGUS: [','],
           return_spec -> <*> name ':' type: [','],
           return_spec -> <*> type: [','],
           type -> <*> ID: [',']
         }
    s7 = { name -> ID <*>: [',', ':'],
           type -> ID <*>: [ID]
         }    
    s8 = { name -> ID <*>: [':'],
           return_spec -> ID <*> BOGUS: [','],
           type -> ID <*>: [',']
         }
\end{Verbatim}
\vspace*{-0.3cm} %\$
\caption{Einige Zust\"ande der in Abbildung \ref{fig:myst-solved.g} gezeigten Grammatik.}
\label{fig:myst-solved.txt}
\end{figure}

\section{Aufl\"osung von Shift/Reduce-Konflikten}
Es gibt im Wesentlichen zwei Arten von Shift/Reduce-Konflikten:
\begin{enumerate}
\item Konflikte, die auf eine Mehrdeutigkeit der Grammatik zur\"uckzuf\"uhren sind.

      Solche Mehrdeutigkeits-Konflikte hatten wir beispielsweise in der Grammatik f\"ur arithmetische
      Ausdr\"ucke, die in Abbildung \ref{fig:shift-reduce-conflict.grammar} auf Seite
      \pageref{fig:shift-reduce-conflict.grammar} gezeigt ist, diskutiert.  In dem Beispiel waren
      diese Konflikte darauf zur\"uckzuf\"uhren, dass durch die Grammatik keine Pr\"azedenzen f\"ur die
      arithmetischen Operatoren festgelegt wurde, so dass am Ende nicht klar war, ob ein Ausdruck
      der Form ``\texttt{1+2*3}'' als ``\texttt{1+(2*3)}'' oder als ``\texttt{(1+2)*3}'' zu
      interpretieren ist.

      Wir haben bereits fr\"uher in Abschnitt \ref{section:operator-precedence} besprochen, wie solche
      Konflikte durch die Spezifikation von Operator-Pr\"azedenzen aufgel\"ost werden k\"onnen.
\item Konflikte, die entstehen, weil ein Look-Ahead von einem Token nicht ausreichend ist um zu
      entscheiden, ob das n\"achste Token der Eingabe auf den Stack geschoben werden soll, oder 
      ob stattdessen der Stack durch Anwendung einer Grammatik-Regel reduziert werden muss.
      Solche \emph{Look-Ahead}-Konflikte   werden wir in diesem Abschnitt diskutieren.
\end{enumerate}
Als Beispiel f\"ur einen Look-Ahead-Konflikt betrachten wir die in Abbildung \ref{fig:lambda.g}
gezeigte Grammatik
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Cup/LambdaExpr/lambda.cup}{\texttt{lambda.cup}}.  
Diese Grammatik beschreibt drei Arten von Ausdr\"ucken:
\begin{enumerate}
\item $\lambda$-Ausdr\"ucke haben syntaktisch die Form
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[$x_1$, $\cdots$, $x_n$] |-> $e$}.
      \\[0.2cm]
      Ein solcher Ausdruck steht f\"ur eine Funktion, die $n$ Argumente $x_1$, $\cdots$, $x_n$
      verarbeitet und als Ergebnis den Ausdruck $e$ zur\"uck liefert, wobei der Ausdruck $e$ im
      Allgemeinen von den Parametern $x_1$, $\cdots$, $x_n$ abh\"angen wird.   Ein konkretes Beispiel
      w\"are etwa der $\lambda$-Ausdruck
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[x, y] |-> [x, y, x]}.
\item Zus\"atzlich sind als Ausdr\"ucke Variablen-Namen zugelassen.
\item Au{\ss}erdem sind auch Listen von Ausdr\"ucken m\"oglich, wobei diese Listen in eckigen Klammern
      eingefasst werden.  Diese Listen k\"onnen dabei beliebig geschachtelt sein.
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    terminal MAPSTO, LBRACKET, RBRACKET, COMMA, IDENTIFIER;
    
    nonterminal expr, exprList, lambdaDefinition, identifierList;
    
    expr ::= lambdaDefinition
          |  IDENTIFIER  
          |  LBRACKET exprList RBRACKET
          ;   
    lambdaDefinition
         ::= LBRACKET identifierList RBRACKET MAPSTO expr
          ;
    identifierList
         ::= IDENTIFIER COMMA identifierList 
          |  IDENTIFIER
          ;
    exprList
         ::= expr COMMA exprList
          |  expr
          ;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Eine \textsc{Cup}-Grammatik f\"ur $\lambda$-Ausdr\"ucke.}
\label{fig:lambda.g}
\end{figure}

Versuchen wir mit \textsc{Cup} einen Parser f\"ur diese Grammatik zu erzeugen, so erhalten wir
verschiedene Shift/Reduce-Konflikte.  Diese Konflikte entstehen in dem Zustand Nummer 6, der in
Abbildung \ref{fig:lambda.g:state6} gezeigt ist.  Da auf eine \textsl{expr} ein ``\texttt{,}''
folgen kann, dieses aber in dem Zustand gleichzeitig auch auf den Stack geschoben werden kann, ist
nicht klar, ob mit der Regel 
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{expr} \rightarrow \mathtt{IDENTIFIER}$
\\[0.2cm]
reduziert werden darf, wenn das Look-Ahead-Token ein Komma ist.  Um zu entscheiden, ob der Parser
versucht eine Liste von \texttt{IDENTIFIER}n zu parsen, m\"usste der Parser bis zu dem Token
\texttt{MAPSTO} schauen k\"onnen.  Wenn sp\"ater ein solches Token noch kommt, dann w\"urde der Parser im
Zustand 6 versuchen, eine \texttt{identifierList} zu parsen und das Komma sollte auf den Stack
geschoben werden.  Andernfalls k\"onnte mit der Regel 
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{expr} \rightarrow \mathtt{IDENTIFIER}$
\\[0.2cm]
reduziert werden. Leider l\"asst ein LR-Parser-Generator nicht zu, dass wir den noch ungelesenen Teil
der Eingabe inspizieren.  Wir m\"ussen daher eine andere L\"osung suchen.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    lalr_state [6]: {
      [identifierList ::= IDENTIFIER (*) COMMA identifierList , {RBRACKET }]
      [expr ::= IDENTIFIER (*) , {RBRACKET COMMA }]
      [identifierList ::= IDENTIFIER (*) , {RBRACKET }]
    }
\end{Verbatim}
 \vspace*{-0.3cm}
\caption{Der Zustand mit der Nummer 6 zu der Grammatik aus Abbildung \ref{fig:lambda.g}}
\label{fig:lambda.g:state6}
\end{figure}

Wir k\"onnen den Shift/Reduce-Konflikt l\"osen, indem wir die Grammatik wie in der in Abbildung
\ref{fig:lambda-generalized.cup} gezeigten Grammatik
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Cup/LambdaExpr/lambda-generalized.cup}{\texttt{lambda-generalized.cup}}
 \textbf{verallgemeinern}.  Diese Grammatik l\"asst auch
Ausdr\"ucke zu, bei denen in der Argument-Liste nicht nur Variablen-Namen enth\"alt, sondern Ausdr\"ucke
beliebiger Komplexit\"at.  Damit beschreibt diese Grammatik eine Sprache, die eigentlich zu allgemein
ist.  Es ist aber ein leichtes, sp\"ater den resultierenden Syntax-Baum drauf hin zu untersuchen, ob
in der Parameter-Liste tats\"achlich nur Variablen stehen oder nicht.  Daher bietet eine solche
Verallgemeinerung der Grammatik eine praktische M\"oglichkeit um Shift/Reduce-Konflikte zu l\"osen.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm, 
                  xrightmargin  = 0.8cm,
                ]
    terminal    MAPSTO, LBRACKET, RBRACKET, COMMA, IDENTIFIER;
    
    nonterminal expr, exprList, lambdaDefinition;
    
    expr ::= lambdaDefinition
          |  IDENTIFIER  
          |  LBRACKET exprList RBRACKET
          ;
    
    lambdaDefinition
         ::= LBRACKET exprList RBRACKET MAPSTO expr
          ;
    
    exprList
         ::= expr COMMA exprList
          |  expr
          ;
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Die verallgemeinerte Grammatik f\"ur $\lambda$-Ausdr\"ucke.}
\label{fig:lambda-generalized.cup}
\end{figure}
\vspace*{\fill}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "formal-languages"
%%% End: 
