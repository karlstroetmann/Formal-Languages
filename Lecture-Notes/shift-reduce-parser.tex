\chapter{Bottom-up Parsers\label{chapter:bottom-up}}

\begin{figure}[h] 
\centering
  \includegraphics[width=10.5cm]{Abbildungen/bottom-up-parser.png}
\caption{An artists rendition of a Bottom-Up Parser.}
\label{fig:bottom-up-parser.png}
\end{figure}

In constructing a parser, there are generally two approaches: \blue{top-down} and \blue{bottom-up}. We have already discussed the top-down approach. In this chapter, we will explain the bottom-up approach.
\begin{enumerate}[(a)]
\item In the next section, we present the general concept underlying a
      \blue{bottom-up parser}.
\item In the following section, we show how bottom-up parsers can be implemented and introduce
      \blue{shift-reduce parsers} as one possible implementation. 

      A \emph{shift-reduce parser} operates with a table that specifies how the parser should process inputs in
      a given state. 
\item We then develop the theory of how such a table can be meaningfully filled with information in the
      following section: First, we discuss the \blue{SLR parsers} (simple LR parsers), which are the simplest
      class of shift-reduce parsers. 
\item Unfortunately, the concept of SLR parsers is not powerful enough for practical use. Therefore, we refine
      this concept to obtain the class of \blue{canonical LR parsers}.
\item As the tables for LR parsers often become large, we simplify these tables slightly and
      then obtain the concept of LALR parsers, which in terms of power lies between the concept of
      SLR parsers and that of LR parsers.
\end{enumerate}
In the following chapter, we will discuss the parser generator \simtextsc{Ply}, which is an LALR parser.


\section{Bottom-Up-Parser}
The parsers that we have implemented in the Chapter 6 without the help of any tool are known as
\textcolor{blue}{top-down parsers}: starting 
from the start symbol of the grammar, they attempt to parse a given input by applying various grammar rules.
In contrast, the parsers generated by \simtextsc{Ply} are \textcolor{blue}{bottom-up parsers}. In such parsers, the
idea is to start with the string to be parsed and group terminals based on the right-hand sides of the grammar
rules.  

As an example, consider parsing the string ``\texttt{1 + 2 * 3}'' using the grammar defined by the following rules:
\\[0.2cm]
\hspace*{1.3cm}
$ 
\begin{array}[t]{rcl}
  e & \rightarrow & e \quoted{+} p \;|\; p  \\[0.1cm]
  p & \rightarrow & p \quoted{*} f \;|\; f  \\[0.1cm]
  f & \rightarrow & \squoted{1} \;|\; \squoted{2} \;|\; \squoted{3} 
\end{array}
$
\\[0.2cm]
To parse this string, we look for substrings that correspond to the right-hand sides of grammar rules, scanning the string from left to right. This way, we try to construct a parse tree in reverse from bottom to top:
\\[0.2cm]
\hspace*{0.3cm} 
$
\begin{array}[t]{lcll}
\texttt{1 + 2 * 3} & \Leftarrow & f \texttt{ + 2 * 3} 
                                & (\mbox{rule:\ }  f \rightarrow  \squoted{1}) \\
                   & \Leftarrow & p \texttt{ + 2 * 3} 
                                & (\mbox{rule:\ } p \rightarrow f) \\
                   & \Leftarrow & e \texttt{ + 2 * 3} 
                                & (\mbox{rule:\ }  e \rightarrow  p) \\
                   & \Leftarrow & e \texttt{ + } f \texttt{ * 3} 
                                & (\mbox{rule:\ } f \rightarrow  \squoted{2}) \\
                   & \Leftarrow & e \texttt{ + } p \texttt{ * 3} 
                                & (\mbox{rule:\ } p \rightarrow f) \\
                   & \Leftarrow & e \texttt{ + } p \texttt{ * } f 
                                & (\mbox{rule:\ } f \rightarrow \squoted{3}) \\
                   & \Leftarrow & e \texttt{ + } p & (\mbox{rule:\ } p \rightarrow p \quoted{*} f) \\
                   & \Leftarrow & e                & (\mbox{rule:\ } e \rightarrow e \quoted{+} P) 
\end{array}
$
\\[0.2cm]
In the first step, we used the grammar rule \(f \rightarrow \squoted{1}\) to replace the string ``\texttt{1}''
with \(f\), thus obtaining the string ``f\texttt{ + 2 * 3}''. In the second step, we used the rule \(p
\rightarrow f\) to replace \(f\) with \(p\). In this manner, we ultimately traced the original string
``\texttt{1 + 2 * 3}'' back to \(e\). At this point, we can make two observations: 
\begin{enumerate}[(a)]
\item In our approach, we always replace the leftmost substring that can be replaced when we want to trace the
      initially given string back to the start symbol of the grammar. 
\item If we write down the derivation that we have constructed backwards, we obtain:
\\[0.2cm]
\hspace*{1.3cm}
$
\begin{array}[t]{lcl}
e  & \Rightarrow & e \texttt{ + } p \\
   & \Rightarrow & e \texttt{ + } p \texttt{ * } f \\
   & \Rightarrow & e \texttt{ + } p \texttt{ * 3} \\
   & \Rightarrow & e \texttt{ + } f \texttt{ * 3} \\
   & \Rightarrow & e \texttt{ + 2 * 3} \\
   & \Rightarrow & p \texttt{ + 2 * 3} \\
   & \Rightarrow & f \texttt{ + 2 * 3} \\
   & \Rightarrow & \texttt{1 + 2 * 3}
\end{array}
$
   \\[0.2cm]
   We see here that in this derivation, the rightmost syntactic variable is always the one being replaced. Such
   a derivation is referred to as a \textcolor{blue}{rightmost derivation}\index{rightmost derivation}. 

   In contrast, the derivations produced by a \textcolor{blue}{top-down parser} are exactly the opposite:
   there, the leftmost syntactic variable is always replaced. Therefore, the derivations created with such a
   parser are called \textcolor{blue}{leftmost derivations}\index{leftmost derivation}. 
\end{enumerate}
The above two observations are the reason why the parsers discussed in this chapter are referred to as
\textcolor{blue}{LR Parsers}. The \textcolor{blue}{L} stands for \textcolor{blue}{\underline{l}eft to right}
and describes the approach of always scanning the string from left to right, while the \textcolor{blue}{R}
stands for \textcolor{blue}{\underline{r}everse rightmost derivation} and indicates that such parsers construct
a rightmost derivation in reverse. 
\vspace*{0.2cm}

\noindent
In the implementation of an LR parser, two questions arise:
\begin{enumerate}
\item Which substring do we replace?
\item Which grammar rules should we use in the process?
\end{enumerate}
Answering these questions is generally non-trivial. Although we always scan the strings from left to right, it is not immediately clear which substring we should replace, as the potentially replaceable substrings can overlap. Consider, for example, the intermediate result
\\[0.2cm]
\hspace*{1.3cm}
\(e \texttt{ + } p \texttt{ * 3}\),
\\[0.2cm]
that we obtained in the fifth step above.
Here, we could replace the substring ``p'' using the rule
\\[0.2cm]
\hspace*{1.3cm}
\(e \rightarrow p\)
\\[0.2cm]
with ``e''. Then, we would obtain the string
\\[0.2cm]
\hspace*{1.3cm}
\(e \texttt{ + } e \texttt{ * 3}\).
\\[0.2cm]
The only reductions we can now perform, via the intermediate results \(e \texttt{ + } e \texttt{ * } f\) and
\(e \texttt{ + } e \texttt{ * } p\), lead to the string 
\\[0.2cm]
\hspace*{1.3cm}
\(e \texttt{ + } e \texttt{ * } e\),
\\[0.2cm]
which then cannot be reduced any further with the grammar given above. The answers to the above questions,
which substring we replace and which rule we use, require a fair amount of theory, which we will develop in the
following sections. 

\section{Shift-Reduce-Parser}
\blue{Shift-reduce parsing} is one way to implement bottom up parsing.
Assume a grammar $G = \langle V, T, R, s \rangle$ is given.  A  \blue{shift-reduce parser}\index{shift-reduce parser}
is defined as a 4-Tuple
\\[0.2cm]
\hspace*{1.3cm}
$P = \langle Q, q_0, \textsl{action}, \textsl{goto} \rangle$
\\[0.2cm]
where
\begin{enumerate}
\item $Q$ is the set of \blue{states} of the shift-reduce parser.  

      At first, states are purely abstract. 
\item $q_0 \in Q$ is the start state.
\item $\textsl{action}$ is a function taking two arguments. The first argument is a state $q \in Q$
      and the second argument is a terminal $t \in T$.  The result of this function is an element from the set
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{Action} :=
       \bigl\{ \pair(\texttt{shift}, q)  \mid q \in Q \bigr\}               \cup 
       \bigl\{ \pair(\texttt{reduce}, r) \mid r \in R \bigr\} \cup 
       \bigl\{ \texttt{accept} \bigr\}                        \cup
       \bigl\{ \texttt{error}  \bigr\}                         $.
      \\[0.2cm]
      Here \texttt{shift}, \texttt{reduce}, \texttt{accept}, and \texttt{error} are strings that serve to
      distinguish the different kinds of result of the function 
      $\textsl{action}$.  Then the signature of the function \textsl{action} is
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{action}: Q \times T \rightarrow \textsl{Action}$.
\item \textsl{goto} is a function that takes a state $q \in Q$ and a syntactical variable
      $v \in V$ and computes a new state.  The signature of \textsl{goto} is 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{goto}: Q \times V \rightarrow Q$.
\end{enumerate}
To describe the algorithm implemented in a shift-reduce parser, we first describe the data structures that are
used by this algorithm:
\begin{enumerate}[(a)]
\item \textsl{States} is a stack of states from the set $Q$:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{States} \in \textsl{Stack}[Q]$.
\item \textsl{Symbols} is a stack of grammar symbols, i.e.~this stack contains both terminals and syntactical
      variables:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{Symbols} \in \textsl{Stack}[T \cup V]$.
\end{enumerate}
In order to simplify the exposition of shift-reduce parsing we assume that the set $T$ of terminals contains
the special symbol ``\simtextsc{Eof}'' (short for \underline{\blue{e}}nd \underline{\blue{o}}f \underline{\blue{f}}ile).
This symbol is assumed to occur at the end of the input string but does not occur elsewhere.

In order to understand how a shift-reduce parser works we introduce the notion of a
\blue{parser configuration}\index{parser configuration}.  A parser configuration is a triple of the form
\\[0.2cm]
\hspace*{1.3cm}
$\langle \textsl{States}, \textsl{Symbols}, \textsl{Tokens} \rangle$
\\[0.2cm]
where \textsl{States} and \textsl{Symbols} are the aforementioned stacks of states and grammar symbols, while
\textsl{Tokens} is the rest of the 
tokens from the input string that have not been processed.  The stack \textsl{States} starts with the
start state $q_0$, i.e.~initially we have
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{States} = [q_0]$.
\\[0.2cm]
The length of $\textsl{States}$ is always the length of the stack $\textsl{Symbols}$ plus one:
\\[0.2cm]
\hspace*{1.3cm}
$\texttt{length}(\textsl{States}) = \texttt{length}(\textsl{Symbols}) + 1$.
\\[0.2cm]
If the input string that is to be parsed has the form
\\[0.2cm]
\hspace*{1.3cm}
$[t_1, \cdots,t_n]$
\\[0.2cm]
and we have already processed the first part $[t_1, \cdots,t_k]$ of the input string to produce the symbols 
\\[0.2cm]
\hspace*{1.3cm}
$[X_1,\cdots, X_m]$,
\\[0.2cm]
while $[t_{k+1},\cdots,t_n]$ is the part of the input string that still needs to be processed, then we know
that by construction of our parser we have
\\[0.2cm]
\hspace*{1.3cm}
$X_1\cdots X_m \Rightarrow^* t_1\cdots t_k$
\\[0.2cm]
and, furthermore, the parts of the parser configuration have the form
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{States} = [q_0,q_1\cdots, q_m]$, \quad $\textsl{Symbols} = [X_1,\cdots, X_m]$,
\quad and \quad $\textsl{Tokens} = [t_{k+1}, \cdots, t_n, \simtextsc{EOF}]$,
\\[0.2cm]
and the parser configuration $\langle \textsl{States}, \textsl{Symbols}, \textsl{Tokens} \rangle$ is written as
\\[0.2cm]
\hspace*{1.3cm}
$q_0, q_1, \cdots, q_m \mid X_1, \cdots, X_m \mid t_{k+1}, \cdots, t_n,\, \simtextsc{EOF}$.
\\[0.2cm]
Shift-reduce parsing starts out with the configuration
\\[0.2cm]
\hspace*{1.3cm}
$q_0 \mid \;  \mid t_{1}, \cdots, t_n,\, \simtextsc{Eof}$.
\\[0.2cm]
Therefore, initially the stack \textsl{States} contains only the start symbol, the stack \textsl{Symbols} is
empty, and the list \texttt{Tokens} consists of the sequence of tokens that need to be parsed.
Then, parsing proceeds iteratively.  If the current configuration is
\\[0.2cm]
\hspace*{1.3cm}
$q_0, q_1, \cdots, q_m \mid X_1, \cdots, X_m \mid t_{k+1}, \cdots, t_n, \,\simtextsc{Eof}$,
\\[0.2cm]
then there is a case distinction according to the value of $\textsl{action}(q_m, t_{k+1})$.
\begin{enumerate}[(a)]
\item If $\textsl{action}(q_m, t_{k+1}) = \textsl{error}$, then we know that the given string $t_1\cdots,t_n$
      is not generated by the given grammar and parsing is aborted with an error message.
\item If $\textsl{action}(q_m, t_{k+1}) = \textsl{accept}$, then we must have $k=n$ and hence $t_{k+1} = t_{n+1} = \simtextsc{Eof}$
      and we also must have $X_1, \cdots, X_m = S$.  In this case, we have reduced the string $t_1\cdots t_n$
      to the start symbol $S$ of the given grammar and parsing finishes with success.
\item If $\textsl{action}(q_m, t_{k+1}) = \langle\textsl{shift}, q \rangle$, then the current configuration
      is changed into the new configuration
      \\[0.2cm]
      \hspace*{1.3cm}
      $q_0, q_1, \cdots, q_m, q \mid X_1, \cdots, X_m, t_{k+1} \mid t_{k+2}, \cdots, t_n, \,\simtextsc{Eof}$,
      \\[0.2cm]
      i.e.~the next token $t_{k+1}$ is moved from the unread input to the top of the symbol stack
      and the new state $q$ is pushed onto the stack \textsl{States}.
\item If $\textsl{action}(q_m, t_{k+1}) = \langle\textsl{reduce}, r \rangle$, where $r$ is a grammar rule,
      then the grammar rule $r$ must have the form
      \\[0.2cm]
      \hspace*{1.3cm}
      $a \rightarrow X_{m-l} \cdots X_{m}$,
      \\[0.2cm]
      i.e.~the right hand side of the grammar rule matches the end of the stack \textsl{Symbols}.
      In this case, the symbols stack is reduced with this grammar rule, i.e.~the symbols
      $X_{m-l}, \cdots, X_m$ are replaced by $a$.  Furthermore, in the stack \textsl{States} the states
      $q_{m-l} \cdots q_m$ are replaced by the state $\textsl{goto}(q_{m-l-1}, a)$.
      Therefore, the configuration changes as follows:
      \\[0.2cm]
      \hspace*{1.3cm}
      $q_0, q_1, \cdots, q_{m-l-1}, \textsl{goto}(q_{m-l-1}, a) \mid X_1, \cdots, X_{m-l-1}, a \mid t_{k+1}, \cdots, t_n, \,\simtextsc{Eof}$.
\end{enumerate}





\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                framesep      = 0.3cm, 
                firstnumber   = 1,
                bgcolor       = sepia,
                numbers       = left,
                numbersep     = -0.2cm,
                xleftmargin   = 0.8cm,
                xrightmargin  = 0.8cm,
              ]{python3}
    class ShiftReduceParser():
        def __init__(self, actionTable, gotoTable):
            self.mActionTable = actionTable
            self.mGotoTable   = gotoTable
\end{minted}
\vspace*{-0.3cm}
\caption{Implementation of a shift-reduce parser in \textsl{Python}}
\label{fig:Shift-Reduce-Parser-Pure.ipynb}
\end{figure}

\noindent
Figure \ref{fig:Shift-Reduce-Parser-Pure.ipynb} on page \pageref{fig:Shift-Reduce-Parser-Pure.ipynb} shows the class 
\texttt{ShiftReduceParser}, which
maintains two dictionaries.
\begin{enumerate}[(a)]
\item \texttt{mActionTable} stores the function $\textsl{action}: Q \times T \rightarrow \textsl{Action}$.
\item \texttt{mGotoTable} stores the function $\textsl{goto}: Q \times V \rightarrow Q$.
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{minted}[ frame         = lines, 
                framesep      = 0.3cm, 
                firstnumber   = 1,
                bgcolor       = sepia,
                numbers       = left,
                numbersep     = -0.2cm,
                xleftmargin   = 0.5cm,
                xrightmargin  = 0.5cm,
              ]{python3}      
    def parse(self, TL):
        index   = 0        # points to next token
        Symbols = []       # stack of symbols
        States  = ['s0']   # stack of states, s0 is start state
        TL     += ['EOF']  # token list
        while True:
            q = States[-1]
            t = TL[index]
            # undefined table entries are interpreted as 'error'
            match self.mActionTable.get((q, t), 'error'):
                case 'error': 
                    return False
                case 'accept':
                    return True
                case 'shift', s: 
                    Symbols += [t]
                    States  += [s]
                    index   += 1
                case 'reduce', rule:
                    head, body = rule
                    n       = len(body)
                    Symbols = Symbols[:-n]
                    States  = States [:-n] 
                    Symbols = Symbols + [head]
                    state   = States[-1]
                    States += [ self.mGotoTable[state, head] ]
\end{minted}
\vspace*{-0.3cm}
\caption{Implementation of a shift-reduce parser in \textsl{Python}}
\label{fig:Shift-Reduce-Parser-Pure.ipynb:parse}
\end{figure}

Figure \ref{fig:Shift-Reduce-Parser-Pure.ipynb:parse} on page \pageref{fig:Shift-Reduce-Parser-Pure.ipynb:parse}
shows the implementation of the method \texttt{parse}
that implements \blue{shift-reduce parsing}.  
This method assumes that the function \textsl{action} is coded
as a dictionary that is stored in the member variable \texttt{mActionTable}.
The function \textsl{goto} is also represented as a dictionary.  It is stored in the
member variable \texttt{mGotoTable}.  The method \texttt{parse} is called with one
argument \textsl{TL}.  This is the list of tokens that have to be parsed.  We append the special token
``\simtextsc{Eof}'' at the end of this list.  The invocation  
$\texttt{parse}(\textsl{TL})$ returns \texttt{True} if the token list \textsl{TL} can be
parsed successfully and \texttt{False} otherwise.  The implementation of \texttt{parse} works as follows:
\begin{enumerate}
\item The variable \textsl{index} points to the next token in the token list that is to be
      read.  Therefore, this variable is initialized to 0.
\item The variable \textsl{Symbols} stores the stack of symbols.  The top of this stack is
      at the end of this list.  Initially, the stack of symbols is empty.
\item The variable \textsl{States} is the stack of states.  The start state is assumed to
      be the state ``\texttt{s0}''.  Therefore this stack is initialized to contain
      only this state.
\item The main loop of the parser 
      \begin{itemize}
      \item sets the variable $q$ to the current state,
      \item initializes $t$ to the next token, and then
      \item looks up the appropriate action in the action table.
      \end{itemize}
      What happens next depends on this value of $\textsl{action}(q, t)$.
      \begin{enumerate}
      \item $\textsl{action}(q,t) = \textsl{error}$.

            In this case the parser has found a syntax error and returns \texttt{False}.
      \item $\textsl{action}(q,t) = \texttt{accept}$.

            In this case parsing is successful and therefore the function returns \texttt{True}.
      \item $\textsl{action}(q,t) = \pair(\texttt{shift}, s)$.
        
            In this case, the token $t$ is pushed onto the symbol stack in line 16,
            while the state $s$ is pushed onto the stack of states.  Furthermore,
            the variable \textsl{index} is incremented to point to the next unread token.            
      \item $\textsl{action}(q,t) = \pair(\texttt{reduce}, A \rightarrow X_1 \cdots X_n)$.

            In this case, we use the grammar rule
            \\[0.2cm]
            \hspace*{1.3cm}
            $r = (A \rightarrow X_1 \cdots X_n)$
            \\[0.2cm]
            to reduce the symbol stack.  The  variable \textsl{head} represents the left
            hand side $A$ of this rule, while the list $[X_1, \cdots,X_n]$ is represented
            by the variable \textsl{body}.

            In this case, it can be shown that the symbols $X_1$, $\cdots$, $X_n$ are on top of the
            symbol stack.  As we are going to reduce the symbol stack with the rule $r$,
            we remove these $n$ symbols from the symbol stack and replace them with the
            variable $A$.
            
            Furthermore, we have to remove $n$ states from the stack of states.
            After that, we set the variable \textsl{state} to the state that is on top of the
            stack of states after we have removed $n$ states.  Next, the new state
            $\textsl{goto}(\textsl{state}, A)$ is put on top of the stack of states in line 26.
      \end{enumerate}
\end{enumerate}
In order to make the method \texttt{parse} work we have to provide an implementation
of the functions $\textsl{action}$ and $\textsl{goto}$.
The tables  \ref{tab:action} and \ref{tab:goto} show these functions for the grammar given
in Figure \ref{fig:Expr.grammar}.  For this grammar, there are 16 different states, which have
been baptized as $s_0$, $s_1$, $\cdots$, $s_{15}$.  The tables use two different abbreviations:
\begin{enumerate}
\item \shft{i} is short for $\pair(\texttt{shift}, s_i)$.
\item \rdc{i} is short for  $\pair(\texttt{reduce}, r_i)$, where $r_i$ denothes the
      grammar rule number $i$.  Here, we have numbered the rules as follows:
      \begin{enumerate}
      \item $r_1 = (\textsl{expr} \rightarrow \textsl{expr} \quoted{+} \textsl{product})$
      \item $r_2 = (\textsl{expr} \rightarrow \textsl{expr} \quoted{-} \textsl{product})$
      \item $r_3 = (\textsl{expr} \rightarrow \textsl{product})$
      \item $r_4 = (\textsl{product} \rightarrow \textsl{product} \quoted{*} \textsl{factor})$
      \item $r_5 = (\textsl{product} \rightarrow \textsl{product} \quoted{/} \textsl{factor})$
      \item $r_6 = (\textsl{product} \rightarrow \textsl{factor})$
      \item $r_7 = (\textsl{factor} \rightarrow  \quoted{(} \textsl{expr} \quoted{)})$
      \item $r_8 = (\textsl{factor} \rightarrow  \simtextsc{Number})$
      \end{enumerate}
\end{enumerate}
The corresponding grammar is shown in Figure \ref{fig:Expr.grammar}.  The definition of the grammar rules
and the coding of the
functions \textsl{action} and \textsl{goto} is shown in the Figures
\ref{fig:parse-table.stlx:grammar}, \ref{fig:parse-table.stlx:action}, and
\ref{fig:parse-table.stlx:goto} on the following pages.   Of course, at present we do not have any
idea how the functions \textsl{action} and \textsl{goto} are computed.  This requires some theory
that will be presented in the next section.


\begin{figure}[htbp]
  \begin{center}    
  \framebox{
  \framebox{
  \begin{minipage}[t]{8cm}
  \begin{eqnarray*}
  \textsl{expr}    & \rightarrow & \;\textsl{expr} \quoted{+} \textsl{product}  \\
                   & \mid        & \;\textsl{expr} \quoted{-} \textsl{product}  \\
                   & \mid        & \;\textsl{product}                           \\[0.2cm]
  \textsl{product} & \rightarrow & \;\textsl{product} \quoted{*} \textsl{factor}\\
                   & \mid        & \;\textsl{product} \quoted{/} \textsl{factor}\\
                   & \mid        & \;\textsl{factor}                            \\[0.2cm]
  \textsl{factor}  & \rightarrow &   \quoted{(} \textsl{expr} \quoted{)}        \\
                   & \mid        & \;\simtextsc{Number} 
  \end{eqnarray*}
  \vspace*{-0.5cm}

  \end{minipage}}}
  \end{center}
  \caption{A grammar for arithmetical expressions.}
  \label{fig:Expr.grammar}
\end{figure}

\begin{table}[!ht]
  \centering
\framebox{
\begin{tabular}{|r|l|l|l|l|l|l|l|l|}
\hline
 State & \simtextsc{Eof} & \texttt{+} & \texttt{-} & \texttt{*} & \texttt{/} & \texttt{(} & \texttt{)} & \simtextsc{Number} \\
\hline
\hline
$s_{0}$ &              &            &            &            &            & \shft{5}   &            & \shft{2} \\
\hline
$s_{1}$ & \rdc{6}      & \rdc{6}    & \rdc{6}    & \rdc{6}    & \rdc{6}    &            & \rdc{6}    &          \\
\hline
$s_{2}$ & \rdc{8}      & \rdc{8}    & \rdc{8}    & \rdc{8}    & \rdc{8}    &            & \rdc{8}    &          \\
\hline
$s_{3}$ & \rdc{3}      & \rdc{3}    & \rdc{3}    & \shft{12}  & \shft{11}  &            & \rdc{3}    &          \\
\hline
$s_{4}$ & \accept      & \shft{8}   & \shft{9}   &            &            &            &            &          \\
\hline
$s_{5}$ &              &            &            &            &            & \shft{5}   &            & \shft{2} \\
\hline
$s_{6}$ &              & \shft{8}   & \shft{9}   &            &            &            & \shft{7}   &          \\
\hline
$s_{7}$ & \rdc{7}      & \rdc{7}    & \rdc{7}    & \rdc{7}    & \rdc{7}    &            & \rdc{7}    &          \\
\hline
$s_{8}$ &              &            &            &            &            & \shft{5}   &            & \shft{2} \\
\hline
$s_{9}$ &              &            &            &            &            & \shft{5}   &            & \shft{2} \\
\hline
$s_{10}$ & \rdc{2}     & \rdc{2}    & \rdc{2}    & \shft{12}  & \shft{11}  &            & \rdc{2}    &          \\
\hline
$s_{11}$ &             &            &            &            &            & \shft{5}   &            & \shft{2} \\
\hline
$s_{12}$ &             &            &            &            &            & \shft{5}   &            & \shft{2} \\
\hline
$s_{13}$ & \rdc{4}     & \rdc{4}    & \rdc{4}    & \rdc{4}    & \rdc{4}    &            & \rdc{4}    &          \\
\hline
$s_{14}$ & \rdc{5}     & \rdc{5}    & \rdc{5}    & \rdc{5}    & \rdc{5}    &            & \rdc{5}    &          \\
\hline
$s_{15}$ & \rdc{1}     & \rdc{1}    & \rdc{1}    & \shft{12}  & \shft{11}  &            & \rdc{1}    &          \\
\hline
  \end{tabular}}
  \caption{The function $\textsl{action}()$.}
  \label{tab:action}
\end{table}

\begin{table}[!ht]
  \centering
\framebox{
\begin{tabular}{|r|r|r|r|}
\hline
State   & \textsl{expr} & \textsl{product} & \textsl{factor} \\
\hline
\hline
$s_{0}$ & $s_{4}$       & $s_{3}$          & $s_{1}$         \\
\hline
$s_{1}$ &               &                  &                 \\
\hline
$s_{2}$ &               &                  &                 \\
\hline
$s_{3}$ &               &                  &                 \\
\hline
$s_{4}$ &               &                  &                 \\
\hline
$s_{5}$ & $s_{6}$       & $s_{3}$          & $s_{1}$         \\
\hline
$s_{6}$ &               &                  &                 \\
\hline
$s_{7}$ &               &                  &                 \\
\hline
$s_{8}$ &               & $s_{15}$         & $s_{1}$         \\
\hline
$s_{9}$ &               & $s_{10}$         & $s_{1}$         \\
\hline
$s_{10}$ &              &                  &                 \\
\hline
$s_{11}$ &              &                  & $s_{14}$        \\
\hline
$s_{12}$ &              &                  & $s_{13}$        \\
\hline
$s_{13}$ &              &                  &                 \\
\hline
$s_{14}$ &              &                  &                 \\
\hline
$s_{15}$ &              &                  &                 \\
\hline
  \end{tabular}}
  \caption{The function $\textsl{goto}()$.}
  \label{tab:goto}
\end{table}


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    r1 = ('e', ('e', '+', 'p'))
    r2 = ('e', ('e', '-', 'p'))
    r3 = ('e', ('p'))
    
    r4 = ('p', ('p', '*', 'f'))
    r5 = ('p', ('p', '/', 'f'))
    r6 = ('p', ('f'))
    
    r7 = ('f', ('(', 'e', ')'))
    r8 = ('f', ('NUMBER',))               
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Grammar rules coded in \textsl{Python}.}
\label{fig:parse-table.stlx:grammar}
\end{figure}


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    gotoTable   := {};

    gotoTable["s0", "e"] := "s4";
    gotoTable["s0", "p"] := "s3";
    gotoTable["s0", "f"] := "s1";
    
    gotoTable["s5", "e"] := "s6";
    gotoTable["s5", "p"] := "s3";
    gotoTable["s5", "f"] := "s1";
    
    gotoTable["s8", "p"] := "s15";
    gotoTable["s8", "f"] := "s1";
    
    gotoTable["s9", "p"] := "s10";
    gotoTable["s9", "f"] := "s1";
    
    gotoTable["s11", "f"] := "s14";
    gotoTable["s12", "f"] := "s13";
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Goto table coded in \simtextsc{Python}.}
\label{fig:parse-table.stlx:goto}
\end{figure}


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = none,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
actionTable = {}

actionTable[s0, '('] = (shft, s5)  actionTable[s8, '('] = (shft, s5)   
actionTable[s0, NBR] = (shft, s2)  actionTable[s8, NBR] = (shft, s2)   
 
actionTable[s1, EOF] = (rdc, r6)   actionTable[s9, '('] = (shft, s5)   
actionTable[s1, '+'] = (rdc, r6)   actionTable[s9, NBR] = (shft, s2)   
actionTable[s1, '-'] = (rdc, r6) 
actionTable[s1, '*'] = (rdc, r6)   actionTable[s0, EOF] = (rdc, r2)   
actionTable[s1, '/'] = (rdc, r6)   actionTable[s0, '+'] = (rdc, r2)    
actionTable[s1, ')'] = (rdc, r6)   actionTable[s0, '-'] = (rdc, r2)    
                                   actionTable[s0, '*'] = (shft, s2)
actionTable[s2, EOF] = (rdc, r8)   actionTable[s10, '/'] = (shft, s11) 
actionTable[s2, '+'] = (rdc, r8)   actionTable[s10, ')'] = (rdc, r2)    
actionTable[s2, '-'] = (rdc, r8) 
actionTable[s2, '*'] = (rdc, r8)   actionTable[s11, '('] = (shft, s5)  
actionTable[s2, '/'] = (rdc, r8)   actionTable[s11, NBR] = (shft, s2)  
actionTable[s2, ')'] = (rdc, r8) 
                                   actionTable[s12, '('] = (shft, s5)  
actionTable[s3, EOF] = (rdc, r3)   actionTable[s12, NBR] = (shft, s2)  
actionTable[s3, '+'] = (rdc, r3) 
actionTable[s3, '-'] = (rdc, r3)   actionTable[s13, EOF] = (rdc, r4)   
actionTable[s3, '*'] = (shft, s12) actionTable[s13, '+'] = (rdc, r4)   
actionTable[s3, '/'] = (shft, s11) actionTable[s13, '-'] = (rdc, r4)   
actionTable[s3, ')'] = (rdc, r3)   actionTable[s13, '*'] = (rdc, r4)   
                                   actionTable[s13, '/'] = (rdc, r4)   
actionTable[s4, EOF] = 'accept'    actionTable[s13, ')'] = (rdc, r4)   
actionTable[s4, '+'] = (shft, s8) 
actionTable[s4, '-'] = (shft, s9)  actionTable[s14, EOF] = (rdc, r5)   
                                   actionTable[s14, '+'] = (rdc, r5)   
actionTable[s5, '('] = (shft, s5)  actionTable[s14, '-'] = (rdc, r5)   
actionTable[s5, NBR] = (shft, s2)  actionTable[s14, '*'] = (rdc, r5)   
                                   actionTable[s14, '/'] = (rdc, r5)   
actionTable[s6, '+'] = (shft, s8)  actionTable[s14, ')'] = (rdc, r5)   
actionTable[s6, '-'] = (shft, s9) 
actionTable[s6, ')'] = (shft, s7)  actionTable[s15, EOF] = (rdc, r1)   
                                   actionTable[s15, '+'] = (rdc, r1)   
actionTable[s7, EOF] = (rdc, r7)   actionTable[s15, '-'] = (rdc, r1)   
actionTable[s7, '+'] = (rdc, r7)   actionTable[s15, '*'] = (shft, s12) 
actionTable[s7, '-'] = (rdc, r7)   actionTable[s15, '/'] = (shft, s11) 
actionTable[s7, '*'] = (rdc, r7)   actionTable[s15, ')'] = (rdc, r1)   
actionTable[s7, '/'] = (rdc, r7)
actionTable[s7, ')'] = (rdc, r7)
\end{Verbatim}
\vspace*{-0.3cm}
\caption{The action table for our shift/reduce parser.}
\label{fig:parse-table.stlx:action}
\end{figure}

 
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "formal-languages"
%%% End: 
