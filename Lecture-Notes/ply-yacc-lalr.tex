\chapter{Advanced Features of \textsc{Ply}}
When we discussed the parser generator \simtextsc{Ply} in chapter 7, we were not able to discuss all the features of
\simtextsc{Ply}, since the underlying theory, which is the theory of \simtextsc{Lalr} parsing,  had not been developed.  Since
we have aquainted ourselves with this theory in the pervious chapter, we are finally able to discuss some of the
more advanced features of \simtextsc{Ply}. 
\begin{enumerate}
\item First, we show how shift-reduce conflicts are presented in \simtextsc{Ply}.
\item Then we discuss how shift-reduce conflicts can be resolved with the help of
      \blue{precedence declarations}.
\end{enumerate}

\section{Shift-Reduce and Reduce-Reduce Conflicts}
In this section we show how shift-reduce and reduce-reduce conflicts are dealt with in \simtextsc{Ply}.
Figure \ref{fig:Conflicts.ipynb} on page \pageref{fig:Conflicts.ipynb} shows a grammar for arithmetical
expressions that is ambiguous because it does not specify the precedence of the different arithmetical
operators.  


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                  commandchars  = \\\{\}
                ]
    expr : expr '+' expr
         | expr '*' expr
         | NUMBER      
\end{Verbatim}
\vspace*{-0.3cm}
\caption{An ambiguous grammar for arithmetical expressions.}
\label{fig:Conflicts.ipynb}
\end{figure}
\FloatBarrier

\noindent
This grammar does not specify whether the string
\\[0.2cm]
\hspace*{1.3cm} 
``\texttt{1 + 2 * 3}'' \quad is interpreted as \quad  ``\texttt{(1 + 2) * 3}'' \quad or as \quad ``\texttt{1 +
  (2 * 3)}''. 
\\[0.2cm]
Since every \simtextsc{Lalr} grammar is unambiguous, but the grammar shown in Figure \ref{fig:Conflicts.ipynb} is
ambiguous,  it has to have at least one shift-reduce or reduce-reduce conflict.  This grammar is part of the
jupyter notebook  
\\[0.2cm]
\hspace*{1.3cm}
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Python/Chapter-10/01-Conflicts.ipynb}{Formal-Languages/tree/master/Python/Chapter-10/01-Conflicts.ipynb}.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                  commandchars  = \\\{\}
                ]
    state 5
    
        (1) expr -> expr + expr .
        (1) expr -> expr . + expr
        (2) expr -> expr . * expr
    
      ! shift/reduce conflict for + resolved as shift
      ! shift/reduce conflict for * resolved as shift
        $end            reduce using rule 1 (expr -> expr + expr .)
        +               shift and go to state 3
        *               shift and go to state 4
    
      ! +               [ reduce using rule 1 (expr -> expr + expr .) ]
      ! *               [ reduce using rule 1 (expr -> expr + expr .) ]
\end{Verbatim} 
\vspace*{-0.3cm}
\caption{An excerpt from the file \texttt{parse.out}.}
\label{fig:Conflicts.ipynb:state10}
\end{figure} %$

When we try to generate a parser for this grammar using \simtextsc{Ply}s \texttt{yacc} command we get the message
\\[0.2cm]
\hspace*{1.3cm}
\texttt{WARNING: 4 shift/reduce conflicts}.
\\[0.2cm]
The file \texttt{parser.out} that is generated by \simtextsc{Ply} shows how these conflicts are resolved.
This file contains the \simtextsc{Lalr} states created by the parser generator and for every state the possible actions are
shown.  Given the grammar shown above, \simtextsc{Ply} creates 6 different states.  There are conflicts in two of
these states.  Figure \ref{fig:Conflicts.ipynb:state10} on page \pageref{fig:Conflicts.ipynb:state10} shows state
number 5 and its actions.   We see that there are 2 shift-reduce conflicts in this state.  Unfortunately,
\simtextsc{Ply} only prints the marked rules defining these states, but it does not show the follow sets of these
rules.  We see that \simtextsc{Ply} resolves all conflicts in favour of shifting.  The exclamation marks in the
beginning of the line 13 and 14 are to be interpreted as negations and show those reduce actions that would have
been possible in state 5, but are discarded in favour of the shift actions shown in line 10 and 11.
Of course, in this example the shift action in line 10 is wrong because then the string
\\[0.2cm]
\hspace*{1.3cm}
\texttt{1 * 2 + 3}
\\[0.2cm]
is interpreted as \texttt{1 * (2 + 3)} and not as \texttt{(1 * 2) + 3}.
\FloatBarrier


\section{Operator Precedence Declarations \label{section:operator-precedence}}
\begin{figure}[!ht]

  \begin{center}    
  \framebox{
  \framebox{
    \begin{minipage}[t]{9cm}    
  \begin{eqnarray*}
  \textsl{expr}    & \rightarrow & \;\textsl{expr} \quoted{+} \textsl{expr}  \\
                   & \mid        & \;\textsl{expr} \quoted{-} \textsl{expr}  \\
                   & \mid        & \;\textsl{expr} \quoted{*} \textsl{expr}  \\
                   & \mid        & \;\textsl{expr} \quoted{/} \textsl{expr}  \\
                   & \mid        & \;\textsl{expr} \quoted{\^} \textsl{expr}  \\
                   & \mid        & \quoted{(} \textsl{expr} \quoted{)}       \\
                   & \mid        & \;\simtextsc{Number}                            
  \end{eqnarray*}
  \vspace*{-0.5cm}
  \end{minipage}}}
  \end{center}
  \caption{A grammar for a arithmetical expressions.}
  \label{fig:grammar-resolved.g}
\end{figure}
It is possible to resolve shift-reduce conflicts using \blue{operator precedence declarations}.
For example, for the grammar for arithmetical expressions shown in Figure \ref{fig:grammar-resolved.g}
on page \pageref{fig:grammar-resolved.g} we can use the following \blue{operator precedence declarations}:
\begin{verbatim}
    precedence = ( ('left', '+', '-'),   # precedence 1
                   ('left', '*', '/'),   # precedence 2
                   ('right', '^')        # precedence 3
                 )
\end{verbatim}
This declaration specifies that the operators ``\texttt{+}'' and ``\texttt{-}'' have a lower precedence than
the operators  ``\texttt{*}'' and ``\texttt{/}''.  Furthermore, it specifies that all these operators associate
to the left.  The operator ``\texttt{\^}'' has the highest precedence and associates to the right as specified
by the keyword ``\texttt{right}''.
The jupyter notebook
\\[0.2cm]
\hspace*{1.3cm}
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Python/Chapter-10/02-Conflicts-Resolved.ipynb}{Formal-Languages/tree/master/Python/Chapter-10/02-Conflicts-Resolved.ipynb}.
\\[0.2cm]
shows this grammar.  When we run this notebook, \simtextsc{Ply} doesn't give us a
warning about any conflicts.  If we inspect the generated file \texttt{parse.out}, the action table for the
state number 11 has the form shown in Figure \ref{fig:Conflicts-Resolved.ipynb:state11} on page
\pageref{fig:Conflicts-Resolved.ipynb:state11}.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                  commandchars  = \\\{\}
                  ]
    state 11
    
        (2) expr -> expr - expr .
        (1) expr -> expr . + expr
        (2) expr -> expr . - expr
        (3) expr -> expr . * expr
        (4) expr -> expr . / expr
        (5) expr -> expr . ^ expr
    
        +               reduce using rule 2 (expr -> expr - expr .)
        -               reduce using rule 2 (expr -> expr - expr .)
        $end            reduce using rule 2 (expr -> expr - expr .)
        )               reduce using rule 2 (expr -> expr - expr .)
        *               shift and go to state 6
        /               shift and go to state 7
        ^               shift and go to state 8
    
      ! *               [ reduce using rule 2 (expr -> expr - expr .) ]
      ! /               [ reduce using rule 2 (expr -> expr - expr .) ]
      ! ^               [ reduce using rule 2 (expr -> expr - expr .) ]
      ! +               [ shift and go to state 4 ]
      ! -               [ shift and go to state 5 ]                  
\end{Verbatim} 
\vspace*{-0.3cm}
\caption{An excerpt from the file \texttt{parse.out} when conflicts are resolved.}
\label{fig:Conflicts-Resolved.ipynb:state11}
\end{figure} %$

\begin{enumerate}
\item Since the operators ``\texttt{+}'' and ``\texttt{-}'' have the same precedence, we have 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{action}(\mathtt{state 11}, \squoted{+}) = 
       \langle \textsl{reduce}, \textsl{expr} \rightarrow \textsl{expr} \quoted{-} \textsl{expr} \rangle
      $
      \\[0.2cm]
      This way, the expression $1 - 2 + 3$ is parsed as $(1 - 2) + 3$ and not as $1 - (2 + 3)$ as it would if
      we would shift the operator ``\texttt{+}'' instead.
\item Since the operator ``\texttt{-}'' is left associative, we have 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{action}(\mathtt{state 11}, \squoted{-}) = 
       \langle \textsl{reduce}, \textsl{expr} \rightarrow \textsl{expr} \quoted{-} \textsl{expr} \rangle
      $
      \\[0.2cm]
      This way, the expression $1 - 2 - 3$ is parsed as $(1 - 2) - 3$.
\item Since the precedence of the operator ``\texttt{*}'' is higher than the precedence of the operator
      ``\texttt{-}'', we have  
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{action}(\mathtt{state 11}, \squoted{*}) = 
       \langle \textsl{shift}, \mathtt{state6} \rangle
      $
      \\[0.2cm]
      This way, the expression $1 - 2 * 3$ is parsed as $1 - (2 * 3)$.
\item Since the precedence of the operator ``\texttt{/}'' is higher than the precedence of the operator
      ``\texttt{-}'', we have  
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{action}(\mathtt{state 11}, \squoted{/}) = 
       \langle \textsl{shift}, \mathtt{state7} \rangle
      $
      \\[0.2cm]
      This way, the expression $1 - 2 / 3$ is parsed as $1 - (2 / 3)$.
\end{enumerate}
\FloatBarrier

\noindent
Next, we explain in detail how \simtextsc{Ply} uses operator precedence relations to resolve shift-reduce conflicts.
\begin{enumerate}
\item First, \simtextsc{Ply} assigns a precedence level to every grammar rule.  This precedence level is the
      precedence level of the last operator symbol occurring in the grammar rule.  Most of the times, there is just
      one operator that determines the precedence of the grammar rule. 
      In the grammar at hand the precedences of the rules would be as shown in the table below. 
      \begin{center}
        \begin{tabular}[t]{|l|c|}
          \hline
          rule                          & precedence  \\
          \hline
          \hline
          $\textsl{expr} \rightarrow \textsl{expr} \quoted{+} \textsl{expr}$ & 1          \\
          \hline
          $\textsl{expr} \rightarrow \textsl{expr} \quoted{-} \textsl{expr}$ & 1          \\
          \hline
          $\textsl{expr} \rightarrow \textsl{expr} \quoted{*} \textsl{expr}$ & 2          \\
          \hline
          $\textsl{expr} \rightarrow \textsl{expr} \quoted{/} \textsl{expr}$ & 2          \\
          \hline
          $\textsl{expr} \rightarrow \textsl{expr} \quoted{\^} \textsl{expr}$ & 3          \\
          \hline
          $\textsl{expr} \rightarrow \quoted{(} \textsl{expr} \quoted{)}$ & --- \\
          \hline
          $\textsl{expr} \rightarrow \simtextsc{Number}$ & --- \\
          \hline
        \end{tabular}
      \end{center}

      If a grammar rule does not contain an operator that has been given a precedence, then the precedence of
      the grammar rule remains undefined.
\item If $s$ is a state that contains two e.m.R.s  $r_1$ and  $r_2$ such that
      \\[0.2cm]
      \hspace*{1.3cm}
      $r_1 = (a \rightarrow \beta \bullet o \;\delta:L_1)$ \quad and \quad
      $r_2 = (c \rightarrow \gamma \bullet : L_2)$ \quad where \quad $o \in L_2$,
      \\[0.2cm]
      then there is a shift-reduce conflict when 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{action}(s, o)$
      \\[0.2cm]
      is computed. Let us assume that the precedence of the operator  $o$ is  $p(o)$
      and the precedence of the rule $r_2$ is  $p(r_2)$.  Then there are six cases that depend
      on the relative values of $p(o)$ and $p(r_2)$ and on the associativity of the operator $o$.
      \begin{enumerate}[(a)]
      \item $p(o) > p(r_2)$.
        
            In this case the precedence of the operator $o$ is higher than the precedence of the rule $r_2$.
            Therefore the operator $o$ is shifted:
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{action}(s,o) = \langle \texttt{shift}, \textsl{goto}(s,o) \rangle$.
            \\[0.2cm]
            To understand this rule we just have to watch what happens when we parse
            \\[0.2cm]
            \hspace*{1.3cm}
            $\texttt{1+2*3}$
            \\[0.2cm]
            using the grammar given above.
            After the part  ``\texttt{1+2}'' has been read and the next token is the operator ``\texttt{*}'',
            the parser is in the following state:
            \\[0.2cm]
            \hspace*{1.3cm}
            $ 
            \begin{array}[t]{llcll}
            \bigl\{ 
            & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{+} \textsl{expr}: \{\symbol{36},
                                            \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^} \}, 
            & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{-} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^}  \},
              & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{*} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^}  \},
              & \\ 
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{/} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^}  \},
              & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{\^} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^}  \},
              & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \squoted{+} \textsl{expr} \;\bullet: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^} 
                                             \} 
            & \bigr\}.
            \end{array}
            $
            \\[0.2cm]
            When the parser next sees the token ``\texttt{*}'', then it must not reduce the symbol stack using
            the rule $\textsl{expr} \rightarrow \textsl{expr} \squoted{+} \textsl{expr}$, because it has to
            multiply the numbers $2$ and $3$ first.  Therefore, the token ``\texttt{*}'' has to be shifted.
      \item $p(o) < p(r_2)$.
            
            Now the precedence of the operator that occurs in the rule $r_2$ is higher than the precedence of
            the operator $o$.  Therefore the correct action is to reduce with the rule  $r_2$: 
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{action}(s,o) = \langle \texttt{reduce}, r_2 \rangle$.
            \\[0.2cm]
            To see that this makes sense we discuss the parsing of the expression
            \\[0.2cm]
            \hspace*{1.3cm}
            $\texttt{1*2+3}$
            \\[0.2cm]
            with the grammar given previously.
            Assume the string  ``\texttt{1*2}'' has already been read and the next token that is processed is
            the token ``\texttt{+}''.
            Then the state of the parser is as follows:
            \\[0.2cm]
            \hspace*{1.3cm}
            $ 
            \begin{array}[t]{llcll}
            \bigl\{ 
            & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{+} \textsl{expr}: \{\symbol{36},
                                            \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^} \}, 
            & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{-} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^}  \},
              & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{*} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^}  \},
              & \\ 
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{/} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^}  \},
              & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{\^} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^}  \},
              & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \squoted{*} \textsl{expr} \;\bullet: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^} 
                                             \}
            & \bigr\}.
            \end{array}
            $
            \\[0.2cm]
            When the parser now sees the operator  ``\texttt{+}'', it has to reduce the string
            ``\texttt{1*2}'' using the rule
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{expr} \rightarrow \textsl{expr} \squoted{*} \textsl{expr}$,
            \\[0.2cm]
            as it has to multiply the numbers $1$ and $2$.  
      \item $p(o) = p(r_2)$ and the operator $o$ is left associative.
            
            Then we reduce the symbol stack with the rule $r_2$, we have 
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{action}(s,o) = \langle \texttt{reduce}, r_2 \rangle$.
            \\[0.2cm]
            To convince yourself that this is the right thing to do, inspect what happens
            when the string
            \\[0.2cm]
            \hspace*{1.3cm}
            $\texttt{1-2-3}$
            \\[0.2cm]
            is parsed with the grammar discussed previously.
            Assume that the string  ``\texttt{1-2}'' has already be read and the next token is the operator
            ``\texttt{-}''. Then the state of the parser is as follows:
            \\[0.2cm]
            \hspace*{1.3cm}
            $ 
            \begin{array}[t]{llcll}
            \bigl\{ 
            & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{+} \textsl{expr}: \{\symbol{36},
                                            \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^} \}, 
            & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{-} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^}  \},
              & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{*} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^}  \},
              & \\ 
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{/} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^}  \},
              & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{\^} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^}  \},
              & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \squoted{-} \textsl{expr} \;\bullet: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^} 
                                             \}
            & \bigr\}.
            \end{array}
            $
            \\[0.2cm]
            If the next token is the operator ``\texttt{-}'', then the parser has to reduce
            the symbol stack using the rule 
            $\textsl{expr} \rightarrow \textsl{expr} \squoted{-} \textsl{expr}$ as it has to subtract $2$ from
            $1$.  If it would shift instead it would compute $1 - (2-3)$ instead of computing $(1-2)-3$.
      \item $p(o) = p(r_2)$ and the operator $o$ associates to the right.
            
            In this case the operator $o$ is shifted
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{action}(s,o) = \langle \texttt{shift}, \textsl{goto}(s,o) \rangle$.
            \\[0.2cm]
            In order to understand this case, parse the string 
            \\[0.2cm]
            \hspace*{1.3cm}
            $\texttt{2\symbol{94}3\symbol{94}4}$
            \\[0.2cm]
            with the grammar rules
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{expr} \rightarrow \textsl{expr} \,\texttt{\symbol{94}}\, \textsl{expr} \mid \simtextsc{Number}$.
            \\[0.2cm]
            Consider the situation when the string ``\texttt{1\symbol{94}2}'' has already been read and the
            next token is the exponentiation operator ``\texttt{\symbol{94}}''.
            The state of the parser is then as follows:
            \\[0.2cm]
            \hspace*{1.3cm}
            $ 
            \begin{array}[t]{llcll}
            \bigl\{ 
            & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{+} \textsl{expr}: \{\symbol{36},
                                            \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^} \}, 
            & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{-} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^}  \},
              & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{*} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^}  \},
              & \\ 
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{/} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^}  \},
              & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{\^} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^}  \},
              & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \squoted{\^} \textsl{expr} \;\bullet: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}, \squoted{\^} 
                                             \}
            & \bigr\}.
            \end{array}
            $
            \\[0.2cm]
            Here the token  \quoted{\texttt{\symbol{94}}} has to be shifted
            since we first have to compute the expression ``$3 \texttt{\symbol{94}} 4$''.
      \item $p(o) = p(r_2)$ and the operator $o$ has been declared to be non-associative.
            
            In this case we have a syntax error:
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{action}(s,o) = \textsl{error}$.
            \\[0.2cm]
            To understand this case, try to parse a string of the form
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{1 < 1 < 1}
            \\[0.2cm]
            using the grammar rules
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{expr} \rightarrow \textsl{expr} \quoted{<} \textsl{expr} \mid \textsl{expr} \quoted{+} \textsl{expr} \mid \simtextsc{Number}$.
            \\[0.2cm]
            %$
            Once the string ``\texttt{1 < 1}'' has been read and the next token is the operator ``\texttt{<}''
            the parser recognizes that there is an error.  Therefore, \simtextsc{Ply} will resolve this
            shift-reduce conflict by putting an error entry into the action table.
      \item $p(o)$ is undefined or $p(r_2)$ is undefined.

            In this case there is a shift-reduce conflict and \simtextsc{Ply} prints a warning message when
            generating the parser.  The conflict is then resolved in favour of shifting.
      \end{enumerate}
\end{enumerate}


\section{Resolving Shift-Reduce and Reduce-Reduce Conflicts}
We start our discussion by categorizing conflicts with respect to their origin.
\begin{enumerate}
\item \emph{Mehrdeutigkeits-Konflikte} sind Konflikte, die ihre Ursache in einer Mehrdeutigkeit
      der zu Grunde liegenden Grammatik haben.  Solche Konflikte weisen damit auf ein tats\"achliches
      Problem der Grammatik hin.  Wir hatten ein Beispiel f\"ur solche Konflikte gesehen, als wir in
      Abbildung \ref{fig:Conflicts.ipynb} 
      versucht hatten, die Syntax arithmetischer Ausdr\"ucke ohne die syntaktischen
      Kategorien \textsl{product} und \textsl{factor} zu beschreiben.

      Wir hatten damals bereits gesehen, dass wir das Problem durch die Einf\"uhrung von
      Operator-Pr\"azedenzen l\"osen k\"onnen.  Falls dies nicht m\"oglich ist, dann bleibt nur das
      Umschreiben der Grammatik.
\item \emph{Look-Ahead-Konflikte} sind Reduce-Reduce-Konflikte, bei denen die Grammatik zwar
      einerseits eindeutig ist, f\"ur die aber andererseits
      ein Look-Ahead von einem Token nicht ausreichend ist um den Konflikt zu l\"osen.
\item \emph{Mysteri\"ose Konflikte} entstehen erst beim \"Ubergang von den LR-Zust\"anden zu den \simtextsc{Lalr}-Zust\"anden 
      durch das Zusammenfassen von Zust\"anden mit dem gleichen Kern.  Diese Konflikte treten also
      genau dann auf, wenn das Konzept einer \simtextsc{Lalr}-Grammatik nicht ausreichend ist um die Syntax der
      zu parsenden Sprache zu beschreiben.
\end{enumerate}
Wir betrachten die letzten beiden F\"alle nun im Detail und zeigen Wege auf, wie die Konflikte gel\"ost
werden k\"onnen.

\subsection{Look-Ahead-Konflikte}
Ein Look-Ahead-Konflikt liegt dann vor, wenn die Grammatik zwar eindeutig ist, aber ein Look-Ahead von einem
Token nicht ausreicht um zu entscheiden,  mit welcher Regel reduziert werden soll.  Abbildung 
\ref{fig:lr-conflict.g} zeigt die Grammatik 
\href{https://github.com/karlstroetmann/Formal-Languages/blob/master/Python/Chapter-10/Look-Ahead.ipynb}{\texttt{Look-Ahead.ipynb}}\footnote{ 
Diese Grammatik habe ich im Netz auf der Seite von Pete Jinks unter der Adresse
\\[0.1cm]
\hspace*{1.3cm}
\href{http://www.cs.man.ac.uk/~pjj/cs212/ho/node19.html}{\texttt{http://www.cs.man.ac.uk/\symbol{126}pjj/cs212/ho/node19.html}}
\\[0.1cm]
gefunden.},
die zwar eindeutig ist, aber nicht die LR(1)-Eigenschaft hat und damit erst recht keine \simtextsc{Lalr}(1) Grammatik ist.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    a : b 'U' 'V'
      | c 'U' 'W'
    b : 'X'
    c : 'X'   
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Eine eindeutige Grammatik ohne die LR(1)-Eigenschaft.}
\label{fig:lr-conflict.g}
\end{figure}


Berechnen wir die LR-Zust\"ande dieser Grammatik,
so finden wir unter anderem den folgenden Zustand:
\\[0.2cm]
\hspace*{1.3cm}
$\{ b \rightarrow \;\squoted{X} \bullet: \squoted{U},\; c \rightarrow \;\squoted{X} \bullet: \squoted{U} \}$.
\\[0.2cm]
Da die Menge der Folge-Token f\"ur beide Regeln gleich sind, haben wir hier einen Reduce-Reduce-Konflikt.
Dieser Konflikt hat seine Ursache darin, dass der Parser mit einem Look-Ahead von nur einem Token nicht
entscheiden kann, ob ein $\squoted{X}$ als ein $b$ oder als ein $c$ zu interpretieren ist, denn dies
entscheidet sich erst, wenn das auf $\squoted{U}$ folgende Zeichen gelesen wird:  Handelt es sich hierbei
um ein $\squoted{V}$, so wird insgesamt die Regel
\\[0.2cm]
\hspace*{1.3cm}
$a \rightarrow b\; \squoted{U} \squoted{V}$
\\[0.2cm]
verwendet werden und folglich ist das $\squoted{X}$ als ein $b$ zu interpretieren. Ist das zweite Token
hinter dem $\squoted{X}$ hingegen ein  $\squoted{W}$, so ist die zu verwendende Regel
\\[0.2cm]
\hspace*{1.3cm}
$a \rightarrow c \;\squoted{U} \squoted{W}$
\\[0.2cm]
und folglich ist das $\quoted{X}$ als  $c$ zu lesen.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    a : b 'V'
      | c 'W'
    b : 'X' 'U'
    c : 'X' 'U'
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Eine zu Abbildung \ref{fig:lr-conflict.g} \"aquivalente LR(1)-Grammatik.}
\label{fig:lr-conflict-resolved.g}
\end{figure}

Das Problem bei dieser Grammatik ist, dass sie versucht, abh\"angig vom Kontext ein $\squoted{X}$ wahlweise
als ein $b$ oder als ein $c$ zu interpretieren.  Es ist offensichtlich, wie das Problem gel\"ost werden
kann:  Wenn der Kontext ``\texttt{U}'', der sowohl auf $b$ als auch auf $c$ folgt, mit in
die Regeln f\"ur $b$ und $c$ aufgenommen wird, dann verschwindet der Konflikt, denn dann hat der
Zustand, in dem fr\"uher der Konflikt auftrat, die Form
\\[0.2cm]
\hspace*{1.3cm}
$\{ b \rightarrow \;\squoted{X} \squoted{U}\bullet: \squoted{V},\; 
    c \rightarrow \;\squoted{X} \squoted{U}\bullet: \squoted{W} 
\}
$.
\\[0.2cm]  
Hier entscheidet sich nun anhand des n\"achsten Tokens, mit welcher Regel wir in diesem Zustand
reduzieren m\"ussen:  Ist das n\"achste Token ein $\squoted{V}$, so reduzieren wir mit der Regel
\\[0.2cm]
\hspace*{1.3cm}
$b \rightarrow \;\squoted{X} \squoted{U}$,
\\[0.2cm]
ist das n\"achste Token hingegen der Buchstabe $\squoted{W}$, so nehmen wir stattdessen die Regel
\\[0.2cm]
\hspace*{1.3cm}
$c \rightarrow \;\squoted{X} \squoted{U}\bullet: \squoted{W}$.
\\[0.2cm]
Abbildung
\ref{fig:lr-conflict-resolved.g} zeigt die entsprechend modifizierte Grammatik, die Sie unter
\\[0.2cm]
\hspace*{1.3cm}
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Python/Chapter-10/Look-Ahead-Solved.ipynb}{\texttt{Formal-Languages/tree/master/Python/Chapter-10/Look-Ahead-Solved.ipynb}}
\\[0.2cm]
im Netz finden.


\subsection{Mysterious Reduce-Reduce Conflicts}
A conflict is called a  \blue{mysterious reduce-reduce conflict} if the conflict results from the merger of
states that happens when we go from an LR parsing table to an \simtextsc{Lalr} parsing table.  The grammar in Figure
\ref{fig:Mysterious-Conflicts.ipynb} on page \pageref{fig:Mysterious-Conflicts.ipynb} is the same as the
grammar shown in Figure \ref{fig:lr-but-notlalr.g} on page \pageref{fig:lr-but-notlalr.g} in the previous
chapter.  Then we had seen that this grammar is an LR grammar, but not an \simtextsc{Lalr} grammar.  Let us see what happens
if we use \simtextsc{Ply} to generate the states for this grammar.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    s : 'v' a 'y'
      | 'w' b 'y'
      | 'v' b 'z'
      | 'w' a 'z'
      
    a : X
    
    b : X
\end{Verbatim}
\vspace*{-0.3cm}
\caption{A grammar that generates a mysterious reduce-reduce conflict.}
\label{fig:Mysterious-Conflicts.ipynb}
\end{figure}
\vspace*{0.3cm}

When we run \simtextsc{Ply} to produce the parsing table, we get the states shown in Figure
\ref{fig:Mysterious-Conflicts.parser.out} on page \pageref{fig:Mysterious-Conflicts.parser.out}.
This Figure only shows two states, \texttt{state 6} and \texttt{state 9}.  I have taken the liberty to annotate
the extended marked rules occurring in these states with their follow sets.  Taken by itself, none of these two
states has a conflict since the follow sets of the respective rules are disjoint.  However, 
it is obvious that these two states have the same core and should have been merged.  The resulting state would
have the form 
\\[0.2cm]
\hspace*{1.3cm}
$\bigl\{ a \rightarrow X \bullet:\{\saquoted{y}, \saquoted{z} \},
         b \rightarrow X \bullet:\{\saquoted{y}, \saquoted{z} \}
\bigr\}$
\\[0.2cm]
and obviously has a reduce-reduce conflict if the next token is either \saquoted{y} or \saquoted{z}.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    state 6
    
        (5) a -> X . : 'y'
        (6) b -> X . : 'z'
    
        y               reduce using rule 5 (a -> X .)
        z               reduce using rule 6 (b -> X .)

    state 9
    
        (6) b -> X . : 'y'
        (5) a -> X . : 'z'
    
        y               reduce using rule 6 (b -> X .)
        z               reduce using rule 5 (a -> X .)
\end{Verbatim}
\vspace*{-0.3cm}
\caption{A grammar that generates a mysterious reduce-reduce conflict.}
\label{fig:Mysterious-Conflicts.parser.out}
\end{figure}
\vspace*{0.3cm}

Interestingly, \simtextsc{Ply} does not merge these states and is therefore able to generate a parse table without
conflicts.  On the other hand, \simtextsc{Ply} claims to generate \simtextsc{Lalr} tables.  Therefore, I have written an
email to \href{https://en.wikipedia.org/wiki/David_M._Beazley}{David Beazley} asking whether this behaviour is
a feature or a bug.  He has classified this example as an ``\emph{interesting curiosity}''.


\exerciseEng
Use \simtextsc{Ply} to implement a \textsl{Python} parser that is able to evaluate formulas from propositional logic.
The language should support the operators ``\texttt{<->}'' (equivalence), ``\texttt{->}'' (implication),
``\texttt{|}'' (disjunction), ``\texttt{\&}'' (conjunction), and 
``\texttt{!}'' (negation).  The operator ``\texttt{!}'' should bind stronger than the operator ``\texttt{\&}'',
which in turn binds stronger than the operator ``\texttt{|}''.  The operators ``\texttt{|}'' and ``\texttt{\&}''
are both left associative.  The operator ``\texttt{->}'' associates to the right and binds weaker than the
operator ``\texttt{|}''. 
The operator ``\texttt{<->}'' in not associative and is the weakest of all operators in terms of binding strength.
Furthermore, the language should support parenthesis, variables, and the assignment operator ``\texttt{:=}''.  \eox


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "formal-languages"
%%% End: 
