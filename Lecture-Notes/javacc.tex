
\section{\textsl{JavaCC}}
Die Sprache \texttt{C} ist in vielen Bereichen von der Sprache \textsl{Java}\/ verdrängt
worden.  Daher ist es nur natürlich, dass auch für \textsl{Java}\/ Scanner-Generatoren
entwickelt worden sind.  Hier gibt es mittlerweile eine ganze Menge verschiedener
Werkzeuge.  Von diesen hat das Werkzeuge \textsl{JavaCC}\/ \cite{kodaganallur:2004}
einen offiziellen Character, weil
es wie \textsl{Java}\/ von der Firma \textsl{Sun \/Microsystems} entwickelt worden ist und
\textsl{JavaCC}\/ ein registriertes Warenzeichen der Firma \textsl{Sun}\/ ist.  Daher habe ich
von den verschiedenen zur Auswahl stehenden Werkzeugen zunächst \textsl{JavaCC}\/ ausgewählt.

Eigentlich ist \textsl{JavaCC}\/ mehr als nur ein Scanner-Generator, denn mit
\textsl{JavaCC}\/ können Sie auch einen Parser erzeugen.  Diesen Aspekt werden wir in
einem späteren Kapitel noch besprechen.  Zunächst begnügen wir uns aber damit,
\textsl{JavaCC}\/ als Scanner-Generator einzusetzen.  

\subsection{Ein Beispiel}
Wir demonstrieren die Funktionalität von \textsl{JavaCC}\/
anhand des Beispiels der Notenberechnung, wir setzen das Beispiel aus Abbildung
\ref{fig:noten.l} also nun noch einmal mit \textsl{JavaCC}\/ um.  Abbildung
\ref{fig:Klausur.jj} zeigt die Datei \texttt{Klausur.jj}, die eine Eingabe-Spezifikation
für das Werkzeug \textsl{JavaCC}\/ ist.  


\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    PARSER_BEGIN(Klausur)
    
    public class Klausur {
        static String  sName      = null;
        static Integer sSumPoints = 0;
        static Integer sMaxPoints = 0;
        
        public static void main(String args[]) throws ParseException {
            SimpleCharStream    stream  = new SimpleCharStream(System.in);
            KlausurTokenManager manager = new KlausurTokenManager(stream);
            Token               t;
            sMaxPoints = new Integer(args[0]);
            do {
                t = manager.getNextToken();
            } while (t.kind != 0); // end of file gives t.kind = 0 
        }
        static Double note() {
            return 7.0 - 6.0 * sSumPoints / sMaxPoints;
        }
    }
    PARSER_END(Klausur)
    
    TOKEN: {
        <KOPF:    (<LETTER>)+ ":" (~["\n"])* "\n">
      | <NAME:    (<LETTER>)+ " " (<LETTER>)+>  
                  {
                      Klausur.sName      = image.toString(); 
                      Klausur.sSumPoints = 0;
                      System.out.print(Klausur.sName);
                  }
      | <COLON:   ":" ([ " ", "\t" ])+>         
                  { 
                      System.out.print(image); 
                  }
      | <ZAHL:    "0" | ["1"-"9"] (["0"-"9"])*> 
                  { 
                      Klausur.sSumPoints += new Integer(image.toString()); 
                  }
      | <HYPHEN:  "-">
      | <EOL:     ([" ", "\t"])* "\n">          
                  { 
                      if (Klausur.sName != null) {
                          System.out.printf(" %3.1f\n", Klausur.note()); 
                      }
                  }
      | <WHITE:   [" ", "\t"]>
      | <#LETTER: ["a"-"z", "A"-"Z", "ö", "ä", "ü", "Ö", "Ä", "Ü", "ß"]>
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Ein \textsl{JavaCC}-Programm zur Notenberechnung}
\label{fig:Klausur.jj}
\end{figure}

Eine \textsl{JavaCC}-Eingabe-Spezifikation für einen Scanner besteht aus zwei Teilen:
\begin{enumerate}
\item Die \emph{Klassen-Definition} wird durch die Schlüsselwörter
      ``\texttt{PARSER\_BEGIN}'' und ``\texttt{PARSER\_END}''
      eingeschlossen.  In der Abbildung erstreckt sich dieser Teil
      von Zeile 1 -- 21.
\item Die \textsl{Token-\/Definition} definiert verschiedene Tokens durch
      reguläre Ausdrücke.
      In unserem Beispiel beginnt sie mit dem Schlüsselwort ``\texttt{TOKEN}''
      in Zeile 23, dem eine Doppelpunkt und eine öffnende geschweifte Klammer
      ``\texttt{\{}'' folgt.   Sie endet in Zeile 45 mit der schließenden geschweiften
      Klammer ``\texttt{\}}''.
\end{enumerate}
Wir diskutieren die Eingabe-Spezifikation jetzt Zeile für Zeile.
\begin{enumerate}
\item In Zeile 1 folgt hinter dem Schlüsselwort ``\texttt{PARSER\_BEGIN}'' der in Klammern
      eingeschlossene Name der Datei, die die Spezifikation enthält, wobei die
      Datei-Endung weggelassen wird.  Die Datei-Endung lautet immer ``\texttt{.jj}''.
\item Anschließend folgt eine Klassen-Definition.  Der Name dieser Klasse muss ebenfalls
      mit dem Datei-Namen übereinstimmen.
  
      In unserem Fall enthält die Klasse zunächst die Definitionen verschiedener
      statischer Variablen.
      \begin{enumerate}
      \item Die in Zeile 4 definierte Variable \texttt{sName} enthält später den Namen 
            des Studenten, dessen Note berechnet werden soll.  Wir initialisieren diese
            Variable aber zunächst mit \texttt{null}.  Dadurch haben wir später die
            Möglichkeit zu prüfen, ob bereits Punkte eines Studenten gelesen worden sind
            oder ob bisher erst die Kopfzeilen der Eingabe-Datei gelesen wurden.
      \item Die in Zeile 5 definierte Variable \texttt{sSumPoints} gibt die Summe aller
            Punkte an, die ein Student erzielt hat.
      \item Die in Zeile 6 definierte Variable \texttt{sMaxPoints} gibt die maximal erreichbare Punktezahl an.
      \end{enumerate}
      Anschließend wird die Methode \texttt{main} definiert.  Diese Methode ist erforderlich, damit
      der erzeugte Scanner aufgerufen werden kann.  
      \begin{enumerate}
      \item Als erstes erzeugen wir einen \emph{Token-Manager}.  Da der Konstruktor 
            für einen Token-Manager als Eingabe ein Objekt vom Type
            \texttt{SimpleCharStream} erwartet, 
            konvertieren wir den Eingabestrom ``\texttt{System.in}'' zunächst in ein solches
            Objekt und erzeugen dann in Zeile 10 den Token-Manager, als Objekt der
            Klasse \texttt{KlausurTokenManager}.  
      \item Die Methode \texttt{main} bekommt die maximale Punktzahl als Argument
            übergeben und speichert diese in Zeile 12 in der Variablen \texttt{sMaxPoints}
            ab.
      \item Anschließend lesen wir in der \texttt{while}-Schleife solange Tokens, bis wir
            das \textsl{End-Of-File}-Token lesen.  Dieses Token können wir daran erkennen,
            dass die Member-Variable \texttt{t.kind} den Wert 0 hat.
            Diese Schleife bezeichnen wir im Folgenden als die \emph{Scanner-Schleife}.
       
            Jedesmal, wenn der Scanner ein Token erkennt, werden die mit dem Token
            spezifizierten Aktionen ausgeführt, mehr dazu später.
      \end{enumerate}
      Neben der Methode $\textsl{main}()$, die in jeder Parser-Klasse vorhanden
      sein muss, enthält die Klasse \texttt{Klausur} noch die Definition der statischen
      Methode $\texttt{note}()$, mit der später die Note berechnet wird.  Hier
      wird dieselbe Formel verwendet, die wir auch schon in dem entsprechenden
      \textsl{Flex}-Beispiel benutzt haben.
\item Nun folgen nach dem Schlüsselwort \texttt{Token} und einem Doppelpunkt die
      einzelnen Token-Definitionen.  Diese werden insgesamt von geschweiften Klammern
      eingefasst und die einzelnen Token-Spezifikationen werden durch das
      Zeichen ``\texttt{|}'' voneinander getrennt.  Eine einzelne Token-Spezifikationen hat die
      Form
      \\[0.2cm]
      \hspace*{1.3cm} $\texttt{<}\textsl{Name}\texttt{:} \textsl{RegExp}\texttt{>}$ $\texttt{\{} \;\textsl{CmdList}\; \texttt{\}}$
      \\[0.2cm]
      Die Bedeutung der einzelnen Komponenten ist wie folgt:
      \begin{enumerate}
      \item \textsl{Name}\/ steht für den Namen eines Tokens.  Dieser besteht aus
            Großbuchstaben.  
      \item \textsl{RegExp}\/ bezeichnet einen regulären Ausdruck.  Die Syntax der
            regulären Ausdrücke weicht von der bei \textsl{Flex}\/ gebräuchlichen
            Syntax stark ab.  Insbesondere haben Leerzeichen und Tabulatoren keine
            Bedeutung, so dass es möglich ist, komplexe reguläre Ausdrücke lesbar zu
            formatieren.  Wir werden die genaue Syntax regulärer Ausdrücke im nächsten
            Unterabschnitt im Detail diskutieren,
            
            \textsl{Name}\/ und \textsl{RegExp}\/ werden zusammen in spitzen Klammern ``\texttt{<}''
            und ``\texttt{>}'' eingeschlossen und durch einen Doppelpunkt getrennt.
      \item \textsl{CmdList}\/ steht für eine Liste von Befehlen.  Diese Befehle
            werden ausgeführt, sobald Text erkannt wird, der von dem regulären Ausdruck
            \textsl{RegExp}\/ erkannt wird.  Syntaktisch handelt es sich bei den Befehlen
            um einen in geschweiften Klammern eingeschlossenen Block von \textsl{Java}-Code.
      \end{enumerate}
      Wir analysieren nun die einzelnen Token-Definitionen aus Abbildung \ref{fig:Klausur.jj}.
      \begin{enumerate}
      \item Die Definition des Tokens \texttt{KOPF} in Zeile 24 spezifiziert die
            Kopfzeilen einer Ergebnis-Datei, die beispielsweise die folgende Form haben:
            \begin{verbatim}
            Klausur: Algorithmen und Datenstrukturen
            Kurs:    TIT07AIX
            \end{verbatim}
            \vspace*{-0.5cm}

            Der reguläre Ausdruck, der in Zeile 24 auf den Doppelpunkt folgt, besteht aus vier
            Komponenten:
            \begin{enumerate}
            \item \texttt{(<LETTER>)+}
              
              Durch die spitzen Klammern wird das Token \texttt{LETTER} referenziert.
              Dieses Token wird weiter unten in Zeile 47 definiert und steht für einen beliebigen
              Buchstaben einschließlich eines Umlauts oder ``\texttt{ß}''.  Das Token
              \texttt{LETTER} ist in runden Klammern eingeschlossen, auf die noch der Operator
              ``\texttt{+}'' folgt.  Dieser Operator steht genau wie bei \textsl{Flex}\/ für
              eine beliebige positive Anzahl von Wiederholungen.  Im Unterschied zu
              \textsl{Flex}\/ muss das Argument, auf dass sich der Operator ``\texttt{+}''
              bezieht, aber in runden Klammern eingeschlossen sein.  Insgesamt steht der
              Ausdruck ``\texttt{(<LETTER>)+}'' also für eine beliebige positive Anzahl
              von Buchstaben.
            \item \texttt{\symbol{34}:\symbol{34}}

                  In doppelten Hochkommata ``\texttt{\symbol{34}}'' eingeschlossener Text
                  wird wörtlich interpretiert.  Der wesentliche Unterschied zu \textsl{Flex},
                  der hier sichtbar wird, ist die Tatsache, dass innerhalb regulärer Ausdrücke in
                  \textsl{JavaCC}\/ Leerzeichen, Tabulatoren und Zeilenumbrüche zulässig sind.
                  Diese werden ignoriert.  So wird das Leerzeichen, dass den Ausdruck
                  ``\texttt{\symbol{34}:\symbol{34}}'' von dem Ausdruck
                  ``\texttt{(<LETTER>)+}'' trennt, ignoriert.  Ich habe dieses Leerzeichen
                  zur Verbesserung der Lesbarkeit eingefügt.  Das wäre bei einer
                  \textsl{Flex}-Spezifikation so nicht möglich.
            \item \texttt{(\symbol{126}[\symbol{34}\symbol{92}n\symbol{34}])*}

                  Dieser Ausdruck beschreibt eine beliebige Anzahl von Zeichen,
                  die von einem Zeilen-Umbruch ``\texttt{\symbol{92}n}'' verschieden sind.
                  Zunächst haben wir hier den in eckigen Klammern eingeschlossenen
                  Ausdruck ``\texttt{\symbol{92}n}''.  Eckige Klammern geben, genau wie bei
                  \textsl{Flex}, eine Menge von Zeichen an.  Im Unterschied zu \textsl{Flex}\/ 
                  müssen die Zeichen aus dieser Menge allerdings alle in doppelten Hochkommata
                  ``\texttt{\symbol{34}}'' eingefasst werden.  
                  In dem obigen Fall enthält die Menge nur ein einziges
                  Zeichen.  \textbf{Vor} den eckigen Klammern finden wir aber das Zeichen
                  ``\texttt{\symbol{126}}''.  Dieses Zeichen bewirkt eine Komplementbildung:
                  Der Ausdruck ``\texttt{\symbol{126}[\symbol{34}\symbol{92}n\symbol{34}]}''
                  steht also für alle Zeichen, die von einem Zeilen-Umbruch \textbf{verschieden} sind.

                  Hier weicht die Syntax ebenfalls von der bei \textsl{Flex}\/ gebräuchlichen
                  Syntax ab, den bei \textsl{Flex}\/ wird zur Komplementbildung der Operator
                  ``\texttt{\^}'' verwendet und dieser steht dann als erstes Zeichen \textbf{nach} der
                  öffnenden eckigen Klammer.

                  Der ganze Ausdruck ist dann noch in runden Klammern eingefasst, auf die der
                  Operator ``\texttt{*}'' folgt.  Genau wie bei \textsl{Flex}\/ steht dieser
                  Operator für eine beliebige Anzahl von Wiederholungen.
                  Im Unterschied zu \textsl{Flex}\/ muss das Argument, auf dass sich der
                  Operator ``\texttt{*}'' bezieht, aber in runden Klammern eingeschlossen
                  sein.
            \item \texttt{\symbol{34}\symbol{92}n\symbol{34}}
          
                  Dieser Ausdruck steht für einen Zeilen-Umbruch.
            \end{enumerate}
            Hinter dem Token \texttt{KOPF} steht kein \textsl{Java}-Block.  Daher
            wird der Text, der hier erkannt wurde, einfach ignoriert.  
      \item Die Definition von \texttt{NAME} sagt, dass eine Name aus zwei Gruppen
            von Buchstaben besteht, die durch ein Leerzeichen getrennt werden.
            Wichtig ist hier, dass das Leerzeichen in dem regulären Ausdruck in
            doppelte Hochkommata ``\texttt{\symbol{34}}'' eingefasst ist, denn (wie oben
            bereits erwähnt) können reguläre Ausdrücke bei \textsl{JavaCC}\/ durch das
            Einfügen von Leerzeichen, Tabulatoren und Zeilenumbrüchen zur Verbesserung
            der Lesbarkeit formatiert werden.

            Wir diskutieren nun den \textsl{Java}-Block in den Zeilen 26 -- 30:
            Der Text, der durch den regulären Ausdruck erkannt wird, ist in der Variablen
            \texttt{image} abgelegt.  Diese Variable entspricht also der \textsl{Flex}-Variablen 
            \texttt{yytext}.  Die Variable \texttt{image} hat aus Effizienzgründen den Typ
            \texttt{StringBuffer} und kann mit der Methode $\textsl{toString}()$ in einen
            \texttt{String} umgewandelt werden.  Mit diesem String initialisieren wir die 
            statische Variable \texttt{sName}.  Beachten Sie, dass der Klassenname
            ``\texttt{Klausur}'' der statischen Variablen vorangestellt werden muss,
            denn der \textsl{Java}-Block  ist später Teil der Klasse
            \texttt{KlausurTokenManager} und nicht der Klasse \texttt{Klausur}.
            
            
      \item Die Definition von \texttt{COLON} spezifiziert einen Doppelpunkt, auf 
            den Leerzeichen und Tabulatoren folgen.  Beachten Sie hier das Komma
            in der Mengen-Definition
            \begin{verbatim}
            [" ", "\t"]
            \end{verbatim}
            \vspace*{-0.5cm}

            Bei \textsl{JavaCC}\/ müssen die einzelnen Zeichen einer Mengen-Definition
            durch Kommata getrennt werden.
      \item Das Token \texttt{ZAHL} steht für eine ganze Zahl.
            Dies ist entweder das Zeichen ``\texttt{0}'' oder eine beliebige Folge von
            Ziffern, die nicht mit dem Zeichen ``\texttt{0}'' beginnt.
            
            Dieses Beispiel zeigt, dass auch bei \textsl{JavaCC}\/ innerhalb einer
            Mengen-Definition Bereiche gebildet werden können.  Dazu wird genau wie bei 
            \textsl{Flex}\/ das Minus-Zeichen ``\texttt{-}'' verwendet.
      \item Das Token \texttt{HYPHEN} steht für ein einzelnes Minus-Zeichen ``\texttt{-}''.
      \item Das Token \texttt{EOL} steht für Leerzeichen und Tabulatoren, die am
            Zeilenende auftreten.  Der abschließende Zeilenumbruch gehört ebenfalls noch
            zu dem Token.  Der Name \texttt{EOL} ist als Abkürzung für 
            \emph{\underline{e}nd \underline{o}f \underline{l}ine} gedacht.
      \item Das Token \texttt{WHITE} steht für Leerzeichen und Tabulatoren.
      \item Das Token \texttt{LETTER} ist durch das Voranstellen des
            Zeichens ``\texttt{\#}'' als \emph{privat} deklariert worden.
            Ein solches Token kann nur bei der Definition anderer Token verwendet werden,
            der Scanner gibt später nie ein Token zurück, das als privat deklariert
            wurde.  Durch die Verwendung privater Token können reguläre Ausdrücke
            abgekürzt werden.  Die \emph{regulären Definitionen} in \textsl{Flex}\/ haben
            dieselbe Funktion.
      \end{enumerate}
\end{enumerate}
Um das Beispiel zu übersetzen, geben wir die folgenden Befehle ein:
\begin{enumerate}
\item \texttt{javacc Klausur.jj}

      Dieser Befehl erzeugt die Datei \texttt{Klausur.java}.  Zusätzlich werden noch die
      Dateien  
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{KlausurConstants.java}, \texttt{KlausurTokenManager.java} und
      \texttt{Token.java} 
      \\[0.2cm]
      generiert.
\item \texttt{javac Klausur.java}      

      Damit werden die erzeugten \textsl{Java}-Dateien übersetzt.
\item \texttt{java Klausur 60 < ergebnis}

      Hierdurch wird der erzeugte Scanner mit dem Argument 60 aufgerufen.
      Als Eingabe verarbeitet der Scanner dann die Datei \texttt{ergebnis}.
\end{enumerate}

\subsection{Reguläre Ausdrücke in \textsl{JavaCC}}
Die Syntax der regulären Ausdrücke ist für \textsl{JavaCC}\/ wie folgt:
\begin{enumerate}
\item In doppelten Hochkommata eingeschlossen Strings stehen für sich selbst.
      Beispiel:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{34}else\symbol{34}}
      \\[0.2cm]
      steht für den String ``\texttt{else}''.  Genau wie bei \textsl{Flex}\/ haben
      Operator-Symbole innerhalb eines solchen Strings keine Bedeutung. 
\item Bereiche können mit den eckigen Klammern ``\texttt{[}'' und ``\texttt{]}''
      gebildet werden, im Unterschied zu \textsl{Flex}\/ müssen die einzelnen Zeichen
      allerdings in Hochkommata eingeschlossen werden.  Beispiel:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{[\symbol{34}0\symbol{34} - \symbol{34}9\symbol{34}]}
      \\[0.2cm]
      Dieser Ausdruck steht für eine beliebige Ziffer.
\item Die Komplementbildung erfolgt für Bereiche durch das Zeichen
      ``\texttt{\symbol{126}}'', dass nun \textbf{vor} der öffnenden eckigen Klammer
      steht.
      Beispiel:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{126}[\symbol{34}a\symbol{34} - \symbol{34}z\symbol{34}]}
      \\[0.2cm]
      Dieser Ausdruck steht für ein Zeichen, dass \textbf{kein} kleiner Buchstabe ist.
\item Der Kleene-Abschluss wird mit dem Postfix-Operator ``\texttt{*}'' gebildet.
      Im Unterschied zu \textsl{Flex}\/ muss das Argument allerdings in runden Klammern
      eingeschlossen sein.  Beispiel:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{([\symbol{34}0\symbol{34}-\symbol{34}9\symbol{34}])*}
      \\[0.2cm]
      Dieser Ausdruck steht für einen String, der nur aus Ziffern besteht.
\item Genau wie in \textsl{Flex}\/ gibt es die Postfix-Operatoren ``\texttt{?}'' und
      ``\texttt{+}'', deren Argumente allerdings zusätzlich in runden Klammern
      eingeschlossen sein müssen.
\item Eine Auswahl zwischen verschiedenen Alternativen erfolgt genau wie bei \textsl{Flex}\/
      mit Hilfe des Operators ``\texttt{|}''.  Beispiel:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{\symbol{34}0\symbol{34} | [\symbol{34}1\symbol{34}-\symbol{34}9\symbol{34}] ([\symbol{34}0\symbol{34}-\symbol{34}9\symbol{34}])*}
      \\[0.2cm]       
      Dieser Ausdruck steht für eine einzelne 0 oder eine Zahl, die mit einer
      postiven Ziffer anfängt, auf die dann beliebig viele andere Ziffern folgen.
\end{enumerate}
Die Operatoren ``\texttt{\symbol{94}}'' und ``\texttt{\symbol{36}}'', mit denen in \textsl{Flex}\/
der Beginn bzw.~das Ende einer Zeile spezifiziert werden können, gibt es in
\textsl{JavaCC}\/ nicht.  Auch der Operator ``\texttt{/}'', mit dem \emph{trailing context}
spezifiziert werden kann, fehlt in \textsl{JavaCC}.  Schließlich ist auch der Punkt
``\texttt{.}'', der in \textsl{Flex}\/ für ein beliebiges von ``\texttt{\symbol{92}n}''
verschiedenes Zeichen steht, in \textsl{JavaCC}\/ kein Operator.  Um ein beliebiges Zeichen
zu spezifizieren kann in \textsl{JavaCC}\/ der Ausdruck
\\[0.2cm]
\hspace*{1.3cm}
\texttt{\symbol{126}[]}
\\[0.2cm]
verwendet werden, denn dieser Ausdruck spezifiziert das Komplement eines leeren Bereichs
und das sind alle Zeichen!

\subsection{Zustände in \textsl{JavaCC}}
Auch in \textsl{JavaCC}\/ gibt es Zustände.  Abbildung \ref{fig:DeComment.jj} zeigt
ein \textsl{JavaCC}-Programm, mit dessen Hilfe Kommentare der Form
\\[0.2cm]
\hspace*{1.3cm}
\texttt{/*} $\cdots$ \texttt{*/}
\\[0.2cm]
aus einer \texttt{C}-Datei entfernt werden können.  Im Unterschied zu \textsl{Flex}\/
werden Zustände in \textsl{JavaCC}\/ nicht deklariert, es gibt also kein Pendant zu
``\texttt{\%x}'' bzw. ``\texttt{\%s}''.  
Außerdem sind in \textsl{JavaCC}\/ alle Zustände automatisch exklusiv.  Der Default-Zustand
heißt jetzt ``\texttt{DEFAULT}''.

\begin{figure}[!h]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    PARSER_BEGIN(DeComment)
    
    public class DeComment {
        public static void main(String args[]) throws ParseException {
            SimpleCharStream      stream  = new SimpleCharStream(System.in);
            DeCommentTokenManager manager = new DeCommentTokenManager(stream);
            Token t;
            do {
                t = manager.getNextToken();
            } while (t.kind != 0); // end of file gives t.kind = 0 
        }
    }
    PARSER_END(DeComment)
    
    <DEFAULT> TOKEN: {
        <START: "/*"> { /* change state here */  } : ML_COMMENT
    |   <CHAR:  ~[]>  { System.out.print(image); } : DEFAULT
    }
    <ML_COMMENT> TOKEN: {
        <STOP: "*/"> {} : DEFAULT
    |   <EAT:  ~[]>  {} : ML_COMMENT
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Entfernung mehrzeiliger Kommentare}
\label{fig:DeComment.jj}
\end{figure}

\noindent
Das Programm in Abbildung \ref{fig:DeComment.jj} ist wie folgt aufgebaut.
\begin{enumerate}
\item Nach der Erzeugung eines Token-Managers finden wir in den Zeilen 8 -- 10
      die \emph{Scanner-Schleife}.
\item Anschließend finden wir in dem Programm zwei Gruppen von Token-Definitionen.
      \begin{enumerate}
      \item Die Zeilen 15 -- 18 enthalten die Regeln, die im Zustand \texttt{DEFAULT}
            verwendet werden.
            \begin{itemize}
            \item Die Regel mit dem Namen \texttt{START} erkennt den String 
                  ``\texttt{/*}'', mit dem ein mehrzeiliger Kommentar eingeleitet wird.
                  Diese Regel wechselt in den Zustand \texttt{ML\_COMMENT}.
            \item Die Regel mit dem Namen \texttt{CHAR} erkennt das Komplement
                  der leeren Zeichenmenge, also ein beliebiges Zeichen.
                  Dieses Zeichen wird unverändert ausgegeben.  Der Folge-Zustand
                  ist wieder der Zustand \texttt{DEFAULT}, es findet also kein
                  Zustandswechsel statt.  Daher könnten wir bei dieser Regel 
                  den Rest 
                  \\[0.2cm]
                  \hspace*{1.3cm}
                  \texttt{: DEFAULT}
                  \\[0.2cm]
                  auch weglassen, denn die Angabe eines Folge-Zustands ist optional.
            \end{itemize}
      \item Die Zeilen 19 -- 22 enthalten die Regeln, die im Zustand \texttt{ML\_COMMENT}
            zum Tragen kommen.
            \begin{itemize}
            \item Die Regel mit dem Namen \texttt{STOP} erkennt den String
                  ``\texttt{*/}'', mit dem ein mehrzeiliger Kommentar beendet wird
                  und wechselt in den Zustand \texttt{DEFAULT}.
            \item Die Regel mit dem Namen \texttt{CHAR} erkennt ein beliebiges
                  Zeichen, was dann einfach verschluckt wird.
            \end{itemize}
      \end{enumerate}
\end{enumerate}
Wir erkennen an dem Beispiel, dass die allgemeine Syntax einer Regel die folgende 
Form hat:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{<}\textsl{Name}\texttt{:}\textsl{Regexp}\texttt{>} 
\texttt{\{} \textsl{CmdList} \texttt{\}} \texttt{:} \textsl{State}
\\[0.2cm]
Hierbei gilt:
\begin{enumerate}
\item \textsl{Name} ist der Name, unter dem das Token später angesprochen werden kann.
      Solange wir \textsl{JavaCC}\/ nur als Scanner verwenden, hat dieser Name keine
      Bedeutung.  Im Allgemeinen wird \textsl{JavaCC}\/ aber als \emph{Parser-Generator}
      eingesetzt und dann können wir in den Grammatik-Regeln auf die Namen zurück greifen.
\item \textsl{Regexp} ist der reguläre Ausdruck, der erkannt werden soll.
\item \textsl{CmdList} ist die Gruppe von Befehlen, die ausgeführt werden, sobald der reguläre
      Ausdruck erkannt worden ist.
\item \textsl{State} ist der Zustand, in den der Automat wechseln soll, nachdem die
      Kommandos abgearbeitet sind.  Die Angabe des Folge-Zustands ist optional.
      Wird kein Folge-Zustand angegeben, so bleibt der Scanner in dem Zustand, in dem er
      gerade ist.
\end{enumerate}
\pagebreak

\exercise
Entwickeln Sie einen Assembler für die im Rechnertechnik-Skript
beschriebene Assembler-Sprache.  Das Programm soll eine Assembler-Datei in eine binäre
Datei übersetzen.
\vspace*{0.3cm}

\noindent
\textbf{Hinweise}:  
\begin{enumerate}
\item Verwenden Sie verschiedene Zustände um die einzelnen Komponenten eines Assembler-Befehls
      zu lesen.
\item Passen Sie die Klasse \texttt{Assembler}, die in dem
      Rechnertechnik-Skript vorgestellt wird, an Ihren Bedarf an und verwandeln Sie diese Klasse
      in eine konkrete Klasse.  Die abgeleiteten Klassen sind nicht mehr erforderlich.
\item Um eine 32-Bit-Zahl binär auszugeben, können Sie die folgende Methode verwenden:
      \begin{verbatim}
public void writeBinary(OutputStream writer, int code) throws IOException
{
    int b0   = (code >>  0) & 255;
    int b1   = (code >>  8) & 255;
    int b2   = (code >> 16) & 255;
    int b3   = (code >> 24) & 255;
    writer.write(b0);
    writer.write(b1);
    writer.write(b2);
    writer.write(b3);
}
\end{verbatim}

\end{enumerate}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "formale-sprachen"
%%% End: 
