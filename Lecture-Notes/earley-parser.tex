\chapter{Earley Parser}

\begin{figure}[h] 
\centering
  \includegraphics[width=10.5cm]{Abbildungen/earl-of-eye.png}
\caption{The Earl of Eye in Suffolk.}
\label{fig:earl-of-eye.png}
\end{figure}


In this Chapter we will discuss an efficient algorithm that takes two inputs:
\begin{enumerate}
\item A context-free grammar $G = \langle V, \Sigma, R, s \rangle$ and
\item a string $w \in \Sigma^*$.
\end{enumerate}
The algorithm decides, whether $s \in L(G)$ holds, i.e.~it checks, whether the string is a
member of the language generated by th \simtextsc{Cfg} $G$.

The algorithm that is presented next has been published in 1970 by Jay Earley \cite{earley:70}.
There is another algorithm solving the same problem, namely the
\href{https://en.wikipedia.org/wiki/CYK_algorithm#:~:text=In%20computer%20science%2C%20the%20Cocke,Tadao%20Kasami%2C%20and%20Jacob%20T.}{Cocke-Younger-Kasami algorithm},
\index{Cocke-Younger-Kasami-Algorithmus}
  which is also known as the
\blue{\simtextsc{Cyk} algorithm}.\index{\simtextsc{Cyk}-Algorithmus}
It has been discovered independently by John Cocke
\cite{cocke:1970}, Daniel H.~Younger \cite{younger:1967}, and Tadao Kasami \cite{kasami:1965}.
The \simtextsc{Cyk} algorithm can only be used when the grammar has a special form, namely it has to be in
\href{https://en.wikipedia.org/wiki/Chomsky_normal_form}{Chomsky normal form}.
As it is quite tedious to transform a given grammar into Chomsky normal form, this algorithm is not used in
practical applications.
In contrast, the Earley algorithm works for arbitrary context-free grammars and hence is used in practical applications.
In the general case, the Earley algorithm has a complexity of $\mathcal{O}(n^3)$ where $n$ is the length of the
string that is to be parsed.  However, if the grammar is not ambiguous, the complexity is only
$\mathcal{O}(n^2)$.  Skillful implementations of Earley's algorithm even achieve a linear runtime for many
practically relevant grammars.   
For example, Earley's algorithm has a linear complexity for both  $LL(k)$ grammars and also for $LR(1)$
grammars.  We will discuss $LR(1)$ grammars in a later Chapter.  On the contrary, the \simtextsc{Cyk} algorithm
always has the complexity $\mathcal{O}(n^3)$, which is prohibitive for practical applications.

This chapter is structured as follows:
\begin{enumerate}[(a)]
\item First, we sketch the theory of Earley's algorithm.
\item Next, we show how this algorithm can be implemented in \textsl{Python}.
%\item Anschließend beweisen wir die Korrektheit und Vollst\"andigkeit des Algorithmus.
%\item Zum Abschluss des Kapitels untersuchen wir die Komplexit\"at.
\end{enumerate}

\section{The Earley Algorithm}
The central notion that is needed to understand Earley's algorithm is the notion of an
\blue{Earley object}\index{Earley object}.  This notion is defined below.

\begin{Definition}[Earley Object]
  Assume that  $G = \langle V, \Sigma, R, s \rangle$ is a context-free grammar and
  $w = x_1x_2 \cdots x_n \in \Sigma^*$ is a string of length $n$.  A pair of the form
  \\[0.2cm]
  \hspace*{1.3cm}
  $\langle a \rightarrow \beta \bullet \gamma, k \rangle$
  \\[0.2cm]
  is called an \blue{Earley object} if and only if
  \begin{enumerate}[(a)]
  \item $(a \rightarrow \beta\gamma) \in R$ \quad and
  \item $k \in \{0,1,\cdots,n\}$. \eox
  \end{enumerate}
\end{Definition}

\noindent
\textbf{Explanation}: 
An Earley describes a possible state of a parser.
If a parser has to parse a string of the form $x_1 \cdots x_n$, then this parser will maintain
$n+1$ sets of Earley objects.  These sets are denoted as
\\[0.2cm]
\hspace*{1.3cm}
$Q_0, Q_1, \cdots, Q_n$.
\\[0.2cm]
If $i \in \{0,1, \cdots, n\}$, then the state $Q_i$ contains those Earley objects that describe the state of
the parser after it has parsed the tokens $x_1$, $\cdots$, $x_i$.  
The interpretation of 
\\[0.2cm]
\hspace*{1.3cm}
$\langle a \rightarrow \beta \bullet \gamma, k \rangle \in Q_j$ \quad where  $j \geq k$
\\[0.2cm]
is as follows:
\begin{enumerate}
\item The parser tries to use the grammar rule $a \rightarrow \beta \gamma$ to parse the variable $a$ at the
      beginning of the substring $x_{k+1} \cdots x_n$.
\item The parser has already parsed $\beta$ in the substring  $x_{k+1} \cdots x_j$, we have
      \\[0.2cm]
      \hspace*{1.3cm}
      $\beta \Rightarrow^* x_{k+1} \cdots x_j$.
\item Hence, in order to parse the variable $a$ the parser only needs to recognize $\gamma$ at the beginning of
      the substring $x_{j+1} \cdots x_n$.
\end{enumerate}
Earley's  algorithm manages the sets $Q_0$, $Q_1$, $\cdots$, $Q_n$  of Earley objects.  The set $Q_j$ contains
those Earley objects that contain all those states the parser could be in when it has read the prefix 
$x_1 \cdots x_j$.

At the beginning of the algorithm we add a new start variable  $\widehat{s}$ to the grammar.  Furthermore the
rule $\widehat{s} \rightarrow s$ is added to the grammar.  Hence, the grammar $G = \langle V, \Sigma, R, s \rangle$
is transformed into the \blue{augmented grammar} 
\\[0.2cm]
\hspace*{1.3cm}
$\widehat{G} = \langle V \cup \{\widehat{s}\}, \Sigma, R \cup \{ \widehat{s} \rightarrow s \}, \widehat{s} \,\rangle$. 
\\[0.2cm]
Next, the set $Q_0$ is defined as
\\[0.2cm]
\hspace*{1.3cm}
$Q_0 := \bigl\{ \pair(\widehat{s} \rightarrow \bullet s, 0) \bigr\}$.
\\[0.2cm]
The reason is that the  parser should recognize the start symbol $s$ at the beginning of the string $x_1 \cdots
x_n$.
The remaining sets  $Q_j$ are initially empty for $j=1,\cdots,n$.  These sets are extended by the
following three operations: 
\begin{enumerate}
\item \emph{Reading}

      If the set $Q_j$ contains an Earley object of the form 
      $\pair(a \rightarrow \beta \bullet T \gamma, k)$ and $T$ is a 
      terminal, then the parser tries to parse the right hand side of the grammar rule
      $a \rightarrow \beta T \gamma$ and, after reading $x_{k+1} \cdots x_j$ it has already recognized $\beta$.
      If this $\beta$ is now followed by the token $T$, then in order to recognize $a$ with the grammar rule
      $a \rightarrow \beta T \gamma$, the parser only has to recognize $\gamma$ in the substring
      $x_{j+2} \cdots x_n$.  Hence, in this case we add the Earley object
      \\[0.2cm]
      \hspace*{1.3cm}
      $\pair(a \rightarrow \beta T \bullet \gamma, k)$
      \\[0.2cm]
      to the set $Q_{j+1}$:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\pair(a \rightarrow \beta \bullet T \gamma, k) \in Q_j \wedge x_{j+1} = T
       \;\Rightarrow\;
       Q_{j+1} := Q_{j+1} \cup \bigl\{ \pair(a \rightarrow \beta T \bullet \gamma, k) \bigr\}$.
\item \emph{Prediction}

      If the set $Q_j$ contains an Earley object of the form $\pair(a \rightarrow \beta \bullet c \delta, k)$
      such that $c$ is a variable, then the parser tries to recognize the substring $C\delta$ after having
      parsed the substring $x_{k+1} \cdots x_j$ as $\beta$.  Hence the parser now has to recognize the variable
      $c$.  Therefore, for every rule of the form $c \rightarrow \gamma$ that is contained in the grammar $G$
      the Earley object 
      $\pair(c \rightarrow \bullet \gamma, j)$ is added to the set $Q_j$:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\pair(a \rightarrow \beta \bullet c \delta, k) \in Q_j 
       \wedge (c \rightarrow \gamma) \in R 
       \;\Rightarrow\;
       Q_j := Q_j \cup\bigl\{ \pair(c \rightarrow \bullet\gamma, j)\bigr\}$.
\item \emph{Completion}

      If the set $Q_i$ contains an Earley object of the form $\pair(c \rightarrow \gamma \bullet, j)$
      and the set $Q_j$ contains an Earley object of the form 
      $\pair(a \rightarrow \beta \bullet c \delta,k)$, then the parser has tried to parse the variable $c$
      after it had read the substring $x_1\cdots x_{j}$ and after reading the substring $x_{j+1}\cdots x_i$
      it has recognized the variable $c$.
      Therefore, the Earley object
      $\pair(a \rightarrow \beta c \bullet \delta,k)$
      is now added to the set $Q_i$:
      \\[0.2cm]
      \hspace*{1.3cm}
      $\pair(c \rightarrow \gamma \bullet, j) \in Q_i \wedge
       \pair(a \rightarrow \beta \bullet c \delta,k) \in Q_j \;\Rightarrow\;
       Q_i := Q_i \cup \bigl\{ \pair(a \rightarrow \beta c \bullet \delta,k) \bigr\}
      $.
\end{enumerate}
When trying to parse the string $w = x_1 \cdots x_n$ with the grammar
$G = \langle V, \Sigma, R, s \rangle$ Earley's algorithm works as follows:
\begin{enumerate}
\item The sets  $Q_i$ are initiallized as follows:
      \\[0.2cm]
      \hspace*{1.3cm}
      $Q_0 := \bigl\{ \pair(\widehat{s} \rightarrow \bullet s, 0) \bigr\}$,
      \\[0.2cm]
      \hspace*{1.3cm}
      $Q_i := \bigl\{ \bigr\}$ \quad for $i=1,\cdots,n$.
\item After that we iterate from $i=0$ to $i=n$ and perform the following operations:
      \begin{enumerate}[(a)]
      \item The set $Q_i$ is enlarged using \blue{completion} until we find no further
            Earley objects.
      \item Next we use prediction to enlarge the set $Q_i$.
            Again, this operation is performed until no new Earley objects are found.
      \item If $i < n$, we read the next token and use it to initiallize $Q_{i+1}$.
      \end{enumerate}
      If the grammar $G$ has  $\lambda$-rules, i.e.~if it has rules with empty right hand side of the form
      \\[0.2cm]
      \hspace*{1.3cm}
      $c \rightarrow \lambda$,
      \\[0.2cm]
      then it might happen that after applying prediction in the set $Q_i$ we can afterwards immediately apply
      completion in $Q_i$.  In this case prediction and completion have to be iterated until no further Earley
      objects are generated for $Q_i$.
\item If after termination of the algorithm the set  $Q_n$ contains the Earley object
      $\pair(\widehat{s} \rightarrow s \bullet,0)$, then parsing is successfull and we have shown that
      the string $w = x_1 \cdots x_n$ is an element of $L(G)$.
\end{enumerate}
  
\exampleEng
Figure \ref{fig:expr-small} shows a simplified grammar for arithmetic expressions, consisting only of the
numbers “1”, “2”, and “3” and the two operator symbols “\texttt{+}” and “\texttt{*}”. The set $T$ of terminals
for this grammar is therefore given by
\\[0.2cm]
\hspace*{1.3cm}
 $T = \{ \quoted{1}, \quoted{2}, \quoted{3}, \quoted{+}, \quoted{*} \}$.
\\[0.2cm]
We demonstrate how the string “\texttt{1+2*3}” can be parsed using this grammar and Earley’s algorithm. In the
following representation, we will abbreviate the syntactic variable \texttt{expr} with the letter $e$, write 
$p$ for \texttt{prod}, and use $f$ as an abbreviation for \texttt{fact}. 

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    expr : expr '+' prod
         | prod
         ;
    
    prod : prod '*' fact
         | fact
         ;
    
    fact : '1'
         | '2'
         | '3'
         ;
\end{Verbatim}
\vspace*{-0.3cm}
  \caption{A simplified grammar for arithmetic expressions.}
  \label{fig:expr-small} 
\end{figure}


\begin{enumerate}
\item We initialize $Q_0$ as
      \\[0.2cm]
      \hspace*{1.3cm}
      $Q_0 = \{ \pair(\widehat{s} \rightarrow \bullet\, e, 0) \}$. 
      \\[0.2cm]
      The set $Q_1$, $Q_2$, $Q_3$, $Q_4$ und $Q_5$ are initially empty,  If we apply the completion operation
      to the set $Q_0$, we find no new Earley objects.

      Next, we apply the prediction operation to the Earley object  
      $\pair(\widehat{s} \rightarrow \bullet\, e, 0)$. This initially adds the following two Earley objects to
      the set $Q_0$: 
      \[
        \pair(e \rightarrow \bullet\; e \squoted{+} p, 0) 
        \quad \text{and} \quad 
        \pair(e \rightarrow \bullet\; p, 0)
      \]  
      We can apply the prediction operation once more to the Earley object $\pair(e \rightarrow \bullet\, p, 0)$,
      which results in two new Earley objects:   
      \[
        \pair(p \rightarrow \bullet\; p \squoted{*} f, 0) 
        \quad \text{and} \quad 
        \pair(p \rightarrow \bullet\; f, 0)
      \]  
      Applying the prediction operation to the Earley object $\pair(p \rightarrow \bullet\; f, 0)$, we finally
      add the following Earley objects to $Q_0$:   
      \[
        \pair(f \rightarrow \bullet \squoted{1}, 0), \quad 
        \pair(f \rightarrow \bullet \squoted{2}, 0), \quad \text{and} \quad 
        \pair(f \rightarrow \bullet \squoted{3}, 0)
      \]  
      In total, $Q_0$ now contains the following Earley objects:  
      \begin{enumerate}
      \item $\pair(\widehat{s} \rightarrow \bullet\; e, 0)$,
      \item $\pair(e \rightarrow \bullet\; e \squoted{+} p, 0)$,
      \item $\pair(e \rightarrow \bullet\; p, 0)$,
      \item $\pair(p \rightarrow \bullet\; p \squoted{*} f, 0)$,
      \item $\pair(p \rightarrow \bullet\; f, 0)$,
      \item $\pair(f \rightarrow \bullet \squoted{1}, 0)$,
      \item $\pair(f \rightarrow \bullet \squoted{2}, 0)$,
      \item $\pair(f \rightarrow \bullet \squoted{3}, 0)$.
      \end{enumerate}
      Next, we apply the scanning operation to $Q_0$. Since the first character of the string to be parsed is
      “1,” the set $Q_1$ takes the following form:   
      \[
        Q_1 = \bigl\{ \pair(f \rightarrow \squoted{1} \bullet, 0) \bigr\}
      \]
\item Now, we set $i = 1$ and first apply the completion operation to $Q_1$. Based on the Earley object
      $\pair(f \rightarrow \squoted{1} \bullet, 0)$ in $Q_1$, we look for an Earley object in $Q_0$ where the marker
      “$\bullet$” is positioned before the variable $F$. We find the Earley object   
       $\pair(p \rightarrow \bullet\; f, 0)$. Therefore, we add the following Earley object to $Q_1$:   
       \[
         \pair(p \rightarrow f \;\bullet, 0)
       \]  
       We can then apply the completion operation again. After repeated applications, $Q_1$ contains the
       following Earley objects:  
       \begin{enumerate}
       \item $\pair(p \rightarrow f \;\bullet, 0)$, 
       \item $\pair(p \rightarrow p\;\bullet \squoted{*} f, 0)$, 
       \item $\pair(e \rightarrow p \; \bullet, 0)$,
       \item $\pair(e \rightarrow e\;\bullet \squoted{+} p, 0)$,
       \item $\pair(\widehat{s} \rightarrow e\;\bullet, 0)$.
       \end{enumerate}  
       Next, we apply the prediction operation to these Earley objects. However, since the marker “$\bullet$” in
       none of the Earley objects in $Q_i$ precedes a variable, no new Earley objects are generated.   

       Finally, we apply the scanning operation to $Q_1$. Since the character “\texttt{+}” is at position 2 in
       the string “\texttt{1+2*3}” and $Q_1$ contains the Earley object   
       \[
         \pair(e \rightarrow e\;\bullet \squoted{+} p, 0),
       \]  
       we add the following Earley object to $Q_2$:  
       \[
         \pair(e \rightarrow e \squoted{+}\bullet\; p, 0)
       \]  
\item Next, we set $i = 2$ and first apply the completion operation to $Q_2$. At this point, we have  
      \[
        Q_2 = \{ \pair(e \rightarrow e \squoted{+}\bullet\; p, 0) \}.
      \]  
      Since the marker “$\bullet$” in the only Earley object present here is not at the end of the grammar rule,
      the completion operation does not yield any new Earley objects in this step.   

      Next, we apply the prediction operation to $Q_2$. Since the marker precedes the variable $p$, we first
      find the following two Earley objects:   
      \[
        \pair(p \rightarrow \bullet\; f, 2) \quad \text{and} \quad \pair(p \rightarrow \bullet\; p \squoted{*} f, 2).
      \]  
      Since in the first Earley object the marker precedes the variable $f$, the prediction operation can be
      applied once more, yielding the following additional Earley objects:   
      \begin{enumerate}
      \item $\pair(f \rightarrow \bullet \squoted{1}, 2)$, 
      \item $\pair(f \rightarrow \bullet \squoted{2}, 2)$,
      \item $\pair(f \rightarrow \bullet \squoted{3}, 2)$.
      \end{enumerate}  
      Finally, we apply the scanning operation to $Q_2$. Since the third character of the string
      “\texttt{1+2*3}” is the digit “2,” $Q_3$ now takes the form   
      \[
        Q_3 = \{ \pair(f \rightarrow \squoted{2}\bullet, 2) \}.
      \]
\item We set $i = 3$ and apply the completion operation to $Q_3$. This adds  
      \[
        \pair(p \rightarrow f \;\bullet, 2)
      \]  
      to $Q_3$. Here, we can apply the completion operation once more. Through iterative application of the
      completion operation, we additionally obtain the following Earley objects:   
      \begin{enumerate}
      \item $\pair(p \rightarrow p \bullet \squoted{*} f, 2)$,
      \item $\pair(e \rightarrow e \squoted{+} p\;\bullet, 0)$,
      \item $\pair(e \rightarrow e\;\bullet \squoted{+} p, 0)$,
      \item $\pair(\widehat{s} \rightarrow e\;\bullet, 0)$.
      \end{enumerate}  
      Finally, we apply the scanning operation. Since the next character to be read is the symbol “\texttt{*},”
      we get   
      \[
        Q_4 = \{ \pair(p \rightarrow p \squoted{*} \bullet\, f, 2) \}.
      \] 
\item We set $i = 4$. The completion operation does not yield any new Earley objects. The prediction operation
      provides the following Earley objects:   
      \begin{enumerate}
      \item $\pair(f \rightarrow \bullet \squoted{1}, 4)$, 
      \item $\pair(f \rightarrow \bullet \squoted{2}, 4)$,
      \item $\pair(f \rightarrow \bullet \squoted{3}, 4)$.
      \end{enumerate}  
      Since the next character is the digit “3,” the scanning operation for $Q_5$ results in:  
      \[
        Q_5 = \{ \pair(f \rightarrow \squoted{3}\bullet, 4) \}.
      \]
\item We set $i = 5$. The completion operation sequentially provides the following Earley objects:
      \begin{enumerate}
      \item $\pair(p \rightarrow p \squoted{*} f\;\bullet, 2)$,
      \item $\pair(e \rightarrow e \squoted{+} p\;\bullet, 0)$,
      \item $\pair(p \rightarrow  p \;\bullet\squoted{*} f, 2)$,
      \item $\pair(e \rightarrow e \;\bullet\squoted{+} p, 0)$ 
      \item $\pair(\widehat{s} \rightarrow  e\;\bullet, 0)$.
      \end{enumerate}
\end{enumerate}
Since the set $Q_5$ contains the Earley object $\pair(\widehat{s} \rightarrow e\;\bullet, 0)$, we can conclude
that the string “\texttt{1+2*3}” indeed belongs to the language generated by the given grammar. 


\exerciseEng
Use Earley's algorithm to show that the string “\texttt{1*2+3}” belongs to the language of the grammar shown in Figure
\ref{fig:expr-small}. \eox


\section{Implementing Earley's Algorithm in \textsl{Python}}
The \textsl{Jupyter} notebook
\\[0.2cm]
\hspace*{-0.3cm}
\href{https://github.com/karlstroetmann/Formal-Languages/blob/master/ANTLR4-Python/Earley-Parser/Earley-Parser.ipynb}{https://github.com/karlstroetmann/Formal-Languages/blob/master/ANTLR4-Python/Earley-Parser/Earley-Parser.ipynb}
\\[0.2cm]
contains an implementation of Earley's algorithm.
\pagebreak

\section{Check Your Understandig}
\begin{enumerate}[(a)]
\item How is an Earley object defined, and how are the components of an Earley object interpreted?
\item How does the scanning operation work in Earley's algorithm?
\item How does the prediction operation work in Earley's algorithm?
\item How does the completion operation work in Earley's algorithm?
\item Outline Earley's algorithm for the case where the grammar contains no $\varepsilon$-rules.
\item What is the complexity of Earley's algorithm in the general case?
\item What is the complexity of Earley's algorithm in the case that the grammar is not ambiguous?
\end{enumerate}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "formal-languages"
%%% End: 
