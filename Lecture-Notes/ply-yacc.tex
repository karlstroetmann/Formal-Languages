\chapter{Using \textsc{Ply} as a Parser Generator  \label{chapter:ply}}
Most\footnote{The programming language \texttt{C++} is a noteable exception.} modern programming languages can
be parsed using an LALR-Parser.  As this lesson is based on the programming language \textsl{Python}, this
chapter discusses how the parser generator \href{https://www.dabeaz.com/ply/}{\textsc{Ply}} can be used to
generate a parser for any language that has an LALR grammar.  In Chapter \ref{chapter:ply-lex} we have already
seen how \textsc{Ply} can be used to generate a scanner.  This chapter focuses on the parser-generating aspect
of \textsc{Ply}.   If you haven't done so already, you can install \textsc{Ply} via \texttt{anaconda} as follows:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{conda install -c conda-forge ply}


\section{A Simple Example}
Figure \ref{fig:calculator.g} on page \pageref{fig:calculator.g} shows the grammar of a simple 
\blue{symbolic calculator}.  This grammar is similar to the grammar shown in Figure \ref{fig:Program.g4} on page
\pageref{fig:Program.g4} in Chapter \ref{chapter:antlr}. 

\begin{figure}[!ht]

  \begin{center}    
  \framebox{
  \framebox{
  \begin{minipage}[t]{9cm}
  \begin{eqnarray*}
  \textsl{stmnt}   & \rightarrow & \;\textsc{Identifier} \quoted{:=} \textsl{expr} \quoted{;}\\
                   & \mid        & \;\textsl{expr} \quoted{;}                   \\[0.2cm]
  \textsl{expr}    & \rightarrow & \;\textsl{expr} \quoted{+} \textsl{product}  \\
                   & \mid        & \;\textsl{expr} \quoted{-} \textsl{product}  \\
                   & \mid        & \;\textsl{product}                           \\[0.2cm]
  \textsl{product} & \rightarrow & \;\textsl{product} \quoted{*} \textsl{factor}\\
                   & \mid        & \;\textsl{product} \quoted{/} \textsl{factor}\\
                   & \mid        & \;\textsl{factor}                            \\[0.2cm]
  \textsl{factor}  & \rightarrow &   \quoted{(} \textsl{expr} \quoted{)}        \\
                   & \mid        & \;\textsc{Number}                            \\
                   & \mid        & \;\textsc{Identifier}                        
  \end{eqnarray*}
  \vspace*{-0.5cm}
  \end{minipage}}}
  \end{center}
  \caption{A grammar for a symbolic calculator.}
  \label{fig:calculator.g}
\end{figure}

In order to generate a symbolic calculator that is based on this grammar we first need to implement a scanner.
Figure \ref{fig:Symbolic-Calculator.ipynb:lex} shows how to specify an appropriate scanner with \textsc{Ply}.
As we have discussed scanner generation with \textsc{Ply} at length in Chapter \ref{chapter:ply-lex} there is
no need for further discussions here.

\begin{figure}[!ht]
\centering
\begin{minted}[ frame        = lines, 
                framesep     = 0.3cm, 
                bgcolor      = sepia,
                numbers      = left,
                numbersep    = -0.2cm,
                xleftmargin  = 0.8cm,
                xrightmargin = 0.8cm,
              ]{python3}
    import ply.lex as lex
    
    tokens = [ 'NUMBER', 'IDENTIFIER', 'ASSIGN_OP' ]
    
    def t_NUMBER(t):
        r'0|[1-9][0-9]*(\.[0-9]+)?([eE][+-]?([1-9][0-9]*))?'
        t.value = float(t.value)
        return t
    
    def t_IDENTIFIER(t):
        r'[a-zA-Z][a-zA-Z0-9_]*'
        return t
    
    def t_ASSIGN_OP(t):
        r':='
        return t
    
    literals = ['+', '-', '*', '/', '(', ')', ';']
    
    t_ignore  = ' \t'
    
    def t_error(t):
        print(f"Illegal character '{t.value[0]}'")
        t.lexer.skip(1)
    
    lexer = lex.lex()
\end{minted}
\vspace*{-0.3cm}
\caption{A scanner for the symbolic calculator.}
\label{fig:Symbolic-Calculator.ipynb:lex}
\end{figure}

\begin{figure}[!ht]
\centering
\begin{minted}[ frame        = lines, 
                framesep     = 0.3cm, 
                bgcolor      = sepia,
                numbers      = left,
                numbersep    = -0.2cm,
                xleftmargin  = 0.8cm,
                xrightmargin = 0.8cm,
              ]{python3}
    import ply.yacc as yacc
    
    start = 'stmnt'
    
    def p_stmnt_assign(p):
        "stmnt : IDENTIFIER ASSIGN_OP expr ';'"
        Names2Values[p[1]] = p[3]
    
    def p_stmnt_expr(p):
        "stmnt : expr ';'"
        print(p[1])
    
    def p_expr_plus(p):
        "expr : expr '+' prod"
        p[0] = p[1] + p[3]
        
    def p_expr_minus(p):
        "expr : expr '-' prod"
        p[0] = p[1] - p[3]
        
    def p_expr_prod(p):
        "expr : prod"
        p[0] = p[1]
    
    def p_prod_mult(p):
        "prod : prod '*' factor"
        p[0] = p[1] * p[3]
        
    def p_prod_div(p):
        "prod : prod '/' factor"
        p[0] = p[1] / p[3]
        
    def p_prod_factor(p):
        "prod : factor"
        p[0] = p[1]
    
    def p_factor_group(p):
        "factor : '(' expr ')'"
        p[0] = p[2]
    
    def p_factor_number(p):
        "factor : NUMBER"
        p[0] = p[1]
    
    def p_factor_id(p):
        "factor : IDENTIFIER"
        p[0] = Names2Values.get(p[1], float('nan'))
\end{minted}
\vspace*{-0.3cm}
\caption{A scanner for the symbolic calculator, part 1.}
\label{fig:Symbolic-Calculator.ipynb:yacc}
\end{figure}

Figure \ref{fig:Symbolic-Calculator.ipynb:yacc} on page \pageref{fig:Symbolic-Calculator.ipynb:yacc} shows how the
grammar is implemented in \textsc{Ply}.  We discuss it line by line.
\begin{enumerate}
\item Line 1 imports the module \texttt{ply.yacc}.  This module contains the function \texttt{ply.yacc.yacc}
      which is responsible for computing the parse table. The name \blue{yacc} is a homage to the Unix tool
      \href{https://en.wikipedia.org/wiki/Yacc}{\textsc{Yacc}}, which is a popular parser generator for the language
      \texttt{C} and, furthermore, is part of the standard utilities of the Unix operating system.
\item Line 3 specifies that the syntactical variable \texttt{stmnt} is the \blue{start symbol} of the grammar.
\item Line 5 -- 7 define the function \texttt{p\_stmnt\_assign} which implements the grammar rule
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{stmnt} \rightarrow \textsc{Identifier} \quoted{:=} \textsl{expr}$.
      \\[0.2cm]
      Note that this grammar rule itself is represented by the \blue{document string} of the function
      \texttt{p\_stmnt\_assign}.  In general, if
      \\[0.2cm]
      \hspace*{1.3cm}
      $v \rightarrow \alpha$
      \\[0.2cm]
      is a grammar rule, then this grammar rule is represented by a function that has the name
      \texttt{p\_$v$\_$s$}.  Here, the prefix ``\texttt{p\_}'' specifies that the function implements 
      a grammar rule (the \texttt{p} is short for \blue{parser}), $v$ should\footnote{
        This is just a convention. Technically, $v$ can be any string that is a valid \textsl{Python}
        identifier.
      }
      be the name of the variable
      defined by this grammar rule, and $s$ is a string chosen by the user to distinguish between different
      grammar rules for the same variable.  Of course, $s$ has to be chosen in a way such that the string
      \texttt{p\_$v$\_$s$} is a legal \textsl{Python} identifier.

      The function always takes one argument \texttt{p}.  This argument is a sequence of objects that can be
      indexed with array notation. If the grammar rule defining $v$ has the form
      \\[0.2cm]
      \hspace*{1.3cm}
      $v \rightarrow X_1 \cdots X_n$,
      \\[0.2cm]
      then this sequence has a length of $n+1$.  If $X_i$ is a token, then \texttt{p[$i$]} is the property
      with name \texttt{value} that is associated with this token.  Often, this value is just a string, but it
      can also be a number.  If $X_i$ is a variable, then  \texttt{p[$i$]} is the value that is returned
      when $X_i$ is recognized.  The value associated with the variable $v$ is stored in the location
      \texttt{p[0]}.  In the grammar rule shown in line 5--7, we have not assigned any value to \texttt{p[0]} and
      therefore there is no value associated with the syntactical variable \texttt{stmnt} that is defined by
      this grammar rule.

      \underline{\textbf{Note:}} Line 6 shows how a grammar rule is represented for \textsc{Ply}.
      A grammar rule of the form 
      \\[0.2cm]
      \hspace*{1.3cm}
      $v \rightarrow X_1 \cdots X_n$
      \\[0.2cm]
      is represented as the string:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{"$v$ : $X_1$ $\cdots$ $X_n$"}
      \\[0.2cm]
      It is very \red{\underline{im}p\underline{ortant}} to note that the character ``\texttt{:}'' has to be
      surrounded by space characters.  Otherwise, the parser generator does not work but rather generates error
      messages that are difficult to understand. 

      The function \texttt{p\_stmnt\_assign} has the task of evaluating the expression that is on the right
      hand side of the assignment operator ``\texttt{:=}''.  The result of this evaluation is then stored in the
      dictionary \texttt{Names2Values}.  The key that is used is the name of the identifier to the left of the
      assignment operator.
\item The function in line 9 -- 11 implements the grammar rule
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{stmnt} \rightarrow \textsl{expr} \quoted{;}$.
      \\[0.2cm]
      The rule is implemented by evaluating the expression and then printing it.
\item The function \texttt{p\_expr\_plus} implements the grammar rule
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{expr} \rightarrow \textsl{expr} \quoted{+} \textsl{prod}$.
      \\[0.2cm]
      It is implemented by evaluating the expression to the left of the operator ``\texttt{+}'', which is
      stored in \texttt{p[1]}, and the product to the right of this operator, which is stored in \texttt{p[3]},
      and then adding the corresponding values.  Finally, the resulting sum is stored in \texttt{p[0]} so that
      it is available later as the value of the expression that has been parsed.

      The remaining functions are similar to the ones that are discussed above.
\end{enumerate}

\begin{figure}[!ht]
\centering
\begin{minted}[ frame        = lines, 
                framesep     = 0.3cm, 
                bgcolor      = sepia,
                numbers      = left,
                numbersep    = -0.2cm,
                xleftmargin  = 0.8cm,
                xrightmargin = 0.8cm,
              ]{python3}
    def p_error(p):
        if p:
            print(f'Syntax error at {p.value} in line {p.lexer.lineno}.')
        else:
            print('Syntax error at end of input.')
        
    parser = yacc.yacc(write_tables=False, debug=True)

    Names2Values = {}
    
    def main():
        while True:
            s = input('calc > ')
            if s == '':
                break
            yacc.parse(s)
\end{minted}
\vspace*{-0.3cm}
\caption{A scanner for the symbolic calculator, part 2.}
\label{fig:Symbolic-Calculator.ipynb:yacc2}
\end{figure}
\FloatBarrier

\noindent
Figure \ref{fig:Symbolic-Calculator.ipynb:yacc2} on page \pageref{fig:Symbolic-Calculator.ipynb:yacc2}
is discussed next.
\begin{enumerate}
\item Line 1 -- 7 shows the function \texttt{p\_error} which is used to print error messages in the case that
      the input can not be parsed because of a syntax error.  The argument \texttt{p} is the token $t$ that
      caused the entry $\texttt{action}(s, t)$ in the action table to be undefined.
      If the syntax error happens at the end of the input, \texttt{p} has the value \texttt{None}.

      In an industrial application, the parser would also print both the line and column numbers of the
      offending token, but in order to keep this example small, this is not done here.  The column number can
      be retrieved as the attribute \texttt{pl.lexer.lexpos}.
\item Line 7 generates the parser.
      \begin{enumerate}[(a)]
      \item The first argument \texttt{write\_tables} has to be set to \texttt{False} to prevent an
            obscure bug from happening.
      \item The argument \texttt{debug} has to be set to \texttt{True} if we want to dump the parse table
            to the disk.  The parse table is then written to the file \texttt{parser.out}.
      \end{enumerate}
\item Line 9 initializes the dictionary \texttt{Names2Values}.  For every identifier $x$ defined interactively,
      \texttt{Names2Values[$x$]} is the value associated with $x$.
\item The function \texttt{main} is used as a driver for the parser.  It reads a string \texttt{s}
      from the command line and tries to parse \texttt{s} using the function \texttt{yacc.parse}.
      The function \texttt{yacc.parse} is generated behind the scenes when the function \texttt{yacc.yacc} is
      invoked in line 7. 
\end{enumerate}


\section{Shift/Reduce and Reduce/Reduce Conflicts}
In this section we show how shift/reduce and reduce/reduce conflicts are dealt with in \textsc{Ply}.
Figure \ref{fig:Conflicts.ipynb} on page \pageref{fig:Conflicts.ipynb} shows a grammar for arithmetical
expressions that is ambiguous because it does not specify the precedence of the different arithmetical
operators.  


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                  commandchars  = \\\{\}
                ]
    expr : expr '+' expr
         | expr '-' expr
         | expr '*' expr
         | expr '/' expr
         | '(' expr ')'
         | NUMBER      
\end{Verbatim}
\vspace*{-0.3cm}
\caption{An ambiguous grammar for arithmetical expressions.}
\label{fig:Conflicts.ipynb}
\end{figure}
\FloatBarrier

\noindent
This grammar does not specify whether the string
\\[0.2cm]
\hspace*{1.3cm} 
``\texttt{1 + 2 * 3}'' \quad is interpreted as \quad  ``\texttt{(1 + 2) * 3}'' \quad or as \quad ``\texttt{1 +
  (2 * 3)}''. 
\\[0.2cm]
Since every LALR is unambiguous, but the grammar shown in Figure \ref{fig:Conflicts.ipynb} is ambiguous,  it
has to have shift/reduce or reduce/reduce conflicts.  This grammar is part of the jupyter notebook 
\\[0.2cm]
\hspace*{1.3cm}
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Ply/Conflicts.ipynb}{Formal-Languages/tree/master/Ply/Conflicts.ipynb}.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                  commandchars  = \\\{\}
                ]
    state 10
    
        (2) expr -> expr - expr .
        (1) expr -> expr . + expr
        (2) expr -> expr . - expr
        (3) expr -> expr . * expr
        (4) expr -> expr . / expr
    
      ! shift/reduce conflict for + resolved as shift
      ! shift/reduce conflict for - resolved as shift
      ! shift/reduce conflict for * resolved as shift
      ! shift/reduce conflict for / resolved as shift
        $end            reduce using rule 2 (expr -> expr - expr .)
        )               reduce using rule 2 (expr -> expr - expr .)
        +               shift and go to state 4
        -               shift and go to state 5
        *               shift and go to state 6
        /               shift and go to state 7
    
      ! +               [ reduce using rule 2 (expr -> expr - expr .) ]
      ! -               [ reduce using rule 2 (expr -> expr - expr .) ]
      ! *               [ reduce using rule 2 (expr -> expr - expr .) ]
      ! /               [ reduce using rule 2 (expr -> expr - expr .) ]
\end{Verbatim} 
\vspace*{-0.3cm}
\caption{An excerpt from the file \texttt{parse.out}.}
\label{fig:Conflicts.ipynb:state10}
\end{figure} %$

When we try to generate a parser for this grammar using \textsc{Ply}s \texttt{yacc} command we get the message
\\[0.2cm]
\hspace*{1.3cm}
\texttt{WARNING: 16 shift/reduce conflicts}.
\\[0.2cm]
The file \texttt{parser.out} that is generated by \textsc{Ply} shows how these conflicts are resolved.
This file contains the LALR states created by the parser generator and for every state the possible actions are
shown.  Given the grammar shown above, \textsc{Ply} creates 14 different states.  There are conflicts in 4 of
these states.  Figure \ref{fig:Conflicts.ipynb:state10} on page \pageref{fig:Conflicts.ipynb:state10} shows state
number 10 and its actions.   We see that there are 4 shift/reduce conflicts in this state.  Unfortunately,
\textsc{Ply} only prints the marked rules defining these states, but it does not show the follow sets of these
rules.  We see that \textsc{Ply} resolves all conflicts in favour of shifting.  The exclamation marks in the
beginning of the line 20 -- 23 are to be interpreted as negations and show those reduce actions that would have
been possible in state 10, but are discarded in favour of the shift actions shown in line 15 -- 18.
Of course, in this example the shift action in line 15 is wrong because then the string
\\[0.2cm]
\hspace*{1.3cm}
\texttt{1 - 2 + 3}
\\[0.2cm]
is interpreted as \texttt{1 - (2 + 3)} and not as \texttt{(1 - 2) + 3}.
\FloatBarrier


\section{Operator Precedence Declarations \label{section:operator-precedence}}
It is possible to resolve shift/reduce conflicts using \blue{operator precedence declarations}.
For the grammar shown previously we can add the following \blue{operator precedence declarations}:
\begin{verbatim}
    precedence = (
        ('left', '+', '-'),
        ('left', '*', '/') )
\end{verbatim}
This declaration specifies that the operators ``\texttt{+}'' and ``\texttt{-}'' have a lower precedence than
the operators  ``\texttt{*}'' and ``\texttt{/}''.  Furthermore, it specifies that all these operators associate
to the left.  Operators can also be specified as being \blue{right associative} using the keyword ``\texttt{right}''.
The jupyter notebook
\\[0.2cm]
\hspace*{1.3cm}
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Ply/Conflicts-Resolved.ipynb}{Formal-Languages/tree/master/Ply/Conflicts-Resolved.ipynb}.
\\[0.2cm]
shows how this precedence declaration is used.  When we run this notebook, \textsc{Ply} doesn't give us a
warning about any conflicts.  If we inspect the generated file \texttt{parse.out}, the action table for the
state number 10 has the form shown in Figure \ref{fig:Conflicts-Resolved.ipynb:state10} on page
\pageref{fig:Conflicts-Resolved.ipynb:state10}.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                  commandchars  = \\\{\}
                ]
    state 10
    
        (2) expr -> expr - expr .
        (1) expr -> expr . + expr
        (2) expr -> expr . - expr
        (3) expr -> expr . * expr
        (4) expr -> expr . / expr
    
        +               reduce using rule 2 (expr -> expr - expr .)
        -               reduce using rule 2 (expr -> expr - expr .)
        $end            reduce using rule 2 (expr -> expr - expr .)
        )               reduce using rule 2 (expr -> expr - expr .)
        *               shift and go to state 6
        /               shift and go to state 7
    
      ! *               [ reduce using rule 2 (expr -> expr - expr .) ]
      ! /               [ reduce using rule 2 (expr -> expr - expr .) ]
      ! +               [ shift and go to state 4 ]
      ! -               [ shift and go to state 5 ]
\end{Verbatim} 
\vspace*{-0.3cm}
\caption{An excerpt from the file \texttt{parse.out} when conflicts are resolved.}
\label{fig:Conflicts-Resolved.ipynb:state10}
\end{figure} %$

\begin{enumerate}
\item Since the operators ``\texttt{+}'' and ``\texttt{-}'' have the same precedence, we have 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{action}(\mathtt{state 10}, \squoted{+}) = 
       \langle \textsl{reduce}, \textsl{expr} \rightarrow \textsl{expr} \quoted{-} \textsl{expr} \rangle
      $
      \\[0.2cm]
      This way, the expression $1 - 2 + 3$ is parsed as $(1 - 2) + 3$ and not as $1 - (2 + 3)$ as it would if
      we would shift the operator ``\texttt{+}'' instead.
\item Since the operator ``\texttt{-}'' is left associative, we have 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{action}(\mathtt{state 10}, \squoted{-}) = 
       \langle \textsl{reduce}, \textsl{expr} \rightarrow \textsl{expr} \quoted{-} \textsl{expr} \rangle
      $
      \\[0.2cm]
      This way, the expression $1 - 2 - 3$ is parsed as $(1 - 2) - 3$.
\item Since the precedence of the operator ``\texttt{*}'' is higher than the precedence of the operator
      ``\texttt{-}'', we have  
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{action}(\mathtt{state 10}, \squoted{*}) = 
       \langle \textsl{shift}, \mathtt{state6} \rangle
      $
      \\[0.2cm]
      This way, the expression $1 - 2 * 3$ is parsed as $1 - (2 * 3)$.
\item Since the precedence of the operator ``\texttt{/}'' is higher than the precedence of the operator
      ``\texttt{-}'', we have  
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{action}(\mathtt{state 10}, \squoted{/}) = 
       \langle \textsl{shift}, \mathtt{state7} \rangle
      $
      \\[0.2cm]
      This way, the expression $1 - 2 / 3$ is parsed as $1 - (2 / 3)$.
\end{enumerate}
\FloatBarrier

\noindent
Next, we explain in detail how \textsc{Ply} uses operator precedence relations to resolve shift/reduce conflicts.
\begin{enumerate}
\item First, \textsc{Ply} assigns a precedence level to every grammar rule.  This precedence level is the
      precedence level of the last operator symbol occurring in the grammar rule.  Most of the times, there is just
      one operator that determines the precedence of the grammar rule. 
      In the grammar at hand the precedences of the rules would be as shown in the table below. 
      \begin{center}
        \begin{tabular}[t]{|l|c|}
          \hline
          rule                          & precedence  \\
          \hline
          \hline
          $\textsl{expr} \rightarrow \textsl{expr} \quoted{+} \textsl{expr}$ & 1          \\
          \hline
          $\textsl{expr} \rightarrow \textsl{expr} \quoted{-} \textsl{expr}$ & 1          \\
          \hline
          $\textsl{expr} \rightarrow \textsl{expr} \quoted{*} \textsl{expr}$ & 2          \\
          \hline
          $\textsl{expr} \rightarrow \textsl{expr} \quoted{/} \textsl{expr}$ & 2          \\
          \hline
          $\textsl{expr} \rightarrow \quoted{(} \textsl{expr} \quoted{)}$ & --- \\
          \hline
          $\textsl{expr} \rightarrow \textsc{Number}$ & --- \\
          \hline
        \end{tabular}
      \end{center}

      If a grammar rule does not contain an operator that has been given a precedence, then the precedence of
      the grammar rule remains undefined.
\item If $s$ is a state that contains two e.m.R.s  $r_1$ and  $r_2$ such that
      \\[0.2cm]
      \hspace*{1.3cm}
      $r_1 = (a \rightarrow \beta \bullet o \;\delta:L_1)$ \quad and \quad
      $r_2 = (c \rightarrow \gamma \bullet : L_2)$ \quad where \quad $o \in L_2$,
      \\[0.2cm]
      then there is a shift/reduce conflict when 
      \\[0.2cm]
      \hspace*{1.3cm}
      $\textsl{action}(s, o)$
      \\[0.2cm]
      is computed. Let us assume that the precedence of the operator  $o$ is  $p(o)$
      and the precedence of the rule $r_2$ is  $p(r_2)$.  Then there are six cases that depend
      on the relative values of $p(o)$ and $p(r_2)$ and on the associativity of the operator $o$.
      \begin{enumerate}[(a)]
      \item $p(o) > p(r_2)$.
        
            In this case the precedence of the operator $o$ is higher than the precedence of the rule $r_2$.
            Therefore the operator $o$ is shifted:
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{action}(s,o) = \langle \texttt{shift}, \textsl{goto}(s,o) \rangle$.
            \\[0.2cm]
            To understand this rule we just have to watch what happens when we parse
            \\[0.2cm]
            \hspace*{1.3cm}
            $\texttt{1+2*3}$
            \\[0.2cm]
            using the grammar given above.
            After the part  ``\texttt{1+2}'' has been read and the next token is the operator ``\texttt{*}'',
            the parser is in the following state:
            \\[0.2cm]
            \hspace*{1.3cm}
            $ 
            \begin{array}[t]{llcll}
            \bigl\{ 
            & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{+} \textsl{expr}: \{\symbol{36},
                                            \squoted{+}, \squoted{-} \squoted{*}, \squoted{/} \}, 
            & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{-} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}  \},
              & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{*} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}  \},
              & \\ 
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{/} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}  \},
              & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \squoted{+} \textsl{expr} \;\bullet: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/} 
                                             \} 
            & \bigr\}.
            \end{array}
            $
            \\[0.2cm]
            When the parser next sees the token ``\texttt{*}'', then it must not reduce the symbol stack using
            the rule $\textsl{expr} \rightarrow \textsl{expr} \squoted{+} \textsl{expr}$, because it has to
            multiply the numbers $2$ and $3$ first.  Therefore, the token ``\texttt{*}'' has to be shifted.
      \item $p(o) < p(r_2)$.
            
            Now the precedence of the operator that occurs in the rule $r_2$ is higher than the precedence of
            the operator $o$.  Therefore the correct action is to reduce with the rule  $r_2$: 
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{action}(s,o) = \langle \texttt{reduce}, r_2 \rangle$.
            \\[0.2cm]
            To see that this makes sense we discuss the parsing of the expression
            \\[0.2cm]
            \hspace*{1.3cm}
            $\texttt{1*2+3}$
            \\[0.2cm]
            with the grammar given previously.
            Assume the string  ``\texttt{1*2}'' has already been read and the next token that is processed is
            the token ``\texttt{+}''.
            Then the state of the parser is as follows:
            \\[0.2cm]
            \hspace*{1.3cm}
            $ 
            \begin{array}[t]{llcll}
            \bigl\{ 
            & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{+} \textsl{expr}: \{\symbol{36},
                                            \squoted{+}, \squoted{-} \squoted{*}, \squoted{/} \}, 
            & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{-} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}  \},
              & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{*} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}  \},
              & \\ 
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{/} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}  \},
              & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \squoted{*} \textsl{expr} \;\bullet: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/} 
                                             \}
            & \bigr\}.
            \end{array}
            $
            \\[0.2cm]
            When the parser now sees the operator  ``\texttt{+}'', it has to reduce the string
            ``\texttt{1*2}'' using the rule
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{expr} \rightarrow \textsl{expr} \squoted{*} \textsl{expr}$,
            \\[0.2cm]
            as it has to multiply the numbers $1$ and $2$.  
      \item $p(o) = p(r_2)$ and the operator $o$ is left associative.
            
            Then we reduce the symbol stack with the rule $r_2$, we have 
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{action}(s,o) = \langle \texttt{reduce}, r_2 \rangle$.
            \\[0.2cm]
            To convince yourself that this is the right thing to do, inspect what happens
            when the string
            \\[0.2cm]
            \hspace*{1.3cm}
            $\texttt{1-2-3}$
            \\[0.2cm]
            is parsed with the grammar discussed previously.
            Assume that the string  ``\texttt{1-2}'' has already be read and the next token is the operator
            ``\texttt{-}''. Then the state of the parser is as follows:
            \\[0.2cm]
            \hspace*{1.3cm}
            $ 
            \begin{array}[t]{llcll}
            \bigl\{ 
            & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{+} \textsl{expr}: \{\symbol{36},
                                            \squoted{+}, \squoted{-} \squoted{*}, \squoted{/} \}, 
            & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{-} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}  \},
              & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{*} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}  \},
              & \\ 
              & \textsl{expr} & \rightarrow & \textsl{expr} \bullet \squoted{/} \textsl{expr}: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/}  \},
              & \\
              & \textsl{expr} & \rightarrow & \textsl{expr} \squoted{-} \textsl{expr} \;\bullet: \{\symbol{36},
                                              \squoted{+}, \squoted{-} \squoted{*}, \squoted{/} 
                                             \}
            & \bigr\}.
            \end{array}
            $
            \\[0.2cm]
            If the next token is the operator ``\texttt{-}'', then the parser has to reduce
            the symbol stack using the rule 
            $\textsl{expr} \rightarrow \textsl{expr} \squoted{-} \textsl{expr}$ as it has to subtract $2$ from
            $1$.  If it would shift instead it would compute $1 - (2-3)$ instead of computing $(1-2)-3$.
      \item $p(o) = p(r_2)$ and the operator $o$ associates to the right.
            
            In this case the operator $o$ is shifted
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{action}(s,o) = \langle \texttt{shift}, \textsl{goto}(s,o) \rangle$.
            \\[0.2cm]
            In order to understand this case, parse the string 
            \\[0.2cm]
            \hspace*{1.3cm}
            $\texttt{2\symbol{94}3\symbol{94}4}$
            \\[0.2cm]
            with the grammar rules
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{expr} \rightarrow \textsl{expr} \,\texttt{\symbol{94}}\, \textsl{expr} \mid \textsc{Number}$.
            \\[0.2cm]
            Consider the situation when the string ``\texttt{1\symbol{94}2}'' has already been read and the
            next token is the exponentiation operator ``\texttt{\symbol{94}}''.
            The state of the parser is then as follows:
            \\[0.2cm]
            \hspace*{1.3cm}
            $\bigl\{ 
             \textsl{expr}  \rightarrow \textsl{expr} \bullet \quoted{\texttt{\symbol{94}}} \textsl{expr}:
             \{\symbol{36},\quoted{\texttt{\symbol{94}}} \},\;  \textsl{expr} \rightarrow  \textsl{expr}
             \squoted{\texttt{\symbol{94}}} \textsl{expr} \;\bullet: \{\symbol{36},\quoted{\texttt{\symbol{94}}}\}
            \bigr\}.
            $
            \\[0.2cm]
            Here the token  \quoted{\texttt{\symbol{94}}} has to be shifted
            since we first have to compute the expression ``$3 \texttt{\symbol{94}} 4$''.
      \item $p(o) = p(r_2)$ and the operator $o$ has been declared to be non-associative.
            
            In this case we have a syntax error:
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{action}(s,o) = \textsl{error}$.
            \\[0.2cm]
            To understand this case, try to parse a string of the form
            \\[0.2cm]
            \hspace*{1.3cm}
            \texttt{1 < 1 < 1}
            \\[0.2cm]
            using the grammar rules
            \\[0.2cm]
            \hspace*{1.3cm}
            $\textsl{expr} \rightarrow \textsl{expr} \quoted{<} \textsl{expr} \mid \textsl{expr} \quoted{+} \textsl{expr} \mid \textsc{Number}$.
            \\[0.2cm]
            %$
            Once the string ``\texttt{1 < 1}'' has been read and the next token is the operator ``\texttt{<}''
            the parser recognizes that there is an error.  Therefore, \textsc{Ply} will resolve this
            shift/reduce conflict by putting an error entry into the action table.
      \item $p(o)$ is undefined or $p(r_2)$ is undefined.

            In this case there is a shift/reduce conflict and \textsc{Ply} prints a warning message when
            generating the parser.  The conflict is then resolved in favour of shifting.
      \end{enumerate}
\end{enumerate}


\section{Resolving Shift/Reduce and Reduce/Reduce Conflicts}
We start our discussion by categorizing conflicts with respect to their origin.
\begin{enumerate}
\item \emph{Mehrdeutigkeits-Konflikte} sind Konflikte, die ihre Ursache in einer Mehrdeutigkeit
      der zu Grunde liegenden Grammatik haben.  Solche Konflikte weisen damit auf ein tatsächliches
      Problem der Grammatik hin.  Wir hatten ein Beispiel für solche Konflikte gesehen, als wir in
      Abbildung \ref{fig:Conflicts.ipynb} 
      versucht hatten, die Syntax arithmetischer Ausdrücke ohne die syntaktischen
      Kategorien \textsl{product} und \textsl{factor} zu beschreiben.

      Wir hatten damals bereits gesehen, dass wir das Problem durch die Einführung von
      Operator-Präzedenzen lösen können.  Falls dies nicht möglich ist, dann bleibt nur das
      Umschreiben der Grammatik.
\item \emph{Look-Ahead-Konflikte} sind Reduce/Reduce-Konflikte, bei denen die Grammatik zwar
      einerseits eindeutig ist, für die aber andererseits
      ein Look-Ahead von einem Token nicht ausreichend ist um den Konflikt zu lösen.
\item \emph{Mysteriöse Konflikte} entstehen erst beim Übergang von den LR-Zuständen zu den LALR-Zuständen 
      durch das Zusammenfassen von Zuständen mit dem gleichen Kern.  Diese Konflikte treten also
      genau dann auf, wenn das Konzept einer LALR-Grammatik nicht ausreichend ist um die Syntax der
      zu parsenden Sprache zu beschreiben.
\end{enumerate}
Wir betrachten die letzten beiden Fälle nun im Detail und zeigen Wege auf, wie die Konflikte gelöst
werden können.

\subsection{Look-Ahead-Konflikte}
Ein Look-Ahead-Konflikt liegt dann vor, wenn die Grammatik zwar eindeutig ist, aber ein Look-Ahead von einem
Token nicht ausreicht um zu entscheiden,  mit welcher Regel reduziert werden soll.  Abbildung 
\ref{fig:lr-conflict.g} zeigt die Grammatik 
\href{https://github.com/karlstroetmann/Formal-Languages/blob/master/Ply/Look-Ahead.ipynb}{\texttt{Look-Ahead.ipynb}}\footnote{ 
Diese Grammatik habe ich im Netz auf der Seite von Pete Jinks unter der Adresse
\\[0.1cm]
\hspace*{1.3cm}
\href{http://www.cs.man.ac.uk/~pjj/cs212/ho/node19.html}{\texttt{http://www.cs.man.ac.uk/\symbol{126}pjj/cs212/ho/node19.html}}
\\[0.1cm]
gefunden.},
die zwar eindeutig ist, aber nicht die LR(1)-Eigenschaft hat und damit erst recht keine LALR(1) Grammatik ist.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    a : b 'U' 'V'
      | c 'U' 'W'
    b : 'X'
    c : 'X'   
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Eine eindeutige Grammatik ohne die LR(1)-Eigenschaft.}
\label{fig:lr-conflict.g}
\end{figure}


Berechnen wir die LR-Zustände dieser Grammatik,
so finden wir unter anderem den folgenden Zustand:
\\[0.2cm]
\hspace*{1.3cm}
$\{ b \rightarrow \;\squoted{X} \bullet: \squoted{U},\; c \rightarrow \;\squoted{X} \bullet: \squoted{U} \}$.
\\[0.2cm]
Da die Menge der Folge-Token für beide Regeln gleich sind, haben wir hier einen Reduce/Reduce-Konflikt.
Dieser Konflikt hat seine Ursache darin, dass der Parser mit einem Look-Ahead von nur einem Token nicht
entscheiden kann, ob ein $\squoted{X}$ als ein $b$ oder als ein $c$ zu interpretieren ist, denn dies
entscheidet sich erst, wenn das auf $\squoted{U}$ folgende Zeichen gelesen wird:  Handelt es sich hierbei
um ein $\squoted{V}$, so wird insgesamt die Regel
\\[0.2cm]
\hspace*{1.3cm}
$a \rightarrow b\; \squoted{U} \squoted{V}$
\\[0.2cm]
verwendet werden und folglich ist das $\squoted{X}$ als ein $b$ zu interpretieren. Ist das zweite Token
hinter dem $\squoted{X}$ hingegen ein  $\squoted{W}$, so ist die zu verwendende Regel
\\[0.2cm]
\hspace*{1.3cm}
$a \rightarrow c \;\squoted{U} \squoted{W}$
\\[0.2cm]
und folglich ist das $\quoted{X}$ als  $c$ zu lesen.


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    a : b 'V'
      | c 'W'
    b : 'X' 'U'
    c : 'X' 'U'
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Eine zu Abbildung \ref{fig:lr-conflict.g} äquivalente LR(1)-Grammatik.}
\label{fig:lr-conflict-resolved.g}
\end{figure}

Das Problem bei dieser Grammatik ist, dass sie versucht, abhängig vom Kontext ein $\squoted{X}$ wahlweise
als ein $b$ oder als ein $c$ zu interpretieren.  Es ist offensichtlich, wie das Problem gelöst werden
kann:  Wenn der Kontext ``\texttt{U}'', der sowohl auf $b$ als auch auf $c$ folgt, mit in
die Regeln für $b$ und $c$ aufgenommen wird, dann verschwindet der Konflikt, denn dann hat der
Zustand, in dem früher der Konflikt auftrat, die Form
\\[0.2cm]
\hspace*{1.3cm}
$\{ b \rightarrow \;\squoted{X} \squoted{U}\bullet: \squoted{V},\; 
    c \rightarrow \;\squoted{X} \squoted{U}\bullet: \squoted{W} 
\}
$.
\\[0.2cm]  
Hier entscheidet sich nun anhand des nächsten Tokens, mit welcher Regel wir in diesem Zustand
reduzieren müssen:  Ist das nächste Token ein $\squoted{V}$, so reduzieren wir mit der Regel
\\[0.2cm]
\hspace*{1.3cm}
$b \rightarrow \;\squoted{X} \squoted{U}$,
\\[0.2cm]
ist das nächste Token hingegen der Buchstabe $\squoted{W}$, so nehmen wir stattdessen die Regel
\\[0.2cm]
\hspace*{1.3cm}
$c \rightarrow \;\squoted{X} \squoted{U}\bullet: \squoted{W}$.
\\[0.2cm]
Abbildung
\ref{fig:lr-conflict-resolved.g} zeigt die entsprechend modifizierte Grammatik, die Sie unter
\\[0.2cm]
\hspace*{1.3cm}
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Ply/Look-Ahead-Solved.ipynb}{\texttt{github.com/karlstroetmann/Formal-Languages/tree/master/Ply/Look-Ahead-Solved.ipynb}}
\\[0.2cm]
im Netz finden.


\subsection{Mysterious Reduce/Reduce Conflicts}
A conflict is called a  \blue{mysterious reduce/reduce conflict} if the conflict results from the merger of
states that happens when we go from an LR parsing table to an LALR parsing table.  The grammar in Figure
\ref{fig:Mysterious-Conflicts.ipynb} on page \pageref{fig:Mysterious-Conflicts.ipynb} is the same as the
grammar shown in Figure \ref{fig:lr-but-notlalr.g} on page \pageref{fig:lr-but-notlalr.g} in the previous
chapter.  Then we had seen that this grammar is an LR grammar, but not an LALR grammar.  Let us see what happens
if we use \textsc{Ply} to generate the states for this grammar.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    s : 'v' a 'y'
      | 'w' b 'y'
      | 'v' b 'z'
      | 'w' a 'z'
      
    a : X
    
    b : X
\end{Verbatim}
\vspace*{-0.3cm}
\caption{A grammar that generates a mysterious reduce/reduce conflict.}
\label{fig:Mysterious-Conflicts.ipynb}
\end{figure}
\vspace*{0.3cm}

When we run \textsc{Ply} to produce the parsing table, we get the states shown in Figure
\ref{fig:Mysterious-Conflicts.parser.out} on page \pageref{fig:Mysterious-Conflicts.parser.out}.
This Figure only shows two states, \texttt{state 6} and \texttt{state 9}.  I have taken the liberty to annotate
the extended marked rules occurring in these states with their follow sets.  Taken by itself, none of these two
states has a conflict since the follow sets of the respective rules are disjoint.  However, 
it is obvious that these two states have the same core and should have been merged.  The resulting state would
have the form 
\\[0.2cm]
\hspace*{1.3cm}
$\bigl\{ a \rightarrow X \bullet:\{\saquoted{y}, \saquoted{z} \},
         b \rightarrow X \bullet:\{\saquoted{y}, \saquoted{z} \}
\bigr\}$
\\[0.2cm]
and obviously has a reduce/reduce conflict if the next token is either \saquoted{y} or \saquoted{z}.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    state 6
    
        (5) a -> X . : 'y'
        (6) b -> X . : 'z'
    
        y               reduce using rule 5 (a -> X .)
        z               reduce using rule 6 (b -> X .)

    state 9
    
        (6) b -> X . : 'y'
        (5) a -> X . : 'z'
    
        y               reduce using rule 6 (b -> X .)
        z               reduce using rule 5 (a -> X .)
\end{Verbatim}
\vspace*{-0.3cm}
\caption{A grammar that generates a mysterious reduce/reduce conflict.}
\label{fig:Mysterious-Conflicts.parser.out}
\end{figure}
\vspace*{0.3cm}

Interestingly, \textsc{Ply} does not merge these states and is therefore able to generate a parse table without
conflicts.  On the other hand, \textsc{Ply} claims to generate LALR tables.  Therefore, I have have written an
email to \href{https://en.wikipedia.org/wiki/David_M._Beazley}{David Beazley} asking whether this behaviour is
a feature or a bug.  He has classified this example as an ``\emph{interesting curiosity}''.

\exercise
Use \textsc{Ply} to implement a \textsl{Python} parser that is able to evaluate formulas from propositional logic.
The language should support the operators ``\texttt{\&}'' (conjunction), ``\texttt{|}'' (disjunction), and
``\texttt{!}'' (negation).  The operator ``\texttt{!}'' should bind stronger than the operator ``\texttt{\&}''
which in turn bind stronger than the operator ``\texttt{|}''.  Furthermore, the language should support the
assignment operator ``\texttt{:=}''.  \eox


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "formal-languages"
%%% End: 
