\section{SLR-Parser}
In this section, we demonstrate how to compute the functions 
\\[0.2cm]
\hspace*{1.3cm}
\(\textsl{action}: Q \times T \rightarrow \textsl{Action}\) \quad and \quad \(\textsl{goto}: Q \times V \rightarrow Q\)
\\[0.2cm]
that have been used in the last section to build a shift-reduce parser for a given context-free grammar \(G\).
For this purpose, we first clarify what information the states contained in the set \(Q\) should hold. We will
define these states in such a way that they contain information about which rule the shift-reduce parser is
attempting to apply, which part of the right hand side of a grammar rule has already been recognized, and what
are the symbols that are still expected. To this end, we define the concept of a \textcolor{blue}{marked rule}.
Unfortunately, the original English literature \cite{knuth:65} uses the rather meaningless term
``\textcolor{blue}{item}'' instead of the notion of a \emph{marked rule}. 

\begin{Definition}[Marked Rule]
  A \textcolor{blue}{marked rule} \index{marked rule} of a context-free grammar \(G = \langle V, T, R, s
  \rangle\) is a triple 
  \\[0.2cm]
  \hspace*{1.3cm}
  \(( a, \beta, \gamma )\),
  \\[0.2cm]
  such that
  \\[0.2cm]
  \hspace*{1.3cm}
  \((a \rightarrow \beta \gamma) \in R\).
  \\[0.2cm]
  A marked rule of the form \(\langle a, \beta, \gamma \rangle\) is written as
  \\[0.2cm]
  \hspace*{1.3cm}
  \(a \rightarrow \beta \bullet \gamma\). \eox
\end{Definition}

\noindent
The marked rule \(a \rightarrow \beta \bullet \gamma\) indicates that the parser is trying to parse an \(a\)
with the rule \(a \rightarrow \beta \gamma\), having already seen \(\beta\) and is next attempting to recognize
\(\gamma\). The symbol \(\bullet\) thus marks the part of the right side of the rule that we have
already read.  Now the idea is to represent the states of an SLR parser as \blue{sets of marked rules}. To illustrate
this idea, let's consider a specific example: we start with the grammar for arithmetic expressions shown in
Figure \ref{fig:Expr.grammar} on page \pageref{fig:Expr.grammar}, extending this grammar by a new start symbol
\(\widehat{s}\) and the rule 
\\[0.2cm]
\hspace*{1.3cm} \(\widehat{s} \rightarrow  \textsl{expr}\;\symbol{36}\)
\\[0.2cm]
where the symbol ``$\symbol{36}$'' is used to denote \textsc{Eof}, i.e.~the end of the input.
The start state clearly contains the marked rule
\\[0.2cm]
\hspace*{1.3cm} \(\widehat{s} \rightarrow \lambda \bullet \textsl{expr}\; \symbol{36}\),
\\[0.2cm]
since at the beginning we are trying to derive the start symbol \(\widehat{s}\).
The component \(\lambda\) indicates that we have not yet processed anything. In addition to this marked rule, the start state must also contain the marked rules
\begin{enumerate}
\item \(\textsl{expr} \rightarrow \lambda \bullet \textsl{expr} \aquoted{+} \textsl{product}\),
\item \(\textsl{expr} \rightarrow \lambda \bullet \textsl{expr} \aquoted{-} \textsl{product}\) \qquad and
\item \(\textsl{expr} \rightarrow \lambda \bullet \textsl{product}\)
\end{enumerate}
because, for example, it may be necessary to use the rule
\\[0.2cm]
\hspace*{1.3cm}
\(\textsl{expr} \rightarrow \textsl{expr} \aquoted{+} \textsl{product}\)
\\[0.2cm]  
to derive the sought \textsl{expr}. Similarly, it could be that instead we need to use the rule
\\[0.2cm]
\hspace*{1.3cm}
\(\textsl{expr} \rightarrow \textsl{product}\)
\\[0.2cm]
This explains why we must include the marked rule
\\[0.2cm]
\hspace*{1.3cm}
 \(\textsl{expr} \rightarrow \lambda \bullet \textsl{product}\)
\\[0.2cm]
in the start state, because at the beginning we cannot yet know which rule we will need, so the start state must contain all these rules. Once we have added the marked rule
\\[0.2cm]
\hspace*{1.3cm}
 \(\textsl{expr} \rightarrow \lambda \bullet \textsl{product}\) 
\\[0.2cm]
to the start state, we see that we might need to read a \textsl{product} next. Therefore, the start state also contains the following marked rules:  
\begin{enumerate}
\item[4.] \(\textsl{product} \rightarrow \bullet\; \textsl{product} \aquoted{*} \textsl{factor}\),
\item[5.] \(\textsl{product} \rightarrow \bullet\; \textsl{product} \aquoted{/} \textsl{factor}\),
\item[6.] \(\textsl{product} \rightarrow \bullet\; \textsl{factor}\),

      Now, the sixth rule indicates that we might first read a \textsl{factor}. Therefore, we add the following two marked rules to the start state: 
\item[7.] \(\textsl{factor} \rightarrow \bullet \aquoted{(} \textsl{expr} \aquoted{)}\),
\item[8.] \(\textsl{factor} \rightarrow \bullet\; \textsc{Number}\).
\end{enumerate}
Overall, we see that the start state consists of a set of 8 marked rules.
The system shown above, for deriving further rules from a given rule,
is formalized in the concept of the \textcolor{blue}{closure} of a set of marked rules.

\begin{Definition}[\(\textsl{closure}(\mathcal{M})\)]
  Let \(\mathcal{M}\) be a set of marked rules. Then we define the \textcolor{blue}{closure} \index{closure of a set of marked rules} of this set as the smallest set \(\mathcal{K}\) of marked rules such that:
  \begin{enumerate}
  \item \(\mathcal{M} \subseteq \mathcal{K}\),

        i.e.~the closure includes the original set of rules.
  \item If on the one hand
        \\[0.2cm]
        \hspace*{1.3cm}
        \(a \rightarrow \beta \bullet c\, \delta\)
        \\[0.2cm]
        is a marked rule from the set \(\mathcal{K}\), where \(c\) is a syntactic variable, and on the other hand
        \\[0.2cm]
        \hspace*{1.3cm}
        \(c \rightarrow \gamma\)
        \\[0.2cm]
        is a grammar rule of the underlying grammar \(G\), then the marked rule 
        \\[0.2cm]
        \hspace*{1.3cm}
        \(c \rightarrow \bullet \gamma\)
        \\[0.2cm]
        is also an element of the set \(\mathcal{K}\). Formally, this is written as follows:
        \\[0.2cm]
        \hspace*{1.3cm}
        \((a \rightarrow \beta \bullet c\, \delta) \in \mathcal{K} 
         \;\wedge\; 
         (c \rightarrow \gamma) \in R
         \;\Rightarrow\; (c \rightarrow \bullet \gamma) \in \mathcal{K}
        \)
  \end{enumerate}
  The set \(\mathcal{K}\) defined in this way is uniquely determined and is referred to as \(\textsl{closure}(\mathcal{M})\) \index{\(\textsl{closure}(\mathcal{M})\)} in the following. \eox
\end{Definition}

\noindent
\textbf{Remark}: If you recall the Earley algorithm, you will notice that the calculation of the closure is the
same as the \emph{prediction operation} in the Earley algorithm. \eox 
\vspace*{0.3cm}

\noindent
For a given set \(\mathcal{M}\) of marked rules, the computation of \(\mathcal{K} := \textsl{closure}(\mathcal{M})\) can be done iteratively:
\begin{enumerate}
\item Initially, set \(\mathcal{K} := \mathcal{M}\).
\item Then, find all rules of the form
      \\[0.2cm]
      \hspace*{1.3cm}
      \(a \rightarrow \beta \bullet c\, \delta\)
      \\[0.2cm]
      within the set \(\mathcal{K}\), where \(c\) is a syntactic variable. Subsequently, for all rules of the form \(c \rightarrow \gamma\), add the new marked rule
      \\[0.2cm]
      \hspace*{1.3cm}
      \(c \rightarrow \bullet\gamma\)
      \\[0.2cm]
      into the set \(\mathcal{K}\). Repeat this step until no new rules are found.
\end{enumerate}

\example
Starting from the grammar for arithmetic expressions shown in Figure \ref{fig:Expr.grammar} on page \pageref{fig:Expr.grammar}, let's consider the set
\[ \mathcal{M} := 
   \bigl\{ \textsl{product} \rightarrow \textsl{product} \aquoted{*}\! \bullet \textsl{factor} \bigr\}
\]
For the set \(\textsl{closure}(\mathcal{M})\), we then find
\\[0.2cm]
\hspace*{1.3cm}
$ 
\begin{array}[b]{lcll}
\textsl{closure}(\mathcal{M}) 
 & = & \bigl\{ &
         \textsl{product} \rightarrow \textsl{product} \aquoted{*}\! \bullet \textsl{factor}, \\
   & & & \textsl{factor}  \rightarrow \bullet \aquoted{(} \textsl{expr} \aquoted{)}\!\!,          \\
   & & & \textsl{factor}  \rightarrow \bullet \;\textsc{Number}                                  \\
   & & \bigr\}. & \hspace*{8cm} 
\end{array}$  \eox
\vspace*{0.3cm}

\noindent
Our goal is to define a Shift-Reduce-Parser
\\[0.2cm]
\hspace*{1.3cm}
\(P = \langle Q, q_0, \textsl{action}, \textsl{goto} \rangle\)
\\[0.2cm]
for a given context-free grammar \(G = \langle V, T, R, s \rangle\). To achieve this goal, we first need to
determine how to define the states in the set \(Q\), as this will almost automatically define the remaining
components. As mentioned earlier, we define the states as sets of marked rules. Let's first define 
\\[0.2cm]
\hspace*{1.3cm}
\(\Gamma := \bigl\{ a \rightarrow \beta \bullet \gamma \mid (a \rightarrow \beta \gamma) \in R \bigr\}\)
\\[0.2cm]
as the set of all marked rules of the grammar. However, it is not sensible to allow arbitrary subsets of
\(\Gamma\) as states: A subset \(\mathcal{M} \subseteq \Gamma\) is only considered as a state if the set
\(\mathcal{M}\) is \blue{closed} under the function \(\textsl{closure}()\), meaning
\(\textsl{closure}(\mathcal{M}) = \mathcal{M}\). Therefore, we define 
\\[0.2cm]
\hspace*{1.3cm}
\(Q := \bigl\{ \mathcal{M} \in 2^\Gamma \mid \textsl{closure}(\mathcal{M}) = \mathcal{M} \bigr\}\).
\\[0.2cm]
The interpretation of the sets \(\mathcal{M} \in Q\) is that a state \(\mathcal{M}\) contains exactly those
marked rules that can be applied in the situation described by the state. 

To simplify the following constructions, we extend the
grammar \(G = \langle V, T, R, s \rangle\) by introducing a new start symbol \(\widehat{s}\)
and a new token \(\symbol{36}\) to the grammar
\\[0.2cm]
\hspace*{1.3cm}
\(\widehat{G} = 
 \Bigl\langle V \cup \{ \widehat{s} \}, T \cup \{\symbol{36}\}, R \cup \{ \widehat{s} \rightarrow s\, \symbol{36} \}, \widehat{s} \Bigr\rangle
\).
\\[0.2cm]
The token \(\symbol{36}\) represents the end of the input.
We refer to the grammar \(\widehat{G}\) as the \blue{augmented grammar}.\index{augmented grammar}
The use of the augmented grammar enables the following definition of the start state.
We set:
\\[0.2cm]
\hspace*{1.3cm}
\( q_0 := \textsl{closure}\Bigl( \bigl\{ \widehat{s} \rightarrow \bullet s\,\symbol{36} \bigr\} \Bigr)\).
\\[0.2cm]
Next, we construct the function \(\textsl{goto}()\). The definition is as follows:
\\[0.2cm]
\hspace*{1.3cm}
\(\textsl{goto}(\mathcal{M}, c) := \textsl{closure}\Bigl( \bigl\{ 
   a \rightarrow \beta\, c \bullet \delta \mid (a \rightarrow \beta \bullet c\, \delta) \in \mathcal{M} 
   \bigr\} \Bigr)
\).
\\[0.2cm]
To understand this definition, assume that the parser is in a state where it
tries to parse an \(a\) using the rule \(a \rightarrow \beta\, c\, \delta\) and that the substring \(\beta\) has already been recognized. This state is described by the marked rule
\\[0.2cm]
\hspace*{1.3cm}
\(a \rightarrow \beta \bullet c\, \delta\)
\\[0.2cm]
If a \(c\) is now recognized, the parser can transition from the state containing the
rule \(a \rightarrow \beta \bullet c\, \delta\) to a state containing the rule
\(a \rightarrow \beta\, c \bullet \delta\).
Therefore, we get the above definition of the function \(\textsl{goto}(\mathcal{M},c)\).
For the subsequent definition of the function \(\textsl{action}(\mathcal{M}, t)\), it is
useful to extend the definition of the function \(\textsl{goto}\) to terminals.
For terminals \(t \in T\) we set:
\\[0.2cm]
\hspace*{1.3cm}
\(\textsl{goto}(\mathcal{M}, t) := \textsl{closure}\Bigl( \bigl\{ 
   a \rightarrow \beta\, t \bullet \delta \mid (a \rightarrow \beta \bullet t\, \delta) \in \mathcal{M} 
   \bigr\} \Bigr)
\).
\\[0.2cm]
Before we can compute the function \textsl{action}, we need to define two more functions, 
the functions \textsl{First} and \textsl{Follow}.

\subsection{The Functions \textsl{First} and \textsl{Follow}}
In this section, we define the two functions \textsl{First} and \textsl{Follow}. These functions
are needed to compute the function \textsl{action}.
We consider a given context-free grammar \(G = \langle V, T, R, s \rangle\).
\begin{enumerate}[(a)]
\item For a syntactic variable \(a\), \(\textsl{First}(a)\) calculates the set of all tokens with which a
      string \(w\) can begin, which is derived from the variable \(a\), for which \(a \Rightarrow_G^* w\) holds.
\item For a syntactic variable \(a\), \(\textsl{Follow}(a)\) calculates the set of tokens
      that can follow an \(a\) in a string derived from \(s\), i.e., \(t \in \textsl{Follow}(a)\)
      if there is a derivation of the following form:
      \\[0.2cm]
      \hspace*{1.3cm}
      \(s \Rightarrow_G^* \beta\, a\, t\, \gamma\).
      \\[0.2cm]
      Here, \(\beta\) and \(\gamma\) are strings consisting of tokens and variables, while \(t\) denotes a single token.
\end{enumerate}

\begin{Definition}[$\lambda$-generating]
Let \(G = \langle V, T, R, S \rangle\) be a context-free grammar and \(\textsl{a}\) be a
syntactic variable, i.e., \(\textsl{a} \in V\). The variable \(\textsl{a}\) is called 
\blue{$\lambda$-generating}\index{$\lambda$-generating} precisely when
\\[0.2cm]
\hspace*{1.3cm}
\(\textsl{a} \Rightarrow^* \lambda\)
\\[0.2cm]
holds, which means that the empty word can be derived from the variable \(\textsl{a}\). 
We write \(\textsl{nullable}(\textsl{a})\) if the variable \(\textsl{a}\) is $\lambda$-generating.
\eox
\end{Definition}

\examples
\begin{enumerate}[(a)]
\item In the grammar shown in Figure \ref{fig:Expr2} on page \pageref{fig:Expr2},
      the variables \textsl{exprRest} and \textsl{productRest} are \(\lambda\)-generating.
\item Now let's consider a less obvious example. Suppose the grammar \(G\)
      contains the following rules:
      \\[0.2cm]
      \hspace*{1.3cm}
      \(S \rightarrow \textsl{a} \; \textsl{b} \; \textsl{c}\)
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{a} \rightarrow \aquoted{X} \textsl{b} \mid \textsl{a} \aquoted{Y} \mid \textsl{b}\;\textsl{c}\)
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{b} \rightarrow \aquoted{X} \textsl{b} \mid \textsl{a} \aquoted{Y} \mid \textsl{c}\;\textsl{c}\)
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{c} \rightarrow \textsl{a}\;\textsl{b}\; \textsl{c} \mid \lambda\)
      \\[0.2cm]
      Initially, it's clear that the variable \(\textsl{c}\) is \(\lambda\)-generating. Then, due to the rule
      \(\textsl{b} \rightarrow \textsl{c} \;\textsl{c}\), \(\textsl{b}\) is also \(\lambda\)-generating, and from the rule \(\textsl{a} \rightarrow \textsl{b}\;\textsl{c}\), \(\textsl{a}\) 
      becomes \(\lambda\)-generating as well. Finally, \(S\) is recognized as \(\lambda\)-generating,
      since the first rule states
      \\[0.2cm]
      \hspace*{1.3cm}
      \(S \rightarrow \textsl{a} \; \textsl{b} \; \textsl{c}\)
      \\[0.2cm]
      and here, all variables on the right side of the rule have already been proven to be
      \(\lambda\)-generating variables.
\end{enumerate}

\begin{Definition}[\(\textsl{First}()\)]
Let \(G = \langle V, T, R, s \rangle\) be a context-free grammar and \(\textsl{a} \in V\).
We define \(\textsl{First}(\textsl{a})\) as the set of all tokens \(t\) with which a
word derived from \(\textsl{a}\) can begin:
\\[0.2cm]
\hspace*{1.3cm}
\(\textsl{First}(\textsl{a}) := \{ t \in T \mid \exists \gamma \in (V \cup T)^*: \textsl{a} \Rightarrow^* t\,\gamma \}\).
\\[0.2cm]
The definition of the function \(\textsl{First}()\) can be extended to strings in \((V \cup T)^*\) as follows: 
\begin{enumerate}
\item \(\textsl{First}(\lambda) = \{\}\).
\item \(\textsl{First}(t \beta) = \{ t \}\) \quad if \(t \in T\).
\item \(\textsl{First}(\textsl{a} \beta) = \left\{
       \begin{array}[c]{ll}
         \textsl{First}(\textsl{a}) \cup \textsl{First}(\beta) & \mbox{if \(\textsl{a} \Rightarrow^* \lambda\);} \\
         \textsl{First}(\textsl{a})                            & \mbox{otherwise.}
       \end{array}
       \right.
      \) 
\end{enumerate}
If \(\textsl{a}\) is a variable of \(G\) and the rules defining \(\textsl{a}\) are given as 
\\[0.2cm]
\hspace*{1.3cm}
\(\textsl{a} \rightarrow \alpha_1 \mid \cdots \mid \alpha_n\),
\\[0.2cm]
then we have
\\[0.2cm]
\hspace*{1.3cm}
\(\textsl{First}(\textsl{a}) = \bigcup\limits_{i=1}^n \textsl{First}(\alpha_i)\).   \eox
\end{Definition}

\remarkEng
Note that the definitions of the function $\textsl{First}(\textsl{a})$ for variables
$\textsl{a} \in V$ and the function $\textsl{First}(\alpha)$ for strings $\alpha \in (V \cup T)^*$
are mutually recursive.  The computation of $\textsl{First}(\textsl{a})$ is best done via a 
fixpoint computation:  Start by setting $\textsl{First}(\textsl{a}) := \{\}$ for all variables $\textsl{a}\in V$ and
then continue to iterate the equations defining $\textsl{First}(\textsl{a})$ until none of the sets
$\textsl{First}(\textsl{a})$ changes any more.  The next example clarifies this idea.

\example
We can iteratively compute the sets \(\textsl{First}(\textsl{a})\) for the variables \(\textsl{a}\) of the grammar shown in Figure \ref{fig:Expr2}. It's best to compute the function \(\textsl{First}(\textsl{a})\) for the individual variables \(\textsl{a}\) starting with those at the bottom of the hierarchy.
\begin{enumerate}
\item First, the rules
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{factor} \rightarrow \aquoted{(} \textsl{expr} \aquoted{)} \mid \textsc{Number}\)
      \\[0.2cm]
      imply that every string derived from \textsl{factor} either starts with an opening
      parenthesis or a number:
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{First}(\textsl{factor}) = \{ \aquoted{(}, \textsc{Number}\; \}\).
\item Similarly, from the rules 
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{productRest} \rightarrow \aquoted{*} \textsl{factor}\;\;\textsl{productRest} \;
                            \mid        \aquoted{/} \textsl{factor}\;\;\textsl{productRest} \;
                            \mid        \lambda\)
      \\[0.2cm]
      we find that a \textsl{productRest} either starts with the character \qote{*} or \qote{/}:
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{First}(\textsl{productRest}) = \{ \aquoted{*}, \aquoted{/} \}\).
\item The rule for the variable \textsl{product} is
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{product} \rightarrow \textsl{factor}\;\;\textsl{productRest}\).
      \\[0.2cm]
      Since the variable \textsl{factor} is not \(\lambda\)-generating, we see that
      the set \(\textsl{First}(\textsl{product})\) matches the set
      \(\textsl{First}(\textsl{factor})\):
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{First}(\textsl{product}) = \{ \aquoted{(}, \textsc{Number}\; \}\).
\item From the rules
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{exprRest} \rightarrow \aquoted{+} \textsl{product}\;\;\textsl{exprRest} 
                         \mid        \aquoted{-} \textsl{product}\;\;\textsl{exprRest} 
                         \mid        \lambda\),
      \\[0.2cm]
      we can compute \(\textsl{First}(\textsl{exprRest})\) as follows:
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{First}(\textsl{exprRest}) = \{ \aquoted{+}, \aquoted{-} \}\).
\item Further, from the rule
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{expr} \rightarrow \textsl{product}\;\;\textsl{exprRest}\),
      \\[0.2cm]
      and the fact that the variable \(\textsl{product}\) is not \(\lambda\)-generating,
      the set \(\textsl{First}(\textsl{expr})\) matches the set
      \(\textsl{First}(\textsl{product})\):
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{First}(\textsl{expr}) = \{ \aquoted{(}, \textsc{Number}\; \}\).
\end{enumerate}
Since we have computed the sets \(\textsl{First}(\textsl{a})\) in a clever order, we did not have to perform a
proper fixpoint iteration in this example

\begin{Definition}[\(\textsl{Follow}()\)]
Let \(G = \langle V, T, R, s \rangle\) be a context-free grammar and \(\textsl{a} \in V\).
In computing \(\textsl{Follow}(\textsl{a})\), the grammar is first modified
by adding the symbol \(\$\) as a new symbol to the set \(T\) of terminals.  This symbols signifies the end of input.
To the variables, the new symbol \(\widehat{s}\) is added, which is also
the new start symbol of the grammar. To the set \(R\) of rules,
we add the following new rule:
\\[0.2cm]
\hspace*{1.3cm}
\(\widehat{s} \rightarrow s\; \$\).
\\[0.2cm]
Furthermore, we define
\\[0.2cm]
\hspace*{1.3cm}
 \(\widehat{T} := T \cup \{ \$ \}\).
\\[0.2cm]
We refer to the thus modified grammar \(\widehat{G} = \langle V, \widehat{T}, R, \widehat{s} \rangle\) as the
\textit{augmented} grammar. 
Then we define \(\textsl{Follow}(\textsl{a})\) as the set of all tokens \(t\) that can follow the variable \(\textsl{a}\) in a derivation:
\\[0.2cm]
\hspace*{1.3cm}
\(\textsl{Follow}(\textsl{a}) := 
 \bigl\{ t \in \widehat{T} \,\bigm|\, \exists \beta,\gamma \in (V \cup \widehat{T})^*: 
                           \widehat{s} \Rightarrow^* \beta \,\textsl{a}\, t\, \gamma 
  \bigr\}
\).
\\[0.2cm]
If the start symbol \(\widehat{s}\) can somehow derive a string \(\beta \,\textsl{a}\, t\,\gamma\) in which the
token \(t\) follows the variable \(\textsl{a}\), then \(t\) is an element of the set
\(\textsl{Follow}(\textsl{a})\). 
\eox
\end{Definition}

\example
Let's reexamine the grammar for arithmetic expressions shown in Figure \ref{fig:Expr2}.
\begin{enumerate}
\item Due to the newly added rule
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\widehat{S} \rightarrow \textsl{expr}\; \$\)
      \\[0.2cm]
      the set \(\textsl{Follow}(\textsl{expr})\) must contain the symbol \(\$\).
      Furthermore, due to the rule 
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{factor} \rightarrow \aquoted{(} \textsl{expr} \aquoted{)}\)
      \\[0.2cm]
      the set \(\textsl{Follow}(\textsl{expr})\) must also contain the symbol \aquoted{)}.
      Thus, we have in total
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{Follow}(\textsl{expr}) = \{ \$, \aquoted{)} \}\).
\item Due to the rule 
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{expr} \rightarrow \textsl{product}\;\;\textsl{exprRest}\)
      \\[0.2cm]      
      we know that all terminals that can follow an \textsl{expr} can also follow
      an \textsl{exprRest}. Thus, we already know that
      \(\textsl{Follow}(\textsl{exprRest})\) contains the tokens \(\$\) and \aquoted{)}.
      Since \textsl{exprRest} otherwise only appears at the end of its defining rules, these are all the tokens that can follow
      \textsl{exprRest}, and we have
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{Follow}(\textsl{exprRest}) = \{ \$, \aquoted{)} \}\).
\item The rules 
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{exprRest} \rightarrow \aquoted{+} \textsl{product}\;\;\textsl{exprRest} 
                         \mid        \aquoted{-} \textsl{product}\;\;\textsl{exprRest}\)
      \\[0.2cm]
      show that all elements from \(\textsl{First}(\textsl{exprRest})\)
      can follow a \textsl{product}. However, that's not all: since the variable \textsl{exprRest}
      is \(\lambda\)-generating, additionally, all tokens that can follow \textsl{exprRest} can also follow \textsl{product}. Thus, we have in total
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{Follow}(\textsl{product}) = 
      \{ \aquoted{+}, \aquoted{-}, \$, \aquoted{)} \}\).
\item The rule
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{product} \rightarrow \textsl{factor}\;\;\textsl{productRest}\)
      \\[0.2cm]      
      shows that all terminals that can follow a \textsl{product} can also follow
      a \textsl{productRest}.
      Since \textsl{productRest} otherwise only appears at the end of its defining rules, these are all the tokens that can follow
      \textsl{productRest}, and we have in total
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{Follow}(\textsl{productRest}) = \{ \aquoted{+}, \aquoted{-}, \$, \aquoted{)} \}\).
\item The rules 
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{productRest} \rightarrow \aquoted{*} \textsl{factor}\;\;\textsl{productRest} 
                            \mid        \aquoted{/} \textsl{factor}\;\;\textsl{productRest}\) 
      \\[0.2cm]
      show that all elements from \(\textsl{First}(\textsl{productRest})\)
      can follow a \textsl{factor}. However, that's not all: since the variable \textsl{productRest}
      is \(\lambda\)-generating, additionally, all tokens that can follow \textsl{productRest} can also follow \textsl{factor}. Thus, we have in total
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{Follow}(\textsl{factor}) = \{ \aquoted{*}, \aquoted{/}, \aquoted{+}, \aquoted{-}, \$, \aquoted{)} \}\).
      \eox
\end{enumerate}

\noindent
The last example demonstrates that the computation of the \(\textsl{nullable}()\) predicate and the computation of the sets \(\textsl{First}(\textsl{a})\) and \(\textsl{Follow}(\textsl{a})\) for a syntactic variable \(\textsl{a}\) are closely interconnected. Suppose we have a grammar rule:
\\[0.2cm]
\hspace*{1.3cm}
 \(\textsl{a} \rightarrow Y_1 Y_2 \cdots Y_k\)
\\[0.2cm]
Then the following relationships exist between the \(\textsl{nullable}()\) predicate and the \(\textsl{First}()\) and \(\textsl{Follow}()\) functions:
\begin{enumerate}
\item \(\forall t \in T: \neg\, \textsl{nullable}(t)\).
\item \(k = 0 \Rightarrow \textsl{nullable}(\textsl{a})\).
\item \(\bigl(\forall i \in \{1, \cdots, k\}: \textsl{nullable}(Y_i)\bigr) \Rightarrow
       \textsl{nullable}(\textsl{a})\).

      Setting \(k=0\) here, we see that 2.~is a special case of 3.
\item \(\textsl{First}(Y_1) \subseteq \textsl{First}(\textsl{a})\).
\item \(\bigl(\forall j \in \{1,\cdots,i-1\}: \textsl{nullable}(Y_j)\bigr) \Rightarrow
       \textsl{First}(Y_i) \subseteq \textsl{First}(\textsl{a})\).

       Setting \(i=1\) above, we see that 4.~is a special case of 5.
\item \(\textsl{Follow}(\textsl{a}) \subseteq \textsl{Follow}(Y_k)\).
\item \(\bigl(\forall j \in \{i+1, \cdots, k\}: \textsl{nullable}(Y_j)\bigr) \Rightarrow 
       \textsl{Follow}(\textsl{a}) \subseteq \textsl{Follow}(Y_i)\).

      Setting \(i=k\) here, we see that 6.~is a special case of 7.
\item \(\forall i \in \{1,\cdots,k-1\}:\textsl{First}(Y_{i+1}) \subseteq \textsl{Follow}(Y_i)\).
\item \(\bigl(\forall j \in \{i+1, \cdots, l-1\}: \textsl{nullable}(Y_j)\bigr) \Rightarrow 
       \textsl{First}(Y_l) \subseteq \textsl{Follow}(Y_i)\).

      Setting \(l=i+1\) here, we see that 8.~is a special case of 9.
\end{enumerate}
Using these relationships, \(\textsl{nullable}()\), \(\textsl{First}()\), and \(\textsl{Follow}()\) can be computed iteratively through a fixpoint iteration:
\begin{enumerate}
\item Initially, the functions \(\textsl{First}(\textsl{a})\) and \(\textsl{Follow}(\textsl{a})\) for each syntactic variable \(\textsl{a}\) are initialized with the empty set. The predicate \(\textsl{nullable}(\textsl{a})\) is set to \(\texttt{false}\) for each syntactic variable.
\item Subsequently, the rules outlined above are applied repeatedly until no further changes occur from their application.
\end{enumerate}

\subsection{Computing the Function \textsl{action}}
Finally, we specify how the function \(\textsl{action}(\mathcal{M},t)\) is computed for a set of marked rules \(\mathcal{M}\) and a token \(t\). When defining \(\textsl{action}(\mathcal{M},t)\), we distinguish four cases.
\begin{enumerate}
\item If \(\mathcal{M}\) contains a marked rule of the form \(a \rightarrow \beta \bullet t\, \delta\) and \(t \neq \symbol{36}\), then we set
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{action}(\mathcal{M},t) := \langle \texttt{shift}, \textsl{goto}(\mathcal{M},t) \rangle\),
      \\[0.2cm]
      because in this case the parser is trying to recognize an \(a\) using the rule \(a \rightarrow \beta\, t \delta\)
      and has already recognized \(\beta\). If the next token in the input string is indeed the token  
      \(t\), the parser can read this \(t\) and transitions from the state \(a \rightarrow \beta \bullet t\,
      \delta\) to the state  
      \(a \rightarrow \beta\, t \bullet \delta\), which is computed by the function \(\textsl{goto}(\mathcal{M},t)\). So, we have
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{action}(\mathcal{M},t) := \langle \texttt{shift}, \textsl{goto}(\mathcal{M},t) \rangle
         \quad \text{if} \quad (a \rightarrow \beta \bullet t\, \delta) \in \mathcal{M}
      \) and \(t \neq \symbol{36}\).
\item If \(\mathcal{M}\) contains a marked rule of the form \(a \rightarrow \beta \bullet\) and additionally \(t \in \textsl{Follow}(a)\), then we set
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{action}(\mathcal{M},t) := \langle \texttt{reduce}, a \rightarrow \beta \rangle\),
      \\[0.2cm]
      because in this case the parser is trying to recognize an \(a\) using the rule \(a \rightarrow \beta\)
      and has already recognized \(\beta\). If the next token in the input string is the token \(t\) and \(t\)
      is a token that can follow \(a\), i.e., \(t \in \textsl{Follow}(a)\), then the parser can apply the rule
      \(a \rightarrow \beta\) and reduce the symbol stack with this rule. Therefore, 
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{action}(\mathcal{M},t) := \langle \texttt{reduce}, a \rightarrow \beta \rangle\)
      \quad if 
      \((a \rightarrow \beta\bullet) \in \mathcal{M}\), \(a \neq \widehat{s}\) 
      and \(t \in \textsl{Follow}(a)\).
\item If \(\mathcal{M}\) contains the marked rule \(\widehat{s} \rightarrow s \bullet \symbol{36}\) and
      we have completely read the string to be parsed, we set
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{action}(\mathcal{M},\symbol{36}) := \texttt{accept}\),
      \\[0.2cm]
      because in this case the parser is trying to recognize \(\widehat{s}\) using the rule \(\widehat{s} \rightarrow s\,\symbol{36}\)
      and has already recognized \(s\). If the next token in the input string 
      is the end-of-file character \symbol{36}, 
      then the string being parsed belongs to the language specified by the grammar \(G\), 
      \(L(G)\). Therefore, we have
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{action}(\mathcal{M},\symbol{36}) := \texttt{accept}\),
      \quad if \((\widehat{s} \rightarrow s\bullet\symbol{36}) \in \mathcal{M}\).
\item In all other cases, we set
      \\[0.2cm]
      \hspace*{1.3cm}
      \(\textsl{action}(\mathcal{M},t) := \texttt{error}\).
\end{enumerate}
Conflicts can arise between the first two rules. We distinguish between two types of conflicts.
\begin{enumerate}
\item A \textsl{Shift-Reduce Conflict} occurs when both the first and second cases apply. In this situation,
      the set \(\mathcal{M}\) contains, on one hand, a marked rule of the form 
      \\[0.2cm]
      \hspace*{1.3cm}
      \(a \rightarrow \beta \bullet t\, \gamma\),
      \\[0.2cm]
      and on the other hand, \(\mathcal{M}\) contains a rule of the form
      \\[0.2cm]
      \hspace*{1.3cm}
      \(c \rightarrow \delta \bullet\) \quad with \(t \in \textsl{Follow}(c)\).
      \\[0.2cm]
      If the next token is \(t\), it is unclear whether this token should be pushed onto the symbol stack and
      the parser transition to a state with the marked rule  
      \(a \rightarrow \beta\, t \bullet \gamma\), or whether the symbol stack should be reduced using the rule
      \(c \rightarrow \delta\) instead. 
\item A \textsl{Reduce-Reduce Conflict} exists if the set \(\mathcal{M}\) contains two different marked rules of the form
      \\[0.2cm]
      \hspace*{1.3cm}
      \(c_1 \rightarrow \gamma_1 \bullet\) \quad  and \quad \(c_2 \rightarrow \gamma_2 \bullet\)
      \\[0.2cm]
      and if at the same time \(t \in \textsl{Follow}(c_1) \cap \textsl{Follow}(c_2)\), because then it is not clear which
      of the two rules the parser should apply when the next token to be read is \(t\).
\end{enumerate}

If either of these conflicts occurs, we say that the grammar is not an SLR grammar\index{SLR grammar}. Such a
grammar cannot be parsed using an SLR parser. We will later provide examples of both types of conflicts, but
first, we want to examine a grammar where no conflicts occur and actually compute the functions
\(\textsl{goto}()\) and \(\textsl{action}()\) for it. We use the grammar shown in Figure \ref{fig:Expr.grammar}
as a basis. 

Since the syntactic variable \textsl{expr} appears on the right side of grammar rules, we define \textsl{start}
as a new start symbol and add the rule 
\\[0.2cm]
\hspace*{1.3cm}
\(\textsl{start} \rightarrow \textsl{expr}\; \symbol{36}\)
\\[0.2cm]
to the grammar. This step corresponds to the previously discussed process of \textcolor{blue}{augmenting} the grammar.

First, we compute the set of states \(Q\). We had previously provided the following formula for this:
\\[0.2cm]
\hspace*{1.3cm}
\(Q := \bigl\{ \mathcal{M} \in 2^\Gamma \mid \textsl{closure}(\mathcal{M}) = \mathcal{M} \bigr\}\).
\\[0.2cm]
However, this set also contains states that cannot be reached from the start state via the function
\(\textsl{goto}()\). Therefore, we only compute the states that can actually be reached from the start state
using the function \(\textsl{goto}()\). To avoid making the calculation too complicated, we introduce the
following abbreviations: 
\\[0.2cm]
\hspace*{1.3cm}
\(s := \textsl{start},\; e := \textsl{expr},\; p := \textsl{product},\; 
   f := \textsl{factor}\) and \(N := \textsc{Number}\). 
\\[0.2cm]
We begin with the start state:
\begin{enumerate}
\item $ 
\begin{array}[t]{lcrl}
s_0 & := & \textsl{closure}\bigl(\{ & s \rightarrow \bullet\, e\, \symbol{36}\quad \}\bigr) \\
    &  = & \{ & s \rightarrow \bullet\, e \,\symbol{36},                \\[0.1cm]
    &    &    & e \rightarrow \bullet\, e \aquoted{+} p,\; 
                e \rightarrow \bullet\, e \aquoted{-} p,\;
                e \rightarrow \bullet\, p, \\[0.1cm]
    &    &    & p \rightarrow \bullet\, p \aquoted{*} f,\;
                p \rightarrow \bullet\, p \aquoted{/} f,\;
                p \rightarrow \bullet\, f,                \\[0.1cm]
    &    &    & f \rightarrow \bullet\, \saquoted{(} e \aquoted{)},\;
                f \rightarrow \bullet\, N   \hspace*{2.4cm} \}. 
\end{array}
$
\item$ 
\begin{array}[t]{lcl}
s_1 & := & \textsl{goto}(s_0, f ) \\
    &  = & \textsl{closure}(\{ p \rightarrow f \bullet \}) \\
    &  = & \{ p \rightarrow f \bullet \}. 
\end{array}
$
\item$ 
\begin{array}[t]{lcl}
s_2 & := & \textsl{goto}(s_0, N ) \\
    &  = & \textsl{closure}(\{ f \rightarrow N \bullet \}) \\
    &  = & \{ f \rightarrow N \bullet \}. 
\end{array}
$
\item$ 
\begin{array}[t]{lcl}
s_3 & := & \textsl{goto}(s_0, p ) \\
    &  = & \textsl{closure}(\{ p \rightarrow p \bullet \aquoted{*} f,\; 
                               p \rightarrow p \bullet \aquoted{/} f,\;
                               e \rightarrow p \bullet
                            \}) \\
    &  = & \{ p \rightarrow p \bullet \aquoted{*} f,\; p \rightarrow p \bullet \aquoted{/} f, e \rightarrow p \bullet \}. 
\end{array}
$
\item$ 
\begin{array}[t]{lcl}
s_4 & := & \textsl{goto}(s_0, e ) \\
    &  = & \textsl{closure}(\{ 
           s \rightarrow e \bullet\,\symbol{36},\;  
           e \rightarrow e \bullet \aquoted{+} p,\; 
           e \rightarrow e \bullet \aquoted{-} p\;
       \}) \\
    &  = & \{\;  s \rightarrow e \bullet\,\symbol{36},\;
                 e \rightarrow e \bullet \aquoted{+} p,\; 
                 e \rightarrow e \bullet \aquoted{-} p \; \}.
\end{array}
$
\item$ 
\begin{array}[t]{lcl}
s_5 & := & \textsl{goto}(s_0, \aquoted{(}) \\
    &  = & \textsl{closure}(\{ f \rightarrow \aquoted{(} \bullet e \aquoted{)} \}) \\
    &  = & \{\;\; f \rightarrow \aquoted{(} \bullet e \aquoted{)} \\[0.1cm]
    &    & \quad e \rightarrow \bullet\, e \aquoted{+} p,\; 
                 e \rightarrow \bullet\, e \aquoted{-} p,\;
                 e \rightarrow \bullet\, p,                  \\[0.1cm]
    &    & \quad p \rightarrow \bullet\, p \aquoted{*} f,\;
                 p \rightarrow \bullet\, p \aquoted{/} f,\;
                 p \rightarrow \bullet\, f,                \\[0.1cm]
    &    & \quad f \rightarrow \bullet\, \saquoted{(} e \aquoted{)},\;
                 f \rightarrow \bullet\, N   \hspace*{2.4cm} \}. 
\end{array}
$
\item $ 
\begin{array}[t]{lcl}
s_6 & := & \textsl{goto}(s_5, e) \\
    &  = & \textsl{closure}(\{\; 
                               f \rightarrow \aquoted{(} e \bullet \aquoted{)},\;
                               e \rightarrow e \bullet \aquoted{+} p,\; 
                               e \rightarrow e \bullet \aquoted{-} p\;
                            \}) \\
    &  = & \{\; 
                               f \rightarrow \aquoted{(} e \bullet \aquoted{)},\;
                               e \rightarrow e \bullet \aquoted{+} p,\; 
                               e \rightarrow e \bullet \aquoted{-} p.\;
           \}
\end{array}
$
\item $ 
\begin{array}[t]{lcl}
s_7 & := & \textsl{goto}(s_6, \aquoted{)}) \\
    &  = & \textsl{closure}(\{\; 
                               f \rightarrow \aquoted{(} e \aquoted{)} \bullet \;
                            \}) \\
    &  = & \{\; f \rightarrow \aquoted{(} e \aquoted{)} \bullet\; \}.
\end{array}
$
\item $ 
\begin{array}[t]{lcl}
s_8 & := & \textsl{goto}(s_4, \aquoted{+}) \\
    &  = & \textsl{closure}(\{ e \rightarrow e \aquoted{+} \bullet p \}) \\
    &  = & \{\;\; e \rightarrow e \aquoted{+} \bullet p  \\[0.1cm]
    &    & \quad p \rightarrow \bullet\, p \aquoted{*} f,\;
                 p \rightarrow \bullet\, p \aquoted{/} f,\;
                 p \rightarrow \bullet\, f,                \\[0.1cm]
    &    & \quad f \rightarrow \bullet\, \saquoted{(} e \aquoted{)},\;
                 f \rightarrow \bullet\, N   \hspace*{2.4cm} \}. 
\end{array}
$
\item $ 
\begin{array}[t]{lcl}
s_9 & := & \textsl{goto}(s_4, \aquoted{-}) \\
    &  = & \textsl{closure}(\{ e \rightarrow e \aquoted{-} \bullet p \}) \\
    &  = & \{\;\; e \rightarrow e \aquoted{-} \bullet p  \\[0.1cm]
    &    & \quad p \rightarrow \bullet\, p \aquoted{*} f,\;
                 p \rightarrow \bullet\, p \aquoted{/} f,\;
                 p \rightarrow \bullet\, f,                \\[0.1cm]
    &    & \quad f \rightarrow \bullet\, \saquoted{(} e \aquoted{)},\;
                 f \rightarrow \bullet\, N   \hspace*{2.4cm} \}. 
\end{array}
$
\item $ 
\begin{array}[t]{lcl}
s_{10} & := & \textsl{goto}(s_9, p) \\
    &  = & \textsl{closure}(\{ 
                  e \rightarrow e \aquoted{-} p \bullet,\;
                  p \rightarrow p \bullet \aquoted{*} f,\;
                  p \rightarrow p \bullet \aquoted{/} f \; \})
                  \\[0.1cm]
    &  = & \{\;\; e \rightarrow e \aquoted{-} p \bullet,\;
                  p \rightarrow p \bullet \aquoted{*} f,\;
                  p \rightarrow p \bullet \aquoted{/} f \; \}.
\end{array}
$
\item $ 
\begin{array}[t]{lcl}
s_{11} & := & \textsl{goto}(s_3, \aquoted{/}) \\
    &  = & \textsl{closure}(\{ 
                  p \rightarrow p \aquoted{/} \bullet f \; \})
                  \\[0.1cm]
    &  = & \{\;\;
                  p \rightarrow p \aquoted{/} \bullet f,\;
                  f \rightarrow \bullet\, \saquoted{(} e \aquoted{)}\!\!,\;
                  f \rightarrow \bullet\, N \; \}.
\end{array}
$
\item $ 
\begin{array}[t]{lcl}
s_{12} & := & \textsl{goto}(s_3, \aquoted{*}) \\
    &  = & \textsl{closure}(\{ 
                  p \rightarrow p \aquoted{*} \bullet f \; \})
                  \\[0.1cm]
    &  = & \{\;\;
                  p \rightarrow p \aquoted{*} \bullet f,\;
                  f \rightarrow \bullet\, \saquoted{(} e \aquoted{)}\!\!,\;
                  f \rightarrow \bullet\, N \; \}.
\end{array}
$
\item $ 
\begin{array}[t]{lcl}
s_{13} & := & \textsl{goto}(s_{12}, f) \\
    &  = & \textsl{closure}(\{ p \rightarrow p \aquoted{*} f \bullet \; \})
           \\[0.1cm]
    &  = & \{\;\;
                  p \rightarrow p \aquoted{*} f \bullet \; \}.
\end{array}
$
\item $ 
\begin{array}[t]{lcl}
s_{14} & := & \textsl{goto}(s_{11}, f) \\
    &  = & \textsl{closure}(\{ p \rightarrow p \aquoted{/} f \bullet \; \})
           \\[0.1cm]
    &  = & \{\;\;
                  p \rightarrow p \aquoted{/} f \bullet \; \}.
\end{array}
$
\item $ 
\begin{array}[t]{lcl}
s_{15} & := & \textsl{goto}(s_{8}, p) \\
    &  = & \textsl{closure}(\{ 
                 e \rightarrow e \aquoted{+} p \bullet,\;
                 p \rightarrow p \bullet \aquoted{*} f,\;
                 p \rightarrow p \bullet \aquoted{/} f \; \})
                  \\[0.1cm]
    &  = & \{\;\;
                  e \rightarrow e \aquoted{+} p \bullet,\;
                  p \rightarrow p \bullet \aquoted{*} f,\;
                  p \rightarrow p \bullet \aquoted{/} f \; \}.
\end{array}
$
\end{enumerate}
Further calculations do not yield any new states. For instance, when we compute \(\textsl{goto}(s_8,
\aquoted{()})\), we find: 
\\[0.2cm]
\hspace*{1.3cm}
$ 
\begin{array}{cl}
    & \textsl{goto}(s_8, \aquoted{(}) \\
  = & \textsl{closure}(\{ f \rightarrow \aquoted{(} \bullet e \aquoted{)} \}) \\
  = & \{\;\; f \rightarrow \aquoted{(} \bullet e \aquoted{)} \\[0.1cm]
    & \quad e \rightarrow \bullet\, e \aquoted{+} p,\; 
            e \rightarrow \bullet\, e \aquoted{-} p,\;
            e \rightarrow \bullet\, p,                  \\[0.1cm]
    & \quad p \rightarrow \bullet\, p \aquoted{*} f,\;
            p \rightarrow \bullet\, p \aquoted{/} f,\;
            p \rightarrow \bullet\, f,                \\[0.1cm]
    & \quad f \rightarrow \bullet\, \saquoted{(} e \aquoted{)},\;
            f \rightarrow \bullet\, N   \hspace*{2.4cm} \} \\[0.1cm]
  = & s_5.
\end{array}
$
\\[0.2cm]
Therefore, the set of states for the Shift-Reduce parser is given by
\\[0.2cm]
\hspace*{1.3cm}
\( Q := \{ s_0, s_1, s_2, s_3, s_4, s_5, s_6, s_7, s_8, s_9, s_{10}, s_{11}, s_{12}, s_{13}, s_{14}, s_{15} \} \)
\\[0.2cm]
Next, we investigate whether there are any conflicts, and we look specifically at the set \(s_{15}\). Due to
the marked rule  
\\[0.2cm]
\hspace*{1.3cm}
\( p \rightarrow p \bullet \aquoted{*} f \)
\\[0.2cm]
a shift must occur in state \(s_{15}\) if the next token is \(\aquoted{*}\). On the other hand, the state
\(s_{15}\) includes the rule 
\\[0.2cm]
\hspace*{1.3cm}
\( e \rightarrow e \aquoted{+} p \bullet. \)
\\[0.2cm]
This rule indicates that the symbol stack must be reduced with the grammar rule \(e \rightarrow e \aquoted{+}
p\) if a character from the set \(\textsl{Follow}(e)\) appears in the input. If \(\saquoted{*}\) were in
\(\textsl{Follow}(e)\), then we would have a Shift-Reduce conflict. However, 
\\[0.2cm]
\hspace*{1.3cm}
\( \textsl{Follow}(e) = \{ \aquoted{+}, \aquoted{-}, \aquoted{)} ,\aquoted{\symbol{36}} \} \),
\\[0.2cm]
and therefore \(\saquoted{*} \not\in \textsl{Follow}(e)\), so there is no Shift-Reduce conflict here. An
examination of the other sets shows that there are also no Shift-Reduce or Reduce-Reduce conflicts in any of them.

Next, we calculate the \(\textsl{action}\) function. We consider two cases as examples.
\begin{enumerate}
\item First, we compute \(\textsl{action}(s_1, \aquoted{+})\). It holds that
      \\[0.2cm]
      \hspace*{1.3cm}
      \( 
      \begin{array}[t]{lcl}
      \textsl{action}(s_1, \aquoted{+}) & = & 
            \textsl{action}(\{p \rightarrow f \bullet\}, \aquoted{+}) \\
      & = & \langle \textsl{reduce}, p \rightarrow f \rangle,
      \end{array}
      \)
\\[0.2cm]
      since we have \(\saquoted{+} \in \textsl{Follow}(p)\).
\item Next, we compute \(\textsl{action}(s_4, \aquoted{+})\). It holds that
      \\[0.2cm]
      \hspace*{1.3cm}
      \( 
      \begin{array}[t]{lcl}
      \textsl{action}(s_4, \aquoted{+}) & = & 
            \textsl{action}(\{ s \rightarrow e \bullet\,\symbol{36},\;
                 e \rightarrow e \bullet \aquoted{+} p,\; 
                 e \rightarrow e \bullet \aquoted{-} p \; \}, \aquoted{+}) \\
      & = & \langle \textsl{shift}, \textsl{closure}(\{ e \rightarrow e \aquoted{+} \bullet p\}) \rangle \\
      & = & \langle \textsl{shift}, s_8 \rangle.
      \end{array}
      \)
\\[0.2cm]
\end{enumerate}
If we were to continue these calculations, we would obtain Table \ref{tab:action}, as we have chosen the names
of the states to match those of the corresponding states in Tables \ref{tab:action} and \ref{tab:goto}. 

\exerciseEng
Figure \ref{fig:BoolExpr.grammar} shows a grammar for propositional formulas in conjunctive normal form.  
\begin{enumerate}[(a)]
\item Provide the sets \(\textsl{First}(v)\) for all syntactic variables \(v\).
\item Provide the sets \(\textsl{Follow}(v)\) for all syntactic variables \(v\).
\item Calculate the set of SLR states.
\item Specify the function \(\textsl{action}\).
\item Specify the function \(\textsl{goto}\).  
\end{enumerate}
Abbreviate the names of the syntactic variables and terminals with \(s\), \(c\), \(d\), \(l\), and \(I\), where
\(s\) stands for the newly introduced start symbol.  \eox 

\begin{figure}[htbp]
  \begin{center}    
  \framebox{
  \framebox{
  \begin{minipage}[t]{9.5cm}
  \begin{eqnarray*}
  \textsl{cnf}         & \rightarrow & \;\textsl{cnf} \;\;\mathquoted{\wedge}\; \textsl{disjunction}      \\
                       & \mid        & \;\textsl{disjunction}                                    \\[0.2cm]
  \textsl{disjunction} & \rightarrow & \;\textsl{disjunction} \;\;\mathquoted{\vee}\; \textsl{literal}    \\
                       & \mid        & \;\textsl{literal}                                        \\[0.2cm]
  \textsl{literal}     & \rightarrow & \mathquoted{\neg}\;\; \textsc{Identifier}                          \\
                       & \mid        & \;\textsc{Identifier}  
  \end{eqnarray*}
  \vspace*{-0.5cm}

  \end{minipage}}}
  \end{center}
  \caption{Eine Grammatik für Boole'sche Ausdrücke in konjunktiver Normalform.}
  \label{fig:BoolExpr.grammar}
\end{figure}
\subsection{Shift/Reduce and Reduce/Reduce Conflicts}
In this section, we examine shift-reduce and reduce-reduce conflicts in more detail and consider two examples. The first example shows a shift-reduce conflict. 
The grammar shown in Figure \ref{fig:shift-reduce-conflict.grammar} is ambiguous because it does not specify whether the operator \(\saquoted{+}\) binds stronger or weaker than the operator \(\saquoted{*}\). If we interpret the non-terminal \(N\) as an abbreviation for \textsc{Number}, this grammar allows us to interpret the expression \(1 + 2 * 3\) either as 
\\[0.2cm]
\hspace*{1.3cm}
\((1 + 2) * 3\) \quad or as \quad \(1 + (2 * 3)\).

\begin{figure}[htbp]
  \begin{center}    
  \framebox{
  \framebox{
  \begin{minipage}[t]{5.5cm}
    \vspace*{-0.3cm}

  \begin{eqnarray*}
  e & \rightarrow & e \aquoted{+} e  \\
    & \mid        & e \aquoted{*} e  \\
    & \mid        & N
  \end{eqnarray*}
  \vspace*{-0.5cm}

  \end{minipage}}}
  \vspace*{-0.3cm}

  \end{center}
  \caption{A grammar with shift/reduce conflicts.}
  \label{fig:shift-reduce-conflict.grammar}
\end{figure}
\noindent
First, we calculate the start state \(s_0\):
\\[0.2cm]
\hspace*{1.3cm}
\(\begin{array}[t]{lcl}
 s_0 & = & \textsl{closure}\bigl( \{ s \rightarrow \bullet\, e\,\symbol{36} \}\bigr) \\[0.1cm]
     & = & \bigl\{ s \rightarrow \bullet\, e\,\symbol{36},\;
                   e \rightarrow \bullet\, e \saquoted{+} e,\;
                   e \rightarrow \bullet\, e \saquoted{*} e,\;
                   e \rightarrow \bullet\, N\;
            \bigr\}.
 \end{array}
\)
\\[0.2cm] 
Next, we calculate \(s_1 := \textsl{goto}(s_0, e)\):
\\[0.2cm]
\hspace*{1.3cm}
\(\begin{array}[t]{lcl}
  s_1 & = & \textsl{goto}(s_0, e)  \\
      & = & \textsl{closure}\bigl(\{  
                   s \rightarrow e \bullet\,\symbol{36}\;
                   e \rightarrow e \bullet \saquoted{+}\; e,\;
                   e \rightarrow e \bullet \saquoted{*}\; e \;
            \}\bigr) \\
      & = & \{ s \rightarrow e \bullet\,\symbol{36},\;
               e \rightarrow e \bullet \saquoted{+}\; e,\;
               e \rightarrow e \bullet \saquoted{*}\; e \;
            \} 
\end{array}
\)
\\[0.2cm]
Now we calculate \(s_2 := \textsl{goto}(s_1, \saquoted{+})\):
\\[0.2cm]
\hspace*{1.3cm}
\(
\begin{array}[t]{lcl}
  s_2 & = & \textsl{goto}(s_1, \saquoted{+})  \\
      & = & \textsl{closure}\bigl(\{ e \rightarrow e \saquoted{+} \bullet e,\; \}\bigr) \\
      & = & \{ e \rightarrow e \;\saquoted{+} \bullet e,\;
               e \rightarrow \bullet\, e \saquoted{+} e,\;
               e \rightarrow \bullet\, e \saquoted{*} e,\;
               e \rightarrow \bullet\, N\;
            \}
\end{array}
\)
\\[0.2cm] 
Next, we calculate \(s_3 := \textsl{goto}(s_2, e)\):
\\[0.2cm]
\hspace*{1.3cm}
\(
\begin{array}[t]{lcl}
  s_3 & = & \textsl{goto}(s_2, e)  \\
      & = & \textsl{closure}\bigl(\{  
               e \rightarrow e \saquoted{+} e \bullet,\;
               e \rightarrow e \bullet \saquoted{+}\; e,\;
               e \rightarrow e \bullet \saquoted{*}\; e \}\bigr) \\
      & = & \{ e \rightarrow e \saquoted{+} e \bullet,\;
               e \rightarrow e \bullet \saquoted{+}\; e,\;
               e \rightarrow e \bullet \saquoted{*}\; e \;
            \}
\end{array}
\)
\\[0.2cm]
Here, a shift-reduce conflict arises during the calculation of \(\textsl{action}(s_3, \saquoted{*})\),
because on one hand, the marked rule 
\\[0.2cm]
\hspace*{1.3cm}
\(e \rightarrow e \bullet \saquoted{*}\; e\), 
\\[0.2cm]
demands that the token \(\saquoted{*}\) be pushed onto the stack, but on the other hand, we have
\\[0.2cm]
\hspace*{1.3cm}
\(\textsl{Follow}(e) = \{ \;\saquoted{+}, \;\saquoted{*}, \;\saquoted{\symbol{36}}\; \}\), 
\\[0.2cm]
so that, if the next token to be read has the value \(\saquoted{*}\), the symbol stack should be reduced with the rule 
\\[0.2cm]
\hspace*{1.3cm}
\(e \rightarrow e \saquoted{+} e\, \bullet\).
\vspace*{0.3cm}

\noindent
\textbf{Remark}: It is not surprising that we found a conflict in the grammar specified above, as this grammar
is ambiguous. On the other hand, it can be shown that every SLR grammar must be unambiguous. Consequently, an
ambiguous grammar is never an SLR grammar. However, the converse of this statement is not true, as we will see
in the next example. 
\eox


\begin{figure}[htbp]
  \begin{center}    
  \framebox{
  \framebox{
  \begin{minipage}[t]{5.5cm}
    \vspace*{-0.3cm}

  \begin{eqnarray*}
  s & \rightarrow & a \aquoted{x} a \aquoted{y}  \\ 
    & \mid        & b \aquoted{y} b \aquoted{x}  \\[0.1cm]
  a & \rightarrow & \lambda                \\[0.1cm]
  b & \rightarrow & \lambda                
  \end{eqnarray*}
  \vspace*{-0.5cm}

  \end{minipage}}}
  \vspace*{-0.3cm}

  \end{center}
  \caption{A grammar containing a reduce/reduce conflict.}
  \label{fig:reduce-reduce-conflict.grammar}
\end{figure}

Next, we examine a grammar that is not an SLR grammar because it contains reduce-reduce conflicts. 
We consider the grammar shown in Figure \ref{fig:reduce-reduce-conflict.grammar}. This grammar is unambiguous, as we have
\\[0.2cm]
\hspace*{1.3cm}
$L(s) = \{\; \saquoted{xy}, \;\saquoted{yx} \;\}$
\\[0.2cm]
and the string \aquoted{xy} can only be derived using the rule $s \rightarrow  a \aquoted{x} a \aquoted{y}$, while the string \aquoted{yx} can only be generated using the rule 
$s \rightarrow b \aquoted{y} b \aquoted{x}$.
To demonstrate that this grammar contains shift-reduce conflicts, we calculate the start state of an SLR parser for this grammar.
\\[0.2cm]
$\hspace*{1.3cm}
\begin{array}[t]{lcl}
 s_0 & = & \textsl{closure}\bigl( \{ \widehat{s} \rightarrow \bullet\, s\,\symbol{36} \}\bigr) \\
     & = & \bigl\{ \widehat{s} \rightarrow \bullet\, s\,\symbol{36},\;
                   s \rightarrow \bullet\, a \aquoted{x} a \aquoted{y},\;
                   s \rightarrow \bullet\, b \aquoted{y} b \aquoted{x},\;
                   a \rightarrow \bullet\, \lambda, \;
                   b \rightarrow \bullet\, \lambda \;
            \bigr\} \\
     & = & \bigl\{ \widehat{s} \rightarrow \bullet\, s\,\symbol{36},\;
                   s \rightarrow \bullet\, a \aquoted{x} a \aquoted{y},\;
                   s \rightarrow \bullet\, b \aquoted{y} b \aquoted{x},\;
                   a \rightarrow \lambda \bullet, \;
                   b \rightarrow \lambda \bullet \;
            \bigr\},
 \end{array}
$
\\[0.2cm] 
since $a \rightarrow \bullet\, \lambda$ is the same as $a \rightarrow \lambda \bullet$.
In this state, there is a reduce-reduce conflict between the two marked rules
\\[0.2cm]
\hspace*{1.3cm}
$a \rightarrow \lambda \bullet \quad \mbox{and} \quad b \rightarrow \lambda\; \bullet$.
\\[0.2cm]
This conflict arises when calculating 
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{action}(s_0, \aquoted{x})$
\\[0.2cm]
because we have 
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{Follow}(a) = \bigl\{ \saquoted{x}, \saquoted{y} \bigr\} = \textsl{Follow}(b)$.
\\[0.2cm]
Thus, it is unclear which of these rules the parser should use to reduce the input in state $s_0$ when the next token read has the value $\saquoted{x}$, as this token is
both an element of the set $\textsl{Follow}(a)$ and the set $\textsl{Follow}(b)$.

% Es ist interessant zu bemerken, dass die obige Grammatik die $LL(1)$-Eigenschaft hat, denn es gilt
% \\[0.2cm]
% \hspace*{1.3cm}
% $\textsl{First}(a \aquoted{x} a \aquoted{y}) = \{ \aquoted{x} \}$, \quad
% $\textsl{First}(b \aquoted{y} b \aquoted{x}) = \{ \aquoted{y} \}$.
% \\[0.2cm]
% und daraus folgt sofort
% \\[0.2cm]
% \hspace*{1.3cm}
% $\textsl{First}(a \aquoted{x} a \aquoted{y}) \cap \textsl{First}(b \aquoted{y} b \aquoted{x}) =  
%  \{ \saquoted{x} \} \cap \{ \saquoted{y} \} = \{\}. 
% $
% \\[0.2cm]
% Dieses Beispiel zeigt, dass SLR-Grammatiken im Allgemeinen nicht ausdruckstärker sind als
% LL(1)-Grammatiken.  In der Praxis zeigt sich jedoch, dass viele Grammatiken, die nicht die
% LL(1)-Eigenschaft haben, SLR-Grammatiken sind.

\remarkEng
As part of the resources provided with this lecture,  the file
\\[0.2cm]
\hspace*{1.3cm}
\href{https://github.com/karlstroetmann/Formal-Languages/blob/master/Python/Chapter-9/SLR-Table-Generator.ipynb}{Formal-Languages/blob/master/Python/Chapter-9/SLR-Table-Generator.ipynb}
\\[0.2cm]
contains a \textsl{Python} program that checks whether a given grammar is an SLR grammar.  This program
computes the states as well as the action table of a given grammar. \eox

\exerciseEng
The github directory containing supplementary files for this lecture contains the grammar for the
programming language \texttt{C} at
\\[0.2cm]
\hspace*{1.3cm}
\href{https://github.com/karlstroetmann/Formal-Languages/blob/master/Python/Chapter-9/Examples/c-grammar.g}{Formal-Languages/blob/master/Python/Chapter-9/Examples/c-grammar.g}
\\[0.2cm]
This grammar is not an SLR-grammar.  Use the SLR-table generator 
\href{https://github.com/karlstroetmann/Formal-Languages/blob/master/ANTLR4-Python/SLR-Parser-Generator/SLR-Table-Generator.ipynb}{SLR-Table-Genarator.ipynb}
to investigate the conflicts that arise.  Transform the grammar into an SLR grammar by making a small number of changes.
It is sufficient to remove three rules.  After removing those rules, there will be one useless rule left which
is of the form
\\[0.2cm]
\hspace*{1.3cm}
$a \rightarrow b$.
\\[0.2cm]
This rule has to be removed, too.  Furthermore, you have to rename the variable $a$ occurring on the left
hand side of this rule to $b$ everywhere.
\eox

\section{Kanonische LR-Parser}
Der Reduce-Reduce-Konflikt, der in der in Abbildung \ref{fig:reduce-reduce-conflict.grammar}
gezeigten Grammatik auftritt, kann wie folgt gelöst werden:  In dem Zustand
\\[0.2cm]
\hspace*{1.3cm}
$
\begin{array}[t]{lcl}
 s_0 & = & \textsl{closure}\bigl( \{ \widehat{s} \rightarrow \bullet\, s\,\symbol{36} \}\bigr) \\
     & = & \bigl\{ \widehat{s} \rightarrow \bullet\,\, s\,\symbol{36},\;
                   s \rightarrow \bullet\,\, a \aquoted{x} a \aquoted{y},\;
                   s \rightarrow \bullet\,\, b \aquoted{y} b \aquoted{x},\;
                   a \rightarrow \lambda \bullet, \;
                   b \rightarrow \lambda \bullet \;
            \bigr\}
 \end{array}$
\\[0.2cm]
kommen die markierten Regeln $a \rightarrow \lambda \bullet$ und $b \rightarrow
\lambda\bullet$ von der Berechnung des Abschlusses der Regeln 
\\[0.2cm]
\hspace*{1.3cm}
$s \rightarrow \bullet\, a \aquoted{x} a \aquoted{y} \quad \mbox{und} \quad 
 s \rightarrow \bullet\, b \aquoted{y} b \aquoted{x}$.
\\[0.2cm]
Bei der ersten Regel ist klar, dass auf das erste $a$ ein $\saquoted{x}$ folgen muss, bei der zweiten Regel
sehen wir, dass auf das erste $b$ ein $\saquoted{y}$ folgt.  Diese Information geht über die Information
hinaus, die in den Mengen $\textsl{Follow}(a)$ bzw.~$\textsl{Follow}(b)$ enthalten ist, denn jetzt
berücksichtigen wir den \blue{Kontext}, in dem die syntaktische Variable auftaucht.  Damit können wir die
Funktion $\textsl{action}(s_0, \saquoted{x})$ und $\textsl{action}(s_0, \saquoted{y})$ wie folgt definieren:
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{action}(s_0, \saquoted{x}) = \langle \texttt{reduce}, a \rightarrow \lambda \rangle$
\quad \mbox{und} \quad 
$\textsl{action}(s_0, \saquoted{y}) = \langle \texttt{reduce}, b \rightarrow \lambda \rangle$. 
\\[0.2cm]
Durch diese Definition wird der Reduce-Reduce-Konflikt gelöst.  Die zentrale Idee ist,
bei der Berechnung des Abschlusses den Kontext, in dem eine Regel auftritt, mit einzubeziehen.
Dazu erweitern wir zunächst die Definition einer markierten Regel.

\begin{Definition}[erweiterte markierte Regel]
  Eine \blue{erweiterte markierte Regel} \index{erweiterte markierte Regel} (abgekürzt: \blue{e.m.R.}) \index{e.m.R.}
  einer Grammatik 
  $G = \langle V, T, R, s \rangle$ ist ein Quadrupel 
  \\[0.2cm]
  \hspace*{1.3cm}
  $\langle a, \beta, \gamma, L \rangle$,
  \\[0.2cm]
  wobei gilt:
  \begin{enumerate}
  \item $(a \rightarrow \beta \gamma) \in R$.
  \item $L \subseteq T$.
  \end{enumerate}
  Wir schreiben die erweiterte markierte Regel $\langle a, \beta, \gamma, L \rangle$ als
  \\[0.2cm]
  \hspace*{1.3cm}
  $a \rightarrow \beta \bullet \gamma: L$.
  \\[0.2cm]
  Falls $L$ nur aus einem Element $t$ besteht, falls also $L = \{ t \}$ gilt,
  so lassen wir die Mengen-Klammern weg und schreiben die Regel als
  \\[0.2cm]
  \hspace*{1.3cm}
  $a \rightarrow \beta \bullet \gamma:t$. \qed 
\end{Definition}

\noindent
Anschaulich interpretieren wir die e.m.R. $a \rightarrow \beta \bullet \gamma: L$ als einen Zustand,
in dem folgendes gilt:
\begin{enumerate}
\item Der Parser versucht, ein $a$ mit Hilfe der Grammatik-Regel $a \rightarrow \beta \gamma$ zu
      erkennen.
\item Dabei wurde bereits $\beta$ erkannt.  Damit die Regel $a \rightarrow \beta \gamma$
      angewendet werden kann, muss nun  $\gamma$ erkannt werden.
\item Wir wissen zusätzlich, dass auf die syntaktische Variable $a$ ein Token aus der Menge $L$
      folgen muss.

      Die Menge $L$ bezeichnen wir daher als die Menge der \blue{Folge-Token}.
\end{enumerate}

Mit erweiterten markierten Regeln arbeitet es sich ganz ähnlich wie mit markierten Regeln, allerdings
müssen wir die Definitionen der Funktionen $\textsl{closure}$, $\textsl{goto}$ und $\textsl{action}$
etwas modifizieren.  Wir beginnen mit der Funktion $\textsl{closure}$.

\begin{Definition}[$\textsl{closure}(\mathcal{M})$]
  Es sei $\mathcal{M}$ eine Menge erweiterter markierter Regeln.  Dann definieren wir den
  \blue{Abschluss} von $\mathcal{M}$
  als die kleinste Menge $\mathcal{K}$ markierter Regeln, für die folgendes gilt:
  \begin{enumerate}
  \item $\mathcal{M} \subseteq \mathcal{K}$,

        der Abschluss umfasst also die ursprüngliche Regel-Menge.
  \item Ist einerseits
        \\[0.2cm]
        \hspace*{1.3cm}
        $a \rightarrow \beta \bullet c\, \delta: L$
        \\[0.2cm]
        eine e.m.R.~aus der Menge $\mathcal{K}$, wobei $c$ eine syntaktische
        Variable ist, und ist andererseits
        \\[0.2cm]
        \hspace*{1.3cm}
        $c \rightarrow \gamma$
        \\[0.2cm]
        eine Grammatik-Regel der zu Grunde liegenden Grammatik $G$, so ist auch die e.m.R.
        \\[0.2cm]
        \hspace*{1.3cm}
        $c \rightarrow \bullet\, \gamma: \bigcup \{ \textsl{First}(\delta\, t) \mid t \in L \}$
        \\[0.2cm]
        ein Element der Menge $\mathcal{K}$.  Die Funktion $\textsl{First}(\alpha)$ berechnet dabei für
        einen String $\alpha \in (T \cup V)^*$ die Menge aller Token $t$, mit denen ein String
        beginnen kann, der von $\alpha$ abgeleitet worden ist.
  \end{enumerate}
  Die so definierte eindeutig bestimmte Menge $\mathcal{K}$ wird wieder mit
  $\textsl{closure}(\mathcal{M})$ bezeichnet. \qed
\end{Definition}

\noindent
\textbf{Bemerkung}:  Gegenüber der alten Definition ist nur die Berechnung der Menge
der Folge-Token hinzu gekommen.  Der Kontext, in dem das $c$ auftritt, das mit der Regel
$c \rightarrow \gamma$ erkannt werden soll, ist zunächst durch den String $\delta$ gegeben,
der in der Regel $a \rightarrow \beta \bullet c\, \delta:L$ auf das $c$ folgt.
Möglicherweise leitet $\delta$  den leeren String $\lambda$ ab.  In diesen Fall  
spielen auch die Folge-Token aus der Menge $L$ eine Rolle, denn falls
$\delta \Rightarrow^* \lambda$ gilt, kann auf das $c$ auch ein Folge-Token $t$ aus der
Menge $L$ folgen. \hspace*{\fill} $\Box$
\vspace*{0.1cm}

Für eine gegebene e.m.R.-Menge $\mathcal{M}$ kann die Berechnung von 
$\mathcal{K} := \textsl{closure}(\mathcal{M})$ iterativ erfolgen.  Abbildung \ref{fig:closure} zeigt die
Berechnung von $\textsl{closure}(\mathcal{M})$.  Der wesentliche Unterschied gegenüber der
früheren Berechnung von $\textsl{closure}()$ ist, dass wir bei den e.m.R.s, die wir für
eine Variable $c$ mit in $\textsl{closure}(\mathcal{M})$ aufnehmen, bei der Menge der
Folge-Token den Kontext berücksichtigen, in dem $c$ auftritt.
Dadurch gelingt es,  die Zustände des Parsers präziser zu beschreiben, als dies bei
markierten Regeln der Fall ist.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                  commandchars  = \\\{\},
                  codes={\catcode`$=3\catcode`^=7\catcode`_=8}
                ]
    function closure($\mathcal{M}$) \{
        $\mathcal{K}\,$  := $\mathcal{M}$;
        $\mathcal{K}^{-}$ := $\{\}$;
        while ($\mathcal{K}^{-}\!$ $\not=$ $\mathcal{K}$) \{
            $\mathcal{K}^{-}\!$ := $\mathcal{K}$;
            $\mathcal{K}$  := $\mathcal{K} \cup \bigl\{\left(c\rightarrow\bullet\gamma:\bigcup\{\textsl{First}(\delta\,t)\mid{}t\in{}L\}\right) \mid (a\rightarrow\beta\bullet{}c\,\delta:L)\in\mathcal{K}\wedge(c\rightarrow\gamma)\in{}R\bigr\}$;
        \}
        return $\mathcal{K}$;
    \}
\end{Verbatim}
% $
\vspace*{-0.3cm}
\caption{Berechnung von $\textsl{closure}(\mathcal{M})$}
\label{fig:closure}
\end{figure}
\vspace*{0.2cm}

\noindent
\textbf{Bemerkung}: Der Ausdruck $\bigcup\{\textsl{First}(\delta\,t)\mid{}t\in{}L\}$
sieht komplizierter aus, als er tatsächlich ist.  Wollen wir diesen Ausdruck berechnen, so
ist es zweckmäßig eine Fallunterscheidung danach durchzuführen, ob $\delta$ den leeren
String $\lambda$ ableiten kann oder nicht, denn es gilt
\\[0.2cm]
\hspace*{1.3cm}
$\bigcup\{\textsl{First}(\delta\,t)\mid{}t\in{}L\} = 
\left\{
\begin{array}{ll}
  \textsl{First}(\delta) \cup L  & \mbox{falls $\delta \Rightarrow^* \lambda$;}  \\
  \textsl{First}(\delta)         & \mbox{sonst.}  
\end{array}
\right.
$
\\[0.2cm]
Die Berechnung von $\textsl{goto}(\mathcal{M},t)$ für eine Menge $\mathcal{M}$ von erweiterten Regeln und
ein Zeichen $x$ ändert sich gegenüber der Berechnung im Falle einfacher markierter Regeln
nur durch das Anfügen der Menge von \blue{Folge-Tokens}, die aber selbst unverändert bleibt:
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{goto}(\mathcal{M}, x) := \textsl{closure}\Bigl( \bigl\{ 
   a \rightarrow \beta\, x \bullet \delta:L \mid (a \rightarrow \beta \bullet x\, \delta:L) \in \mathcal{M} 
   \bigr\} \Bigr)$. 
\\[0.2cm]
Ähnlich wie bei der Theorie der SLR-Parser augmentieren wir unsere Grammatik $G$, indem wir
der Menge der Variable eine neue Start-Variable $\widehat{s}$ und der Menge der Regeln die
neue Regel $\widehat{s} \rightarrow s$ hinzufügen.  Weiter fügen wir den Token das Symbol
\symbol{36} hinzu.  Dann hat der Start-Zustand die  Form
\\[0.2cm]
\hspace*{1.3cm}
$q_0 := \textsl{closure}\bigr(\bigl\{ \widehat{s} \rightarrow \bullet\, s:\symbol{36}\bigr\}\bigr)$,
\\[0.2cm]
denn auf das Start-Symbol muss das Datei-Ende ``\symbol{36}'' folgen.
Als letztes zeigen wir, wie die Definition der Funktion $\textsl{action}()$ geändert werden muss.
Wir spezifizieren die Berechnung dieser Funktion durch die folgenden bedingten Gleichungen.
\begin{enumerate}
\item $(a \rightarrow \beta \bullet t\, \delta:L) \in \mathcal{M} \;\Longrightarrow\;
       \textsl{action}(\mathcal{M},t) := \langle \texttt{shift}, \textsl{goto}(\mathcal{M},t) \rangle$. 
\item $(a \rightarrow \beta \bullet:L) \in \mathcal{M} \;\wedge\; a \not= \widehat{s}
       \;\wedge\; t \in L \;\Longrightarrow\;
       \textsl{action}(\mathcal{M},t) := \langle \texttt{reduce}, a \rightarrow \beta \rangle$. 
\item $(\widehat{s} \rightarrow s \bullet:\symbol{36}) \in \mathcal{M} \;\Longrightarrow\;
       \textsl{action}(\mathcal{M},\symbol{36}) := \texttt{accept}$. 
\item Sonst: \quad $\textsl{action}(\mathcal{M},t) := \texttt{error}$. 
\end{enumerate}
Falls es bei diesen Gleichungen zu einem Konflikt kommt, weil gleichzeitig die Bedingung
der ersten Gleichung als auch die Bedingung der zweiten Gleichung erfüllt ist, so sprechen
wir wieder von einem \blue{Shift-Reduce-Konflikt}.  
Ein Shift-Reduce-Konflikt liegt also bei der Berechnung von
$\textsl{action}(\mathcal{M},t)$ dann vor, wenn es zwei e.m.R.s 
\\[0.2cm]
\hspace*{1.3cm}
$(a \rightarrow \beta \bullet t\, \delta:L_1) \in \mathcal{M}$ \quad \mbox{und} \quad 
$(c \rightarrow \gamma\bullet :L_2) \in \mathcal{M} \quad \mbox{mit}\; t \in L_2$
\\[0.2cm]
gibt, denn dann ist nicht klar, ob im Zustand $\mathcal{M}$ das Token $t$ auf den Stack geschoben werden
soll, oder ob stattdessen der Symbol-Stack mit der Regel $c \rightarrow \gamma$ reduziert werden muss.
\vspace*{0.2cm}

\noindent
\textbf{Bemerkung}:  Gegenüber einem SLR-Parser ist die Möglichkeit von
Shift-Reduce-Konflikten verringert, denn  bei einem SLR-Parser liegt bereits dann ein
Shift-Reduce-Konflikt vor, wenn $t \in \textsl{Follow}(c)$ gilt und die Menge $L_2$ ist in der Regel kleiner als die
Menge $\textsl{Follow}(c)$.  \eox 
\vspace*{0.3cm}

Ein \blue{Reduce-Reduce-Konflikt} liegt vor, wenn es zwei e.m.R.s 
\\[0.2cm]
\hspace*{1.3cm}
$(a \rightarrow \beta\, \bullet:L_1) \in \mathcal{M}$ \quad \mbox{und} \quad 
$(c \rightarrow \delta\, \bullet:L_2) \in \mathcal{M}$ \quad \mbox{mit} \quad $L_1 \cap L_2 \not= \{\}$
\\[0.2cm]
gibt, denn dann ist nicht klar, mit welcher dieser beiden Regeln der Symbol-Stack reduziert werden soll,
wenn das nächste Token ein Element der Schnittmenge $L_1 \cap L_2$ ist.
\vspace*{0.2cm}

\noindent
\textbf{Bemerkung}:  Gegenüber einem SLR-Parser ist die Möglichkeit von
Reduce-Reduce-Konflikten verringert, denn  bei einem SLR-Parser liegt bereits dann ein
Reduce-Reduce-Konflikt vor, wenn es ein $t$ in der Menge
 $\textsl{Follow}(a) \cap \textsl{Follow}(c)$ gibt und die $\textsl{Follow}$-Mengen sind oft größer als die Mengen
$L_1$ und $L_2$.  \eox
\vspace*{0.3cm}


\example
Wir greifen das Beispiel der in Abbildung \ref{fig:reduce-reduce-conflict.grammar} gezeigten Grammatik
wieder auf und berechnen zunächst die Menge aller Zustände.  

\begin{enumerate}
\item $\begin{array}[t]{lcl}
        s_0 & := & \textsl{closure}\Bigl(\bigl\{\widehat{s} \rightarrow \bullet\, s:\symbol{36} \bigr\}\Bigr) \\
            & =  & \bigl\{ \widehat{s} \rightarrow \bullet\, s:\symbol{36},
                           s \rightarrow \bullet\, a \saquoted{x} a \saquoted{y}:\symbol{36},
                           s \rightarrow \bullet\, b \saquoted{y} b \saquoted{x}:\symbol{36},
                           a \rightarrow \bullet\,: \saquoted{x},
                           b \rightarrow \bullet\,: \saquoted{y}
                    \bigr\}.
       \end{array}
       $
\item $\begin{array}[t]{lcl}
        s_1 & := & \textsl{goto}(s_0,a) \\
            & =  & \textsl{closure}\bigl(\bigl\{ s \rightarrow a \bullet \saquoted{x} a \saquoted{y}:\symbol{36} 
                   \bigr\}\bigr) \\
            & =  & \bigl\{ s \rightarrow a \bullet \saquoted{x} a \saquoted{y}:\symbol{36} \bigr\}.
       \end{array}
       $
\item $\begin{array}[t]{lcl}
        s_2 & := & \textsl{goto}(s_0,s) \\
            & =  & \textsl{closure}\bigl(\bigl\{\widehat{s} \rightarrow s \bullet:\symbol{36} \bigr\}\bigr) \\
            & =  & \bigl\{ \widehat{s} \rightarrow s \bullet:\symbol{36} \bigr\}.
       \end{array}
      $
\item $\begin{array}[t]{lcl}
        s_3 & := & \textsl{goto}(s_0,b) \\
            & =  & \textsl{closure}\bigl(\bigl\{ s \rightarrow b \bullet \saquoted{y} b \saquoted{x}: \symbol{36}
                   \bigr\}\bigr) \\
            & =  & \bigl\{ s \rightarrow b \bullet \saquoted{y} b \saquoted{x}: \symbol{36}
                   \bigr\}.
       \end{array}
       $
\item $\begin{array}[t]{lcl}
        s_4 & := & \textsl{goto}(s_3,\saquoted{y}) \\
            & =  & \textsl{closure}\bigl(\bigl\{ s \rightarrow b \saquoted{y} \bullet b \saquoted{x}: \symbol{36}
                   \bigr\}\bigr) \\
            & =  & \bigl\{ s \rightarrow b \saquoted{y} \bullet b \saquoted{x}: \symbol{36},
                           b \rightarrow \bullet\,: \saquoted{x}
                   \bigr\}.
       \end{array}
       $
\item $\begin{array}[t]{lcl}
        s_5 & := & \textsl{goto}(s_4, b) \\
            & =  & \textsl{closure}\bigl(\bigl\{ s \rightarrow b \saquoted{y} b \bullet \saquoted{x}: \symbol{36}
                   \bigr\}\bigr) \\
            & =  & \bigl\{ s \rightarrow b \saquoted{y} b \bullet \saquoted{x}: \symbol{36}
                   \bigr\}.
       \end{array}
       $
\item $\begin{array}[t]{lcl}
        s_6 & := & \textsl{goto}(s_5, \saquoted{x}) \\
            & =  & \textsl{closure}\bigl(\bigl\{ s \rightarrow b \saquoted{y} b \saquoted{x} \bullet: \symbol{36}
                   \bigr\}\bigr) \\
            & =  & \bigl\{ s \rightarrow b \saquoted{y} b \saquoted{x} \bullet: \symbol{36}
                   \bigr\}.
       \end{array}
       $
\item $\begin{array}[t]{lcl}
        s_7 & := & \textsl{goto}(s_1, \saquoted{x}) \\
            & =  & \textsl{closure}\bigl(\bigl\{ 
                          s \rightarrow a \saquoted{x} \bullet a \saquoted{y}:\symbol{36}
                   \bigr\}\bigr) \\
            & =  & \bigl\{
                          s \rightarrow a \saquoted{x} \bullet a \saquoted{y}:\symbol{36},
                          a \rightarrow \bullet\,: \saquoted{y}
                   \bigr\}.
       \end{array}
       $
\item $\begin{array}[t]{lcl}
        s_8 & := & \textsl{goto}(s_7, a) \\
            & =  & \textsl{closure}\bigl(\bigl\{ 
                          s \rightarrow a \saquoted{x} a \bullet \saquoted{y}:\symbol{36}
                   \bigr\}\bigr) \\
            & =  & \bigl\{
                          s \rightarrow a \saquoted{x} a \bullet \saquoted{y}:\symbol{36}
                   \bigr\}.
       \end{array}
       $
\item $\begin{array}[t]{lcl}
        s_9 & := & \textsl{goto}(s_8, \saquoted{y}) \\
            & =  & \textsl{closure}\bigl(\bigl\{ 
                          s \rightarrow a \saquoted{x} a \saquoted{y} \bullet :\symbol{36}
                   \bigr\}\bigr) \\
            & =  & \bigl\{
                          s \rightarrow a \saquoted{x} a \saquoted{y} \bullet :\symbol{36}
                   \bigr\}.
       \end{array}
       $
\end{enumerate}
Als nächstes untersuchen wir, ob es bei den Zuständen Konflikte gibt.
Beim Start-Zustand $s_0$ hatten wir im letzten Abschnitt einen Reduce-Reduce-Konflikt zwischen den
beiden Regeln $a \rightarrow \lambda$ und $b \rightarrow \lambda$ gefunden, weil 
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{Follow}(a) \cap \textsl{Follow}(b) = \{ \saquoted{x}, \saquoted{y} \} \not= \{\}$
\\[0.2cm]
gilt.  Dieser Konflikt ist nun verschwunden, denn zwischen den e.m.R.s
\\[0.2cm]
\hspace*{1.3cm}
$a \rightarrow \bullet\,: \saquoted{x}$ \quad \mbox{und} \quad 
$b \rightarrow \bullet\,: \saquoted{y}$
\\[0.2cm]
gibt es wegen $\saquoted{x} \not= \saquoted{y}$ keinen Konflikt.  Es ist leicht zu sehen, dass auch bei den
anderen Zustände keine Konflikte auftreten.


\exercise
Berechnen Sie die Menge der Zustände eines LR-Parsers für die folgende Grammatik:
  \begin{eqnarray*}
  e & \rightarrow & e \aquoted{+} p           \\
    & \mid        & p                        \\[0.2cm]
  p & \rightarrow & p \aquoted{*} f           \\
    & \mid        & f                        \\[0.2cm]
  f & \rightarrow & \saquoted{(} e \aquoted{)} \\
    & \mid        & \textsl{Number}             
  \end{eqnarray*}
Untersuchen Sie außerdem, ob es bei dieser Grammatik Shift-Reduce-Konflikte oder
Reduce-Reduce-Konflikte gibt.
\vspace*{0.2cm}

\remarkEng
As part of the resources provided with this lecture,  the file
\\[0.2cm]
\hspace*{1.3cm}
\href{https://github.com/karlstroetmann/Formal-Languages/blob/master/ANTLR4-Python/LR-Parser-Generator/LR-Table-Generator.ipynb}{ANTLR4-Python/LR-Parser-Generator/LR-Table-Generator.ipynb}
\\[0.2cm]
contains a \textsl{Python} program that checks whether a given grammar qualifies as a canonical LR grammar.
This program computes the LR-states as well as the action table for a given grammar.  \eox
\vspace*{0.3cm}

\remarkEng
The theory of LR-parsing has been developed by Donald E.~Knuth \cite{knuth:65}.  
His theory is described in the paper 
``\href{http://www.cs.dartmouth.edu/~mckeeman/cs48/mxcom/doc/knuth65.pdf}{On the translation of languages from left to right}''.
\eox


\section{LALR-Parser}
Die Zahl der Zustände eines LR-Parsers ist oft erheblich größer als die Zahl der Zustände, die ein
SLR-Parser derselben Grammatik hätte.  Beispielsweise kommt ein SLR-Parser für die
\href{https://github.com/karlstroetmann/Formal-Languages/blob/master/SetlX/Examples/c-grammar.g}{\texttt{C}-Grammatik} 
mit 349 Zuständen aus.  Da die Sprache \texttt{C} keine SLR-Sprache ist, gibt es beim Erzeugen
einer SLR-Parse-Tabelle für \texttt{C} allerdings eine Reihe von 
\href{https://github.com/karlstroetmann/Formal-Languages/blob/master/SetlX/Examples/c-grammar-slr-table.txt}{Konflikten},
so dass ein SLR-Parser für die Sprache \texttt{C} nicht funktioniert.  Demgegenüber kommt ein
LR-Parser für die Sprache \texttt{C} auf 1572 Zustände, wie Sie 
\href{https://github.com/karlstroetmann/Formal-Languages/blob/master/SetlX/Examples/c-grammar-lr-table.txt}{hier}
sehen können.  In den siebziger Jahren, als der zur Verfügung stehende
Haupt-Speicher der meisten Rechner noch bescheidener dimensioniert war, als dies heute
der Fall ist, hatten LR-Parser daher eine für die Praxis problematische
Größe.  Eine genaue Analyse der Menge der Zustände von LR-Parsern zeigte, dass es oft möglich ist, 
bestimmte Zustände zusammen zu fassen.  Dadurch kann die Menge der Zustände in den meisten Fällen
deutlich verkleinert werden.  Wir illustrieren das Konzept an einem Beispiel und betrachten die in
Abbildung \ref{fig:dragon-book.grammar} gezeigte Grammatik, die ich dem \blue{Drachenbuch}
\cite{aho:2006} entnommen habe.  (Das ``Drachenbuch'' ist das Standardwerk im Bereich Compilerbau.)


\begin{figure}[htbp]
  \begin{center}    
  \framebox{
  \framebox{
  \begin{minipage}[t]{5.5cm}
    \vspace*{-0.3cm}

  \begin{eqnarray*}
  \widehat{s} & \rightarrow & s      \\[0.1cm]
  s  & \rightarrow & c \; c          \\[0.1cm]
  c  & \rightarrow & \saquoted{x}\; c \\
     & \mid        & \saquoted{y}\;
  \end{eqnarray*}
  \vspace*{-0.5cm}

  \end{minipage}}}
  \vspace*{-0.3cm}

  \end{center}
  \caption{Eine Grammatik aus dem Drachenbuch.}
  \label{fig:dragon-book.grammar}
\end{figure}

\begin{figure}[!ht]
\centering
      \epsfig{file=Abbildungen/cc-LR.eps, scale=0.5}
      \caption{LR-Goto-Graph für die Grammatik aus Abbildung \ref{fig:dragon-book.grammar}.}
  \label{fig:cc-LR.eps}
\end{figure}


Abbildung \ref{fig:cc-LR.eps} zeigt den sogenannten \blue{LR-Goto-Graphen} für diese Grammatik.
Die Knoten dieses Graphen sind die Zustände.  
Betrachten wir den LR-Goto-Graphen, so stellen wir fest, dass die Zustände $s_6$ und
$s_3$ sich nur in den Mengen der Folge-Token unterscheiden, denn es gilt einerseits
\\[0.2cm]
\hspace*{1.3cm}
$s_6 = \Bigl\{ s \rightarrow \saquoted{x} \bullet c: \saquoted{\symbol{36}}, 
                 c \rightarrow \bullet\, \aquoted{x} c:  \saquoted{\symbol{36}},
                 c \rightarrow \bullet\, \aquoted{y}:    \saquoted{\symbol{36}}
       \Bigr\}$, 
\\[0.2cm]
und andererseits haben wir
\\[0.2cm]
\hspace*{1.3cm}
$s_3 = \Bigl\{ s \rightarrow \saquoted{x} \bullet c: \{ \saquoted{x}, \saquoted{y} \}, 
                 c \rightarrow \bullet\, \aquoted{x} c:  \{ \saquoted{x}, \saquoted{y} \},
                 c \rightarrow \bullet\, \aquoted{y}:    \{ \saquoted{x}, \saquoted{y} \}  
       \Bigr\}$.
\\[0.2cm]
Offenbar entsteht die Menge $s_3$ aus der Menge $s_6$ indem überall $\saquoted{\symbol{36}}$
durch die Menge $\{ \saquoted{x}, \saquoted{y}\}$ ersetzt wird.  Genauso kann die Menge $s_7$ in $s_4$
und $s_9$ in $s_8$ überführt werden.  Die entscheidende Erkenntnis ist nun, dass die
Funktion $\textsl{goto}()$ unter dieser Art von Transformation invariant ist, denn bei der
Definition dieser Funktion spielt die Menge der Folge-Token keine Rolle.  So sehen wir zum
Beispiel, dass einerseits
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{goto}(s_3, c) = s_8$ \quad und \quad 
$\textsl{goto}(s_6, c) = s_9$ 
\\[0.2cm]
gilt und dass andererseits der Zustand $s_9$ in den Zustand $s_8$ übergeht, wenn wir
überall in $s_9$ das Terminal $\saquoted{\symbol{36}}$ durch die Menge 
 $\{ \saquoted{x}, \saquoted{y}\}$ ersetzen.  Definieren wir den \blue{Kern}
einer Menge von erweiterten markierten Regeln dadurch, dass wir in jeder Regel die Menge
der Folgetoken wegstreichen, und fassen dann Zustände mit demselben Kern zusammen, so
erhalten wir den in 
Abbildung \ref{fig:cc-LALR.eps} gezeigten Goto-Graphen.

\begin{figure}[!ht]
\centering
  \hspace*{-0.6cm} \epsfig{file=Abbildungen/cc-LALR, scale=0.5}
  \caption{Der LALR-Goto-Graph für die Grammatik aus Abbildung \ref{fig:dragon-book.grammar}.}
  \label{fig:cc-LALR.eps}
\end{figure}

Um die Beobachtungen, die wir bei der Betrachtung der in Abbildung
\ref{fig:dragon-book.grammar} gezeigten Grammatik gemacht gaben, verallgemeinern und formalisieren zu
können, definieren wir ein Funktion 
$\textsl{core}()$, die den Kern einer Menge von e.m.R.s berechnet und damit diese Menge in
eine Menge markierter Regeln überführt: 
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{core}(\mathcal{M}) := 
   \{ a \rightarrow \beta \bullet \gamma \mid (a \rightarrow \beta \bullet \gamma:L) \in \mathcal{M} \}$. 
\\[0.2cm]
Die Funktion $\textsl{core}()$ entfernt also einfach die Menge der Folge-Tokens von den e.m.R.s.
Wir hatten die Funktion $\textsl{goto}()$ für eine Menge $\mathcal{M}$ von erweiterten
markierten Regeln und ein Symbol $x$ durch
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{goto}(\mathcal{M}, x) := \textsl{closure}\Bigl( \bigl\{ 
 a \rightarrow \beta\, x \bullet \gamma:L \mid (a \rightarrow \beta \bullet x\, \gamma:L) \in \mathcal{M} 
 \bigr\} \Bigr)
$.
\\[0.2cm]
definiert.  Offenbar spielt die Menge der Folge-Token bei der Berechnung von
$\textsl{goto}(\mathcal{M}, x)$ keine Rolle, formal gilt für zwei e.m.R.-Mengen
$\mathcal{M}_1$ und $\mathcal{M}_2$ und ein Symbol $x$ die Formel:
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{core}(\mathcal{M}_1) = \textsl{core}(\mathcal{M}_2) \;\Rightarrow\;
 \textsl{core}(\textsl{goto}(\mathcal{M}_1, x)) = 
 \textsl{core}(\textsl{goto}(\mathcal{M}_2, x))
$.
\vspace*{0.2cm}

Für zwei e.m.R.-Mengen $\mathcal{M}$ und $\mathcal{N}$, die
den gleichen Kern haben, definieren wir die \blue{erweiterte Vereinigung}  
$\mathcal{M} \uplus \mathcal{N}$ von $\mathcal{M}$ und $\mathcal{N}$ als
\\[0.2cm]
\hspace*{1.3cm}
$\mathcal{M} \uplus \mathcal{N} := 
   \{ a \rightarrow \beta\bullet \gamma:K \cup L \mid 
      (a \rightarrow \beta\bullet \gamma:K) \in \mathcal{M} \;\wedge\;
      (a \rightarrow \beta\bullet \gamma:L) \in \mathcal{N}
   \}
$.
\\[0.2cm] 
Diese Definition verallgemeinern wir zu einer Operation $\biguplus$, 
die auf einer Menge von Mengen von e.m.R.s definiert ist: Ist $\frak{I}$
eine Menge von Mengen von e.m.R.s, die alle den gleichen Kern haben, gilt also
\[ \frak{I} = \{ \mathcal{M}_1, \cdots, \mathcal{M}_k \} \quad \mbox{mit} \quad
   \textsl{core}(\mathcal{M}_i) = \textsl{core}(\mathcal{M}_j) \quad 
   \mbox{für alle $i,j\in\{1,\cdots,k\}$,} 
\]
so definieren wir
\[ \biguplus \frak{I} := \mathcal{M}_1 \uplus \cdots \uplus \mathcal{M}_k. 
\]
Es sei nun $\Delta$ die Menge aller Zustände eines LR-Parsers.  Dann ist die Menge der Zustände des
entsprechenden LALR-Parsers durch die erweiterte Vereinigung der Menge aller der Teilmengen 
von $\Delta$ gegeben, deren Elemente den gleichen Kern haben:
\[ \frak{Q} := \left\{ \biguplus \frak{I} \mid \frak{I} \in 2^\Delta \wedge 
      \forall \mathcal{M},\mathcal{N} \in \frak{I}: \textsl{core}(\mathcal{M}) = \textsl{core}(\mathcal{N}) 
      \wedge \mbox{und $\frak{I}$ maximal} 
   \right\}. 
\]
Die Forderung ``$\frak{I}$ maximal'' drückt in der obigen Definition aus, dass in $\frak{I}$ tatsächlich
\underline{alle} Mengen aus $\Delta$ zusamengefasst sind, die den selben Kern haben.
Die so definierte Menge $\frak{Q}$ ist die Menge der LALR-Zustände.  

Als nächstes überlegen wir, wie sich die Berechnung von $\textsl{goto}(\mathcal{M},X)$
ändern muss, wenn $\mathcal{M}$ ein Element der Menge $\frak{Q}$ der LALR-Zustände ist.  
Zur Berechnung von $\textsl{goto}(\mathcal{M},X)$ berechnen wir zunächst die Menge
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{closure}\Bigl( \bigl\{  
  A \rightarrow \alpha X \bullet \beta:L \mid (A \rightarrow \alpha \bullet X \beta:L) \in \mathcal{M} 
  \bigr\} \Bigr)
$.
\\[0.2cm]
Das Problem ist, dass diese Menge im Allgemeinen kein Element der Menge $\frak{Q}$ ist,
denn die Zustände in $\frak{Q}$ entstehen ja durch die Zusammenfassung mehrerer LR-Zustände.
Die Zustände, die bei der Berechnung von $\frak{Q}$ zusammengefasst werden, haben aber alle den selben
Kern.  Daher enthält die  Menge
\\[0.2cm]
\hspace*{1.3cm}
$\Bigl\{ q \in \frak{Q} \mid \textsl{core}(q) =
  \textsl{core}\bigl(\textsl{closure}\bigl( \bigl\{  
  a \rightarrow \beta\, x \bullet \gamma:L \mid (a \rightarrow \beta \bullet x\, \gamma:L) \in \mathcal{M} 
  \bigr\} \bigr)\bigr)
  \Bigr\}
$
\\[0.2cm]
genau ein Element und dieses Element ist der Wert von $\textsl{goto}(\mathcal{M}, X)$.  Folglich
können wir  
\\[0.2cm]
\hspace*{1.3cm}
$\ds\textsl{goto}(\mathcal{M}, X) := \textsl{arb}\Bigl(\Bigl\{ q \in \frak{Q} \mid \textsl{core}(q) =
  \textsl{core}\Bigl(\textsl{closure}\Bigl( \bigl\{  
  a \rightarrow \beta\, X \bullet \gamma:L \mid (a \rightarrow \beta \bullet X\, \gamma:L) \in \mathcal{M} 
  \bigr\} \Bigr)\Bigr)
  \Bigr\} \Bigr)
$
\\[0.2cm]
setzen.  Die hier verwendete Funktion $\textsl{arb}()$ dient dazu, ein beliebiges Element aus einer Menge
zu extrahieren.  Da die Menge, aus der hier das Element extrahiert wird, genau ein Element enthält, ist
$\textsl{goto}(\mathcal{M}, x)$ wohldefiniert.
Die Berechnung des Ausdrucks $\textsl{action}(\mathcal{M}, t)$ ändert sich gegenüber der Berechnung für
einen LR-Parser nicht. 

\section{Vergleich von SLR-, LR- und LALR-Parsern}
Wir wollen nun die verschiedenen Methoden, mit denen wir in diesem Kapitel
Shift-Reduce-Parser konstruiert haben, vergleichen.  Wir nennen eine Sprache $\mathcal{L}$
eine \blue{SLR-Sprache}, wenn $\mathcal{L}$ von einem SLR-Parser erkannt werden kann.
Die Begriffe \blue{kanonische LR-Sprache} und \blue{LALR-Sprache} werden analog definiert.
 Zwischen diesen Sprachen bestehen die folgende Beziehungen:
\\[0.2cm]
\hspace*{1.3cm}
\blue{SLR-Sprache} $\subsetneq$ \blue{LALR-Sprache} $\subsetneq$ \blue{kanonische LR-Sprache} 
\hspace*{\fill} $(\star)$
\\[0.2cm]
Diese Inklusionen sind leicht zu verstehen:  Bei der Definition der LR-Parser hatten wir
zu den markierten Regeln  Mengen von Folge-Token hinzugefügt.  Dadurch war
es möglich, in bestimmten Fällen Shift-Reduce- und Reduce-Reduce-Konflikte zu vermeiden.
Da die Zustands-Mengen der kanonischen LR-Parser unter Umständen sehr groß werden können,
hatten wir dann wieder solche Mengen von erweiterten markierten Regeln zusammengefasst,
die den gleichen Kern haben.  So hatten wir die LALR-Parser
erhalten.  Durch die Zusammenfassung von Regel-Menge können wir
uns allerdings in bestimmten Fällen Reduce-Reduce-Konflikte einhandeln, so dass die 
Menge der LALR-Sprachen eine Untermenge der kanonischen LR-Sprachen ist.

Wir werden in den folgenden Unterabschnitten zeigen, dass die Inklusionen in $(\star)$ echt sind.  

\subsection{\blue{SLR-Sprache} $\subsetneq$ \blue{LALR-Sprache}}
Die Zustände eines LALR-Parsers enthalten gegenüber den Zuständen eines SLR-Parsers noch
Mengen von Folge-Token.  Damit sind LALR-Parser mindestens genauso mächtig wie SLR-Parser.
Wir zeigen nun, dass LALR-Parser tatsächlich mächtiger als SLR-Parser sind.  Um diese
Behauptung zu belegen, präsentieren wir eine Grammatik, für die es zwar einen LALR-Parser,
aber keinen SLR-Parser gibt.  Wir hatten auf Seite \pageref{fig:reduce-reduce-conflict.grammar}
gesehen, dass die Grammatik
\\[0.2cm]
\hspace*{1.3cm}
$s \;\rightarrow\; a \aquoted{x} a \aquoted{y} \mid b \aquoted{y} b \aquoted{x}$, \quad
$a \;\rightarrow\;\lambda$, \quad
$b \;\rightarrow\; \lambda$
\\[0.2cm]
keine SLR-Grammatik ist.  Später hatten wir gesehen, dass diese Grammatik von einem
kanonischen LR-Parser geparst werden kann.  Wir zeigen nun, dass diese Grammatik auch von
einem LALR-Parser geparst werden kann.  Dazu berechnen wir die Menge der LALR-Zustände.
Dazu ist zunächst die Menge der kanonischen LR-Zustände zu berechnen.  Diese Berechnung
hatten wir bereits früher durchgeführt und dabei die folgenden Zustände erhalten:
\begin{enumerate}
\item $s_0  = \bigl\{ \widehat{s} \rightarrow \bullet\, s:\symbol{36},
                     s \rightarrow \bullet\, a \saquoted{x} a \saquoted{y}:\symbol{36},
                     s \rightarrow \bullet\, b \saquoted{y} b \saquoted{x}:\symbol{36},
                     a \rightarrow \bullet\,: \saquoted{x},
                     b \rightarrow \bullet\,: \saquoted{y}
              \bigr\}
      $,
\item $s_1 = \bigl\{ s \rightarrow a \bullet \saquoted{x} a \saquoted{y}:\symbol{36} \bigr\}$,
\item $s_2 = \bigl\{ \widehat{s} \rightarrow s \bullet:\symbol{36} \bigr\}$,
\item $s_3 = \bigl\{ s \rightarrow b \bullet \saquoted{y} b \saquoted{x}: \symbol{36} \bigr\}$,
\item $s_4 = \bigl\{ s \rightarrow b \saquoted{y} \bullet b \saquoted{x}: \symbol{36},
                     b \rightarrow \bullet\,: \saquoted{x}
             \bigr\}
      $,
\item $s_5 = \bigl\{ s \rightarrow b \saquoted{y} b \bullet \saquoted{x}: \symbol{36} \bigr\}$,
\item $s_6 = \bigl\{ s \rightarrow b \saquoted{y} b \saquoted{x} \bullet: \symbol{36} \bigr\}$,
\item $s_7 = \bigl\{ s \rightarrow a \saquoted{x} \bullet a \saquoted{y}:\symbol{36},
                     a \rightarrow \bullet\,: \saquoted{y}
              \bigr\}
      $,
\item $s_8 = \bigl\{ s \rightarrow a \saquoted{x} a \bullet \saquoted{y}:\symbol{36} \bigr\}$,
\item $s_9 = \bigl\{ s \rightarrow a \saquoted{x} a \saquoted{y} \bullet :\symbol{36} \bigr\}$.
\end{enumerate}
Wir stellen fest, dass die Kerne aller hier aufgelisteten Zustände verschieden sind.
Damit stimmt bei dieser Grammatik die Menge der Zustände des LALR-Parser mit der Menge der
Zustände des kanonischen LR-Parsers überein.  Daraus folgt, dass es auch bei
den LALR-Zuständen keine Konflikte gibt, denn beim Übergang von kanonischen LR-Parsern zu
LALR-Parsern haben wir lediglich Zustände mit gleichem Kern zusammengefasst, die
Definition der Funktionen $\textsl{goto}()$ und $\textsl{action}()$ blieb unverändert.

\subsection{\blue{LALR-Sprache} $\subsetneq$ \blue{kanonische LR-Sprache}}
Wir hatten LALR-Parser dadurch definiert, dass wir verschiedene Zustände eines kanonischen LR-Parsers
zusammengefasst haben.  Damit ist klar, dass kanonische LR-Parser mindestens so mächtig
sind wie LALR-Parser.  Um zu zeigen, dass kanonische LR-Parser tatsächlich mächtiger sind
als LALR-Parser, benötigen wir eine Grammatik, für die sich zwar ein kanonischer LR-Parser,
aber kein LALR-Parser erzeugen lässt.  Abbildung \ref{fig:lr-but-notlalr.g} zeigt eine
solche Grammatik, die ich dem Drachenbuch entnommen habe.

\begin{figure}[htbp]
  \begin{center}    
  \framebox{
  \framebox{
  \begin{minipage}[t]{5.5cm}
    \vspace*{-0.3cm}

  \begin{eqnarray*}
  s  & \rightarrow & \aquoted{v} a \aquoted{y} \\
     & \mid        & \aquoted{w} b \aquoted{y} \\
     & \mid        & \aquoted{v} b \aquoted{z} \\
     & \mid        & \aquoted{w} a \aquoted{z} \\[0.1cm]
  a  & \rightarrow & \aquoted{x}              \\[0.1cm]
  b  & \rightarrow & \aquoted{x}              
  \end{eqnarray*}
  \vspace*{-0.5cm}

  \end{minipage}}}
  \vspace*{-0.3cm}

  \end{center}
  \caption{Eine kanonische LR-Grammatik, die keine LALR-Grammatik ist.}
  \label{fig:lr-but-notlalr.g}
\end{figure}

Wir berechnen zunächst die Menge der Zustände eines kanonischen LR-Parsers für diese
Grammatik.  Wir erhalten dabei die folgenden Mengen von erweiterten markierten Regeln:
\begin{enumerate}
\item $s_0 = \textsl{closure}(\widehat{s} \rightarrow \bullet\, \;s: \symbol{36}) =
       \{
       \begin{array}[t]{lcl}
         \widehat{s} & \rightarrow & \bullet \;s: \symbol{36},                \\
         s           & \rightarrow & \bullet \saquoted{v} a \saquoted{y}: \symbol{36}, \\
         s           & \rightarrow & \bullet \saquoted{v} b \saquoted{z}: \symbol{36}, \\
         s           & \rightarrow & \bullet \saquoted{w} a \saquoted{z}: \symbol{36}, \\
         s           & \rightarrow & \bullet \saquoted{w} b \saquoted{y}: \symbol{36}\;\},
        \end{array}
       $
\item $s_1 = \textsl{goto}(s_0, s) =\{ \widehat{s} \rightarrow s \bullet: \symbol{36} \}$
\item $s_2 = \textsl{goto}(s_0, \aquoted{v}) = \{ 
       \begin{array}[t]{lcl}
        s & \rightarrow & \saquoted{v} \bullet b \saquoted{z}: \symbol{36}, \\
        s & \rightarrow & \saquoted{v} \bullet a \saquoted{y}: \symbol{36}, \\
        a & \rightarrow & \bullet \saquoted{x}: \saquoted{y}, \\
        b & \rightarrow & \bullet \saquoted{x}: \saquoted{z}\; \},
       \end{array}
      $
\item $s_3 = \textsl{goto}(s_0, \aquoted{w}) = \{ 
       \begin{array}[t]{lcl}
       s & \rightarrow & \saquoted{w} \bullet a \saquoted{z}: \symbol{36},  \\
       s & \rightarrow & \saquoted{w} \bullet b \saquoted{y}: \symbol{36},  \\
       a & \rightarrow & \bullet \saquoted{x}: \saquoted{z},                \\
       b & \rightarrow & \bullet \saquoted{x}: \saquoted{y}\; \},
       \end{array}
      $
\item $s_4 = \textsl{goto}(s_2, \aquoted{x}) =
             \{ a \rightarrow \saquoted{x} \bullet: \saquoted{y},\;
                b \rightarrow \saquoted{x} \bullet: \saquoted{z} \}$,
\item $s_5 = \textsl{goto}(s_3, \aquoted{x}) =
             \{ a \rightarrow \saquoted{x} \bullet: \saquoted{z},\,
                b \rightarrow \saquoted{x} \bullet: \saquoted{y} \}$,
\item $s_6 = \textsl{goto}(s_2, a) =
             \{ s \rightarrow \saquoted{v} a \bullet \saquoted{y}: \symbol{36} \}$,
\item $s_7 = \textsl{goto}(s_6, \aquoted{y}) =
             \{ s \rightarrow \saquoted{v} a \saquoted{y} \bullet: \symbol{36} \}$,
\item $s_8 = \textsl{goto}(s_2, b) =
             \{ s \rightarrow \saquoted{v} b \bullet \saquoted{z}: \symbol{36} \}$,
\item $s_9 = \textsl{goto}(s_8, \aquoted{z}) =
             \{ s \rightarrow \saquoted{v} b \saquoted{z} \bullet: \symbol{36} \}$,
\item $s_{10} = \textsl{goto}(s_3, a) =
                \{ s \rightarrow \saquoted{w} a \bullet \saquoted{z}: \symbol{36} \}$,
\item $s_{11} = \textsl{goto}(s_{10}, \aquoted{z}) =
                \{ s \rightarrow \saquoted{w} a \saquoted{z} \bullet: \symbol{36} \}$,
\item $s_{12} = \textsl{goto}(s_3, b) =
                \{ s \rightarrow \saquoted{w} b \bullet \saquoted{y}: \symbol{36} \}$,
\item $s_{13} = \textsl{goto}(s_{12}, \aquoted{y}) =
                \{ s \rightarrow \saquoted{w} b \saquoted{y} \bullet: \symbol{36} \}$.
\end{enumerate}
Die einzigen Zustände, bei denen es Konflikte geben könnte, sind die Mengen $s_4$ und
$s_5$, denn hier sind prinzipiell sowohl Reduktionen mit der Regel
\\[0.2cm]
\hspace*{1.3cm}
$a \rightarrow \saquoted{x}$ \quad als auch mit \quad
$b \rightarrow \saquoted{x}$
\\[0.2cm]
möglich.  Da allerdings die Mengen der Folge-Token einen leeren Durchschnitt haben, gibt
es tatsächlich keinen Konflikt und die Grammatik ist eine kanonische LR-Grammatik.

Wir berechnen als nächstes die LALR-Zustände der oben angegebenen Grammatik.  Die einzigen
Zustände, die einen gemeinsamen Kern haben, sind die beiden Zustände $s_4$ und $s_5$, denn
es gilt
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{core}(s_4) = \{ a \rightarrow \saquoted{x} \bullet,\;
                b \rightarrow \saquoted{x} \bullet \} = \textsl{core}(s_5)$.
\\[0.2cm]
Bei der Berechnung der LALR-Zustände werden diese beiden Zustände zu einem Zustand
$s_{\{4,5\}}$ zusammengefasst.  Dieser neue Zustand hat die Form
\\[0.2cm]
\hspace*{1.3cm}
$s_{\{4,5\}} = \bigl\{ A \rightarrow \saquoted{x} \bullet: \{\saquoted{y}, \saquoted{z} \},\;
                       B \rightarrow \saquoted{x} \bullet: \{\saquoted{y}, \saquoted{z} \} \bigr\}$.
\\[0.2cm]
Hier gibt es offensichtlich  einen Reduce-Reduce-Konflikt, denn einerseits haben wir
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{action}(s_{\{4,5\}}, \saquoted{y}) = \pair(\textsl{reduce}, A \rightarrow \saquoted{x})$,
\\[0.2cm]
andererseits gilt aber auch
\\[0.2cm]
\hspace*{1.3cm}
$\textsl{action}(s_{\{4,5\}}, \saquoted{y}) = \pair(\textsl{reduce}, B \rightarrow \saquoted{x})$.

\exercise
Es sei $G = \langle V, T, R, s \rangle$ eine LR-Grammatik und $\mathcal{N}$ sei die Menge der
LALR-Zustände der Grammatik.  überlegen Sie, warum es in der Menge $\mathcal{N}$ keine
Shift-Reduce-Konflikte geben kann.  \eox


\paragraph{Historical Notes}
The theory of LALR parsing is due to Franklin L.~DeRemer \cite{deRemer:71}.  At the time of its
invention,  the space savings of LALR parsing in comparison to LR parsing were crucial.  


\subsection{Bewertung der verschiedenen Methoden}
Für die Praxis sind SLR-Parser nicht ausreichend, denn es gibt eine Reihe praktisch
relevanter Sprach-Konstrukte, für die sich kein SLR-Parser erzeugen lässt.  Kanonische
LR-Parser sind wesentlich mächtiger, benötigen allerdings oft deutlich mehr Zustände. 
Hier stellen LALR-Parser einen Kompromiss dar:  Einerseits sind LALR-Sprachen fast so
ausdrucksstark  wie kanonische LR-Sprachen, andererseits liegt der Speicherbedarf von
LALR-Parsern in der gleichen Größenordnung wie der Speicherbedarf von SLR-Parsern.  Beispielsweise
hat die SLR-Parse-Tabelle für die Sprache \texttt{C} insgesamt 349 Zustände, die entsprechende
LR-Parse-Tabelle kommt auf 1572 Zustände, während der LALR-Parser mit 350 Zuständen auskommt und damit nur
einen Zustand mehr als der SLR-Parser hat.  
In den heute in der Regel zur Verfügung stehenden Hauptspeichern lassen sich allerdings
auch kanonische LR-Parser meist mühelos unterbringen, so dass es eigentlich keinen zwingenden
Grund mehr gibt, statt eines LR-Parsers einen LALR-Parser einzusetzen.  

Andererseits wird niemand einen LALR-Parser oder einen kanonischen LR-Parser von Hand
programmieren wollen.  Stattdessen werden Sie später einen Parser-Generator wie \textsl{Bison}
oder \textsl{JavaCup} einsetzen, der Ihnen einen  Parser generiert.  Das Werkzeug Bison
ist ein Parser-Generator für \texttt{C}, \texttt{C++} und bietet auch eine, allerdings leider noch
experimentelle, Unterstützung für \textsl{Java},
während \textsl{JavaCup} auf die Sprache \textsl{Java} beschränkt ist.  Falls Sie
\textsl{JavaCup} benutzen, haben Sie keine Wahl, denn dieses Werkzeug erzeugt immer einen
LALR-Parser.  Bei \href{http://www.gnu.org/software/bison/manual/bison.html}{\textsl{Bison}} ist es
ab der Version 3.0  auch möglich, einen LR-Parser zu erzeugen.



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "formal-languages"
%%% End: 
