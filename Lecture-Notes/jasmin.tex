\chapter{Assembler}
A compiler translates programs written in a high level language like \texttt{C} or
\textsl{Java} into some low level representation.  This low level representation can be
either machine code or some form of assembler code.  For the programming language
\href{https://en.wikipedia.org/wiki/Java_(programming_language)}{\textsl{Java}}, 
the command \texttt{javac} compiles a program written in \textsl{Java} into
\textsl{Java} byte code.  This byte code is then executed using the 
\href{http://en.wikipedia.org/wiki/Java_virtual_machine}{\textsl{Java} virtual machine}
(\textsc{Jvm}).

The compiler that we are going to
develop in the next chapter generates a particular form of assembler code know as
\href{http://jasmin.sourceforge.net}{\textsc{Jvm} assembler code}.
This assembler code can be translated directly into
\href{http://en.wikipedia.org/wiki/Java_bytecode}{\textsl{Java} byte code}, which 
is also the byte code generated by the program \href{https://en.wikipedia.org/wiki/javac}{\texttt{javac}}.  The
program for translating \textsc{Jvm} 
assembler into bytecode is called \href{http://jasmin.sourceforge.net}{\textsl{Jasmin}}.
You can download \textsl{Jasmin} at
\\[0.2cm]
\hspace*{1.3cm}
\href{http://sourceforge.net/projects/jasmin}{http://sourceforge.net/projects/jasmin}.
\\[0.2cm]
\textsl{Jasmin} takes an byte code produced by \textsl{Jasmin} can be executed using the
command  \texttt{java} just like any other ``\texttt{.class}''-file.  
This chapter will discuss the syntax and semantics of
\textsl{Jasmin} assembler code.  \textsl{Jasmin} is discussed in more detail in the book
\textsl{Java Virtual Machine} \cite{meyer:1997}. 

By the way, \textsl{Java} isn't the only programming language that is translated into \textsl{Java} Byte code.
Here is a list of some of the better knwon programming languages that use the \textsc{Jvm} architecture.
\begin{enumerate}
\item \href{https://kotlinlang.org}{Kotlin} is  
      developed by \href{https://www.jetbrains.com/}{JetBrains}. It is is fully interoperable with \textsl{Java}
      and compiles to \textsc{Jvm} bytecode. It is widely used in
      \href{https://en.wikipedia.org/wiki/Android_(operating_system)}{Android} development as a replacement for 
      \textsl{Java}.

      As of the $28^\mathrm{th}$ of November 2024, \textsl{Kotlin} occupies the $20^{\mathrm{th}}$ place in the
      \href{https://www.tiobe.com/tiobe-index/}{Tiobe index}. 
\item \href{https://www.scala-lang.org}{Scala} 
       blends functional and object-oriented programming paradigms. Scala compiles to \textsc{Jvm} bytecode
       and is often used for concurrent and distributed applications.

       Currently, \textsl{Scala} occupies the $30^{th}$ place in the
       \href{https://www.tiobe.com/tiobe-index/}{Tiobe index}.       
\item \href{https://groovy-lang.org}{Groovy} is a dynamic scripting language that is easy to learn for
      \textsl{Java} programmers because its syntax is close to \textsl{Java}. It is often used in scripting,
      configuration, and in build systems like \href{https://gradle.org}{Gradle}. 
\item \href{https://clojure.org}{Clojure}
      is a modern Lisp dialect designed for functional programming.
      It compiles to \textsc{Jvm} bytecode and supports concurrency.
\item \href{https://www.jruby.org}{JRuby}
      is a \textsc{Jvm}-based version of the \href{https://www.ruby-lang.org}{Ruby} programming language.
      It is fully compatible with \textsl{Ruby} but additionally support the use \textsl{Java} libraries.
\item \href{https://www.jython.org}{Jython} 
      is a \textsc{Jvm}-based version of \href{https://www.python.org}{Python} version 2.7.
\item \href{https://github.com/Frege}{Frege}
      is a version of the pure functional language \href{https://www.haskell.org}{Haskell} that compiles to
      \textsc{Jvm} bytecode.  
\end{enumerate}
The main reason these languages compile to the \textsc{Jvm} is to take advantage of \textsl{Java}'s rich library ecosystem.
Another reason is the fact that compiling a language to the \textsc{Jvm} makes this language available for all those
hardware platforms that support \textsl{Java}.

\section{Introduction into \textsc{Jasmin} Assembler}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    .class public Hello
    .super java/lang/Object
    
    .method public <init>()V
        aload 0
        invokenonvirtual java/lang/Object/<init>()V
        return
    .end method
    
    .method public static main([Ljava/lang/String;)V
        .limit locals 1
        .limit stack  2
        getstatic     java/lang/System/out Ljava/io/PrintStream;
        ldc           "Hello World!"
        invokevirtual java/io/PrintStream/println(Ljava/lang/String;)V 
        return
    .end method
\end{Verbatim}
\vspace*{-0.3cm}
\caption{An assembler program to print ``\texttt{Hello World!}''.}
\label{fig:Hello.jas}
\end{figure}

\noindent
To get used to the syntax of \textsl{Jasmin} assembler, we start with a small program that prints the
string
\\[0.2cm]
\hspace*{1.3cm}
``\texttt{Hello World!}''
\\[0.2cm]
on the standard output stream.  Figure \ref{fig:Hello.jas} on page
\pageref{fig:Hello.jas} shows the program
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Jasmin/Hello.jas}{\texttt{Hello.jas}}. 
We discuss this program line by line.
\begin{enumerate}
\item Line 1 uses the directive ``\texttt{\green{.class}}'' to define the name of the class file that is to
      be produced by the assembler.  
      In this case, the class name is \texttt{Hello}.  Therefore, \textsl{Jasmin} will translate
      this file into the class file ``\texttt{Hello.class}''.
\item Line 2 uses the directive ``\texttt{\green{.super}}'' to specify the super class of the class
      \texttt{Hello}.  In our examples, the super class will always be the class \texttt{Object}.
      Since this class resides in the package ``\texttt{java.lang}'', the super class has to be
      specified as 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{java/lang/Object}.
      \\[0.2cm]
      Observe that the character ``\texttt{.}'' in the class name ``\texttt{java.lang.Object}''
      has to be replaced by the character ``\texttt{/}''.  This is true even if a \textsl{Windows}
      operating system is used.
\item The lines 4 -- 8 initialize the program.  This code is always the same and corresponds to a
      constructor for the class \texttt{Hello}.  As this code is copied verbatim to the beginning 
      of every class file, we will not discuss it further. 
\item The lines 10 -- 17 defines the method \texttt{main} that does the actual work.
  \begin{enumerate}[(a)]
  \item Line 10 uses the directive ``\texttt{\green{.method}}'' to declare the name of the method and its
        signature.  The string 
        \\[0.2cm]
        \hspace*{1.3cm}
        \texttt{main([Ljava/lang/String;)V}
        \\[0.2cm]
        specifies the signature:
        \begin{enumerate}
        \item The string ``\texttt{main}''  is the name of the method that is defined.
        \item The character ``\texttt{[}'' specifies that the first argument is an array.
        \item The character ``\texttt{L}'' specifies that this array consists of objects.
        \item The string ``\texttt{java/lang/String;}'' specifies that these objects are objects of
              the class \\
              ``\texttt{java.lang.String}''.
        \item Finally, the character ``\texttt{V}'' specifies that the return type of the method \texttt{main}
              is ``\texttt{void}''.
       \end{enumerate}
  \item Line 11 uses the directive ``\texttt{\green{.limit locals}}'' to specify the number of local variables 
        used by the method \texttt{main}.  In this case, there is just one local variable.  This variable
        corresponds to the parameter of the method main.  The assembler file shown in Figure
        \ref{fig:Hello.jas} on page \pageref{fig:Hello.jas} corresponds to the \textsl{Java} code
        shown in Figure \ref{fig:Hello.java} below.  The method \texttt{main} has one local
        variable, which is the parameter \texttt{args}.
        The information on the number of local variables is needed by the \textsl{Java} virtual
        machine in order to allocate memory for these variables on the stack.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 2.3cm,
                  xrightmargin  = 2.3cm,
                ]
    public class Hello {
        public static void main(String[] args) {
    	System.out.println("Hello World!");
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{Printing \texttt{Hello world} in \textsl{Java}.} 
\label{fig:Hello.java}
\end{figure}

  \item For the purpose of the following discussion, we basically assume that there exist two types of
        processors: Those that store the objects they work upon in registers and those that store
        these objects on a stack residing in main memory.  The Java virtual machine is of the second
        type.  Hence, \textsl{Jasmin} assembler programs do not refer to registers but rather refer to
        this stack\footnote{
          In reality, all real processors make use of registers.  However, it is possible 
          to simulate a stack machine using a real processor and that is what is done in the Java
          virtual machine.}.
        Line 12 uses the directive
        \\[0.2cm]
        \hspace*{1.3cm}
        ``\texttt{\green{.limit stack}}''
        \\[0.2cm]
        to specify the maximal height of the
        stack.  In this case, the stack is allowed to contain a maximum of two objects.  It is easy
        to see that we indeed do never place more than two objects onto the stack, since the command
        \texttt{getstatic} in line 13 pushes the object 
        \\[0.2cm]
        \hspace*{1.3cm}
        \texttt{java.lang.System.out}
        \\[0.2cm]
        onto the stack.  This is an object of class ``\texttt{java.io.PrintStream}''.
        Then, the command \texttt{ldc} in line 14 pushes a reference to the string ``\texttt{Hello World}'' onto the stack.
        The other instructions do not push anything onto the stack.
  \item Line 15 calls the method \texttt{println}, which is a method of the class
        ``\texttt{java.io.PrintStream}''.  It also specifies that \texttt{println} takes one argument of
        type \texttt{java.lang.String} and returns nothing.

        In reality, \texttt{println} needs a second argument.  This argument is the object
        \texttt{java.lang.System.out} that we had previously pushed on the stack using the method \texttt{getstatic}.
  \item Line 16 returns from the method \texttt{main}.
  \item In line 17 the directive ``\texttt{\green{.end}}''  marks the end of the code corresponding to the method 
        \texttt{main}.
  \end{enumerate}
\end{enumerate}
Before we proceed, let us assume that we are working on a Unix operating system and that there is an
executable file called \texttt{jasmin} somewhere in our path that contains the following code:
\begin{verbatim}
    #!/bin/bash 
    java -jar /usr/local/lib/jasmin.jar $@
\end{verbatim}
Of course, for this to work the directory \texttt{/usr/local/lib/} has to contain the file
``\texttt{jasmin.jar}''.  If we were working on a Windows operating system, we would have a file
called \texttt{jasmin.bat} somewhere in our \texttt{PATH}.  This file would contain the following
line:
\begin{verbatim}
    java -jar %USERPROFILE%/Dropbox/Software/jasmin-2.4/jasmin.jar %*
\end{verbatim}
Of course, for this to work the directory \texttt{\%USERPROFILE\%/Dropbox/Software/jasmin-2.4}
has to contain the file ``\texttt{jasmin.jar}''.

In order to execute the assembler program discussed above, we first have to translate the assembler
program into a \texttt{class}-file.  This is done using the command
\\[0.2cm]
\hspace*{1.3cm}
\texttt{jasmin Hello.jas}
\\[0.2cm]
Executing this command creates the file ``\texttt{Hello.class}''.  This class file
can then be executed just like any class file generated from \texttt{javac} by typing
\\[0.2cm]
\hspace*{1.3cm}
\texttt{java Hello}
\\[0.2cm]
in the command line, provided the environment variable \texttt{CLASSPATH} contains the current
directory, i.e.~the \texttt{CLASSPATH} has to contain the directory ``\texttt{.}''.

We will proceed to discuss the different assembler commands in more detail later.  To this end, we
first have to discuss some background: One of the design goal of the programming language
\textsl{Java} was compatibility.  The idea was 
that it should be possible to execute \textsl{Java} class files on any computer.  Therefore, the
\textsl{Java} designers decided to create a so called 
\href{http://en.wikipedia.org/wiki/Virtual_machine}{\emph{virtual machine}}.  A virtual machine is
a computer architecture that, instead of being implemented in silicon, is simulated. 
Programs written in \textsl{Java} are first compiled into so called \emph{class files}.  These class
files correspond to the machine code of the \textsl{Java} virtual machine (\textsc{Jvm}).  
The architecture of the virtual machine is a 
\href{http://en.wikipedia.org/wiki/Stack_machine}{\emph{stack machine}}. 
A stack machine does not have any registers to store variables.  Instead, there is a stack and all
variables reside on the stack.  Every command takes its arguments from the top of the stack and
replaces these arguments with the result of the operation performed by the command.
For example, if we want to add two values, then we first have to
push both values onto the stack.  Next, performing the add operation will pop these values from the
stack and then push their sum onto the stack.


\section{Assembler Instructions}
We proceed to discuss some of the \textsc{Jvm} instructions.  Since there are more than 160
\textsc{Jvm} instructions, we can only discuss a subset of all instructions.  We restrict ourselves to those
instructions that deal with integers:  For example, there is an instruction called \texttt{iadd} that adds
two 32 bit integers.  There are also instructions like \texttt{fadd} that adds two floating point
numbers and \texttt{dadd} that adds two double precision floating point numbers but, since our time
is limited, we won't discuss these instructions.  Before we are able to discuss the different
instructions we have to discuss how the main memory is organized in the \textsc{Jvm}: In the
\textsc{Jvm}, the memory is split into four parts: 
\begin{enumerate}
\item The \blue{program memory} contains the program code as a sequence of bytes.
\item The operands of the different machine instructions are put onto the \blue{stack}.
      Furthermore, the stack contains the arguments and the local variables of a procedure.
      However, in the context of the \textsc{Jvm} the procedures are called \emph{methods} instead
      of procedures.

      The register \texttt{SP} points to the top of the stack.
      If a method is called, the arguments of the method are placed on the stack.  
      The register \texttt{LV} (\blue{local variables}) points to the first argument of the current  
      method.    On top of the arguments, the local variables of the method are put on the stack.
      Both the arguments and the local variables can be accessed via the register \texttt{LV}
      by specifying their offset from the first argument.
      We will discuss the register \texttt{LV} in more detail when we discuss the invocation of methods. 
\item The \blue{heap} is used for dynamically allocated memory.  Newly created objects are
      located in the heap.
\item The \blue{constant pool} contains the definitions of constants and also the addresses of
      methods in program memory.
\end{enumerate}
In the following, we will be mostly concerned with the stack.
We proceed to discuss some of the assembler instructions.

\subsubsection{Arithmetical and Logical Instructions}

\begin{enumerate}
\item The instruction \squoted{\texttt{iadd}}
      adds those values that are on top of the stack and replaces these values by their sum.
      Figure \ref{fig:ijvm-add} on page \pageref{fig:ijvm-add} show how this command works.
      The left part of the figure shows the stack as it is before the command \texttt{iadd} is executed,
      while the right part of the figure depicts the situation after the execution of this command.  Note
      that after the command is executed, the stack pointer points to the position where formerly the
      first argument had been stored.

\setlength{\unitlength}{0.5cm}
\begin{figure}[!ht]
  \centering
\framebox{
\begin{picture}(20,14)
\put(4.5,1){before \texttt{iadd}}
\put(4.91,3){$\vdots$}
\put(7.91,3){$\vdots$}
\put(5,4){\vector(0,1){8}}
\put(8,4){\vector(0,1){8}}
\put(5,8){\line(1,0){3}}
\put(5,9){\line(1,0){3}}
\put(5,10){\line(1,0){3}}
\put(2,9.3){\texttt{SP}}
\put(3.2,9.5){\vector(1,0){1.5}}
\put(6.3,9.3){$b$}
\put(6.3,8.3){$a$}

\put(13.8,1){after \texttt{iadd}}
\put(13.91,3){$\vdots$}
\put(16.91,3){$\vdots$}
\put(14,4){\vector(0,1){8}}
\put(17,4){\vector(0,1){8}}
\put(14,8){\line(1,0){3}}
\put(14,9){\line(1,0){3}}
\put(14,10){\line(1,0){3}}
\put(11,8.3){\texttt{SP}}
\put(12.2,8.5){\vector(1,0){1.5}}
%\put(15.3,9.3){$b$}
\put(14.7,8.3){$a + b$}

\end{picture}}
  \caption{The effect of \texttt{iadd}.}
  \label{fig:ijvm-add}
\end{figure}

\item The instruction \squoted{\texttt{isub}}
      subtracts the integer value on top of the stack from the value that is found on the position next to
      the top of the stack.
      Figure \ref{fig:ijvm-sub} on page \pageref{fig:ijvm-sub} pictures this command.
      The left part of the figure shows the stack as it is before the command \texttt{isub} is executed,
      while the right part of the figure depicts the situation after the execution of this command.  Note
      that after the command is executed, the stack pointer points to the position where formerly the
      first argument had been stored.

\setlength{\unitlength}{0.5cm}
\begin{figure}[!ht]
  \centering
\framebox{
\begin{picture}(20,14)
\put(4.5,1){before \texttt{isub}}
\put(4.91,3){$\vdots$}
\put(7.91,3){$\vdots$}
\put(5,4){\vector(0,1){8}}
\put(8,4){\vector(0,1){8}}
\put(5,8){\line(1,0){3}}
\put(5,9){\line(1,0){3}}
\put(5,10){\line(1,0){3}}
\put(2,9.3){\texttt{SP}}
\put(3.2,9.5){\vector(1,0){1.5}}
\put(6.3,9.3){$b$}
\put(6.3,8.3){$a$}

\put(13.8,1){after \texttt{isub}}
\put(13.91,3){$\vdots$}
\put(16.91,3){$\vdots$}
\put(14,4){\vector(0,1){8}}
\put(17,4){\vector(0,1){8}}
\put(14,8){\line(1,0){3}}
\put(14,9){\line(1,0){3}}
\put(14,10){\line(1,0){3}}
\put(11,8.3){\texttt{SP}}
\put(12.2,8.5){\vector(1,0){1.5}}
%\put(15.3,9.3){$b$}
\put(14.7,8.3){$a - b$}

\end{picture}}
  \caption{The effect of \texttt{isub}.}
  \label{fig:ijvm-sub}
\end{figure}

\item The instruction \squoted{\texttt{imul}}
      multiplies the two integer values which are on top of the stack.  This instruction works similar to
      the instruction \texttt{iadd}.  If the product does not fit in 32 bits, only the lowest 32 bits of
      the result are written onto the stack. 
\item The instruction \squoted{\texttt{idiv}}
      divides the integer value that is found on the position next to the  top of the stack by the value
      on top of the stack.

      \textbf{Note}: Integer division in \textsl{Java} is different from integer division in \textsl{Python}.
      In \textsl{Python}, integer division is always rounded down (i.e.~rounded to negative infinity), while
      integer division in \textsl{Java} rounds towards $0$.  While there is no difference for natural numbers,
      we have $-5 \,\mathtt{/}\, 2 = -2$ in \textsl{Java}, while we have $-5 \,\mathtt{//}\, 2 = -3$ in
      \textsl{Python}.\footnote{
        In mathematics, integer division, which is also known as
        \href{https://en.wikipedia.org/wiki/Euclidean_division}{Euclidean division} is defined in the same was
        as it is implemented in \textsl{Python}.  The different implementation of this operator in
        \textsl{Java} is mostly a reflection of the poor educational standards of the United States of America.
      }. 
\item The instruction \squoted{\texttt{irem}}
      computes the remainder $a \,\texttt{\%}\, b$ of the division of $a$ by $b$ where $a$ and $b$ are
      integer values found on top of the stack.

      Again, it is important to note that the \textsl{Java} implementation of $a \;\texttt{\%}\; b$
      differs from the implementation in \textsl{Java}.  For example, in \textsl{Java} we have
      $-5 \,\mathtt{\%}\, 3 = -2$,
      while we have $-5 \,\mathtt{\%}\, 3 = 1$
      in \textsl{Python}.
\item The instruction \squoted{\texttt{iand}}
      computes the bitwise ``and'' of the values on top of the stack.
\item The instruction \squoted{\texttt{ior}}
      computes the bitwise ``or'' of the integer values that are on top of the stack.
\item The instruction \squoted{\texttt{ixor}}
      computes the bitwise ``\href{http://en.wikipedia.org/wiki/Exclusive_or}{\emph{exclusive or}}'' of
      the integer values that are on top of the stack. 
\end{enumerate}

\subsubsection{Shift Instructions}
\begin{enumerate}
\item The instruction \squoted{\texttt{ishl}}
      shifts the value $a$ to the left by $b$\texttt{[4:0]} bits.  Here, $a$ and $b$ are assumed to be the two
      values on top of the stack:  $b$ is the value on top of the stack and $a$ is the value below $b$.
      $b$\texttt{[4:0]} denotes the natural number that results from the 5 lowest bits of $b$.  Figure
      \ref{fig:ijvm-shl} on page \pageref{fig:ijvm-shl} pictures this command.

\setlength{\unitlength}{0.5cm}
\begin{figure}[!ht]
  \centering
\framebox{
\begin{picture}(20,14)
\put(4.5,1){before \texttt{ishl}}
\put(4.91,3){$\vdots$}
\put(7.91,3){$\vdots$}
\put(5,4){\vector(0,1){8}}
\put(8,4){\vector(0,1){8}}
\put(5,8){\line(1,0){3}}
\put(5,9){\line(1,0){3}}
\put(5,10){\line(1,0){3}}
\put(2,9.3){\texttt{SP}}
\put(3.2,9.5){\vector(1,0){1.5}}
\put(6.3,9.3){$b$}
\put(6.3,8.3){$a$}

\put(13.8,1){after \texttt{ishl}}
\put(13.91,3){$\vdots$}
\put(18.91,3){$\vdots$}
\put(14,4){\vector(0,1){8}}
\put(19,4){\vector(0,1){8}}
\put(14,8){\line(1,0){5}}
\put(14,9){\line(1,0){5}}
\put(14,10){\line(1,0){5}}
\put(11,8.3){\texttt{SP}}
\put(12.2,8.5){\vector(1,0){1.5}}
%\put(15.3,9.3){$b$}
\put(14.7,8.3){$a \,\texttt{<<}\, b[4:0]$}

\end{picture}}
  \caption{The effect of \texttt{ishl}.}
  \label{fig:ijvm-shl}
\end{figure}
\item The instruction \squoted{\texttt{ishr}}
      shifts the value $a$ to the right by $b$\texttt{[4:0]} bits.  Here, $a$ and $b$ are assumed to be the two
      values on top of the stack:  $b$ is the value on top of the stack and $a$ is the value below $b$.
      $b$\texttt{[4:0]} denotes the natural number that results from the 5 lowest bits of $b$.  
      Note that this instruction performs an 
      \href{http://en.wikipedia.org/wiki/Arithmetic_shift}{\emph{arithmetic shift}}, 
      i.e.~the sign bit is preserved.
\end{enumerate}

\subsection{Instructions to Manipulate the Stack}
\begin{enumerate}
\item The instruction \squoted{\texttt{dup}}
      duplicates the value that is on top of the stack.  Figure \ref{fig:ijvm-dup} on page
      \pageref{fig:ijvm-dup} pictures this command.

\setlength{\unitlength}{0.5cm}
\begin{figure}[!ht]
  \centering
\framebox{
\begin{picture}(20,14)
\put(4.5,1){before \texttt{dup}}
\put(4.91,3){$\vdots$}
\put(7.91,3){$\vdots$}
\put(5,4){\vector(0,1){8}}
\put(8,4){\vector(0,1){8}}
\put(5,8){\line(1,0){3}}
\put(5,9){\line(1,0){3}}
\put(2,8.3){\texttt{SP}}
\put(3.2,8.5){\vector(1,0){1.5}}
\put(6.3,8.3){$a$}

\put(14.3,1){after \texttt{dup}}
\put(13.91,3){$\vdots$}
\put(16.91,3){$\vdots$}
\put(14,4){\vector(0,1){8}}
\put(17,4){\vector(0,1){8}}
\put(14,8){\line(1,0){3}}
\put(14,9){\line(1,0){3}}
\put(14,10){\line(1,0){3}}
\put(11,9.3){\texttt{SP}}
\put(12.2,9.5){\vector(1,0){1.5}}
\put(15.3,9.3){$a$}
\put(15.3,8.3){$a$}

\end{picture}}
  \caption{The effect of \texttt{dup}.}
  \label{fig:ijvm-dup}
\end{figure}

\item The instruction \squoted{\texttt{pop}}
      removes the value that is on top of the stack.  Figure \ref{fig:ijvm-pop} on page
      \pageref{fig:ijvm-pop} pictures this command.  The value is not actually erased from memory, only
      the stack pointer is decremented.  The next instruction that puts a new value onto the stack will
      therefore overwrite the old value.

\setlength{\unitlength}{0.5cm}
\begin{figure}[!ht]
  \centering
\framebox{
\begin{picture}(20,14)
\put(4.5,1){before \texttt{pop}}
\put(4.91,3){$\vdots$}
\put(7.91,3){$\vdots$}
\put(5,4){\vector(0,1){8}}
\put(8,4){\vector(0,1){8}}
\put(5,8){\line(1,0){3}}
\put(5,9){\line(1,0){3}}
\put(5,10){\line(1,0){3}}
\put(2,9.3){\texttt{SP}}
\put(3.2,9.5){\vector(1,0){1.5}}
\put(6.3,9.3){$b$}
\put(6.3,8.3){$a$}

\put(14.3,1){after \texttt{pop}}
\put(13.91,3){$\vdots$}
\put(16.91,3){$\vdots$}
\put(14,4){\vector(0,1){8}}
\put(17,4){\vector(0,1){8}}
\put(14,8){\line(1,0){3}}
\put(14,9){\line(1,0){3}}
\put(14,10){\line(1,0){3}}
\put(11,8.3){\texttt{SP}}
\put(12.2,8.5){\vector(1,0){1.5}}
\put(15.3,9.3){$b$}
\put(15.3,8.3){$a$}

\end{picture}}
  \caption{The effect of \texttt{pop}.}
  \label{fig:ijvm-pop}
\end{figure}

\item The instruction \squoted{\texttt{nop}}
      does nothing.  The name is short for \squoted{no operation}.
\item The instruction \squoted{\texttt{bipush} $b$}
      pushes the byte $b$ that is given as argument onto the stack.
      The argument $b$ is constricted to a byte in order to limit the number of bytes that are needed to
      represent this instruction in memory.
      Figure \ref{fig:ijvm-bipush} on page \pageref{fig:ijvm-bipush} pictures this command.
      
      
\setlength{\unitlength}{0.5cm}
\begin{figure}[!ht]
  \centering
\framebox{
\begin{picture}(20,14)
\put(4.5,1){before \texttt{bipush} $b$}
\put(4.91,3){$\vdots$}
\put(7.91,3){$\vdots$}
\put(5,4){\vector(0,1){8}}
\put(8,4){\vector(0,1){8}}
\put(5,8){\line(1,0){3}}
\put(5,9){\line(1,0){3}}
\put(2,8.3){\texttt{SP}}
\put(3.2,8.5){\vector(1,0){1.5}}
\put(6.3,8.3){$a$}

\put(13.8,1){after \texttt{bipush} $b$}
\put(13.91,3){$\vdots$}
\put(16.91,3){$\vdots$}
\put(14,4){\vector(0,1){8}}
\put(17,4){\vector(0,1){8}}
\put(14,8){\line(1,0){3}}
\put(14,9){\line(1,0){3}}
\put(14,10){\line(1,0){3}}
\put(11,9.3){\texttt{SP}}
\put(12.2,9.5){\vector(1,0){1.5}}
\put(15.3,9.3){$b$}
\put(15.3,8.3){$a$}

\end{picture}}
  \caption{The effect of \texttt{bipush} $b$.}
  \label{fig:ijvm-bipush}
\end{figure}
 

\item The instruction \squoted{\texttt{getstatic} $v$ $c$}
      takes two parameters:  $v$ is the name of a static variable and $c$ is the type of this variable.
      For example,  
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{getstatic java/lang/System/out Ljava/io/PrintStream;}
      \\[0.2cm] 
      pushes a reference to the \texttt{PrintStream} that is known as 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{java.lang.System.out}
      \\[0.2cm]
      onto the stack.
\item The instruction \squoted{\texttt{iload} $v$}
      reads the local variable with index  $v$ and pushes it on top of the stack.
      Figure \ref{fig:ijvm-load} on page \pageref{fig:ijvm-load} pictures this command.
      Note that \texttt{LV} denotes the register pointing to the beginning of the local variables of a
      method. 

\setlength{\unitlength}{0.5cm}
\begin{figure}[!ht]
  \centering
\framebox{
\begin{picture}(20,18)
\put(4.5,1){before \texttt{iload} $v$}
\put(4.91,3){$\vdots$}
\put(7.91,3){$\vdots$}
\put(5,4){\vector(0,1){12}}
\put(8,4){\vector(0,1){12}}
\put(5,12){\line(1,0){3}}
\put(5,13){\line(1,0){3}}
\put(2,12.3){\texttt{SP}}
\put(3.2,12.5){\vector(1,0){1.5}}
\put(6.3,12.3){$a$}

\put(0.7,8.3){$\texttt{LV}+v$}
\put(3.2,8.5){\vector(1,0){1.5}}
\put(5,8){\line(1,0){3}}
\put(5,9){\line(1,0){3}}
\put(6.3,8.3){$y$}

\put(2,5.3){\texttt{LV}}
\put(3.2,5.5){\vector(1,0){1.5}}
\put(5,5){\line(1,0){3}}
\put(5,6){\line(1,0){3}}
\put(6.3,5.3){$x$}

\put(13.8,1){after \texttt{iload} $v$}
\put(13.91,3){$\vdots$}
\put(16.91,3){$\vdots$}
\put(14,4){\vector(0,1){12}}
\put(17,4){\vector(0,1){12}}
\put(14,12){\line(1,0){3}}
\put(14,13){\line(1,0){3}}
\put(14,14){\line(1,0){3}}
\put(11,13.3){\texttt{SP}}
\put(12.2,13.5){\vector(1,0){1.5}}
\put(15.3,12.3){$a$}
\put(15.3,13.3){$y$}

\put(9.7,8.3){$\texttt{LV}+v$}
\put(12.2,8.5){\vector(1,0){1.5}}
\put(14,8){\line(1,0){3}}
\put(14,9){\line(1,0){3}}
\put(15.3,8.3){$y$}

\put(11,5.3){\texttt{LV}}
\put(12.2,5.5){\vector(1,0){1.5}}
\put(14,5){\line(1,0){3}}
\put(14,6){\line(1,0){3}}
\put(15.3,5.3){$x$}

\end{picture}}
  \caption{The effect of \texttt{iload} $v$.}
  \label{fig:ijvm-load}
\end{figure}
\item The instruction \squoted{\texttt{istore} $v$}
      removes the value which is on top of the stack and stores this value at the location for the local
      variable with number $v$.  Hence, $v$ is interpreted as an index into the local variable table of
      the method.
      Figure \ref{fig:ijvm-store} on page \pageref{fig:ijvm-store} pictures this command.

\setlength{\unitlength}{0.5cm}
\begin{figure}[!ht]
  \centering
\framebox{
\begin{picture}(20,18)
\put(4.5,1){before \texttt{istore} $v$}
\put(4.91,3){$\vdots$}
\put(7.91,3){$\vdots$}
\put(5,4){\vector(0,1){12}}
\put(8,4){\vector(0,1){12}}
\put(5,12){\line(1,0){3}}
\put(5,13){\line(1,0){3}}
\put(5,14){\line(1,0){3}}
\put(2,13.3){\texttt{SP}}
\put(3.2,13.5){\vector(1,0){1.5}}
\put(6.3,12.3){$a$}
\put(6.3,13.3){$b$}

\put(0.7,8.3){$\texttt{LV}+v$}
\put(3.2,8.5){\vector(1,0){1.5}}
\put(5,8){\line(1,0){3}}
\put(5,9){\line(1,0){3}}
\put(6.3,8.3){$y$}

\put(2,5.3){\texttt{LV}}
\put(3.2,5.5){\vector(1,0){1.5}}
\put(5,5){\line(1,0){3}}
\put(5,6){\line(1,0){3}}
\put(6.3,5.3){$x$}

\put(14.3,1){after \texttt{istore} $v$}
\put(13.91,3){$\vdots$}
\put(16.91,3){$\vdots$}
\put(14,4){\vector(0,1){12}}
\put(17,4){\vector(0,1){12}}
\put(14,12){\line(1,0){3}}
\put(14,13){\line(1,0){3}}
\put(14,14){\line(1,0){3}}
\put(11,12.3){\texttt{SP}}
\put(12.2,12.5){\vector(1,0){1.5}}
\put(15.3,12.3){$a$}
\put(15.3,13.3){$b$}

\put(9.7,8.3){$\texttt{LV}+v$}
\put(12.2,8.5){\vector(1,0){1.5}}
\put(14,8){\line(1,0){3}}
\put(14,9){\line(1,0){3}}
\put(15.3,8.3){$b$}

\put(11,5.3){\texttt{LV}}
\put(12.2,5.5){\vector(1,0){1.5}}
\put(14,5){\line(1,0){3}}
\put(14,6){\line(1,0){3}}
\put(15.3,5.3){$x$}

\end{picture}}
  \caption{The effect of \texttt{istore} $v$.}
  \label{fig:ijvm-store}
\end{figure}

\item The instruction \squoted{\texttt{ldc} $c$}
      pushes the constant $c$ onto the stack.  This constant can be an integer, a single precision floating
      point number, or a (pointer to) a string.  If $c$ is a string, this string is actually stored in the
      so called \emph{constant pool} and in this case the command ``\texttt{ldc} $c$'' will only push a
      pointer to the string onto the stack.
\end{enumerate}
      
\subsubsection{Branching Commands}
In this subsection we discuss those commands that change the control flow.
\begin{enumerate}
\item The instruction \squoted{\texttt{goto} $l$}
      jumps to the \blue{label} $l$.  Here the label $l$ is a label name that has to be declared inside the
      method containing this \texttt{goto} command.  A label with name \textsl{target} is declared using the syntax
      \\[0.2cm]
      \hspace*{1.3cm}
      \textsl{target}\texttt{:}
      \\[0.2cm]
      The next section presents an example assembler program that demonstrates this command.
\item The instruction \squoted{\texttt{if\_icmpeq} $l$}
      checks whether the value on top of the stack is the same as the value preceding it.  If this is
      the case, the program will branch 
      to the label $l$.  Otherwise, the control flow is not changed.  Observe that both values that are
      compared are removed from the stack.
\item The instruction \squoted{\texttt{if\_icmpne} $l$}
      checks whether the value on top of the stack is different from the value preceding it.  If this is
      the case, the program will branch to the label $l$.  Otherwise, the control flow is not
      changed.  Observe that both values that are compared are removed from the stack.

\item The instruction \squoted{\texttt{if\_icmplt} $l$}
      checks whether the value that is below the top of the stack is less than the value on top of
      the stack.  If this is the case, the program will branch 
      to the label $l$.  Otherwise, the control flow is not changed.  Observe that both values that are
      compared are removed from the stack.

\item The instruction \squoted{\texttt{if\_icmple} $l$}
      checks whether the value that is below the top of the stack is less or equal than the value on top
      of the stack.  If this is the case, the program will branch 
      to the label $l$.  Otherwise, the control flow is not changed.  Observe that both values that are
      compared are removed from the stack.
      
      There are similar commands called \texttt{if\_icmpgt} and \texttt{if\_icmpge}.

\item The instruction \squoted{\texttt{ifeq} $l$}
      checks whether the value on top of the stack is zero.  If this is the case, the program will branch
      to the label $l$.  Otherwise, the control flow is not changed.  Observe that the value that is
      tested is removed from the stack.

\item The instruction \squoted{\texttt{iflt} $l$}
      checks whether the value on top of the stack is less than zero.  If this is the case, the program
      will branch to the label $l$.  Otherwise, the control flow is not changed.  Observe that the value
      that is tested is removed from the stack.

\item The instruction \squoted{\texttt{invokevirtual} $m$}
      is used to call the method $m$.  Here $m$ has to  specify the full name of the method.
      For example, in order to invoke the method \texttt{println} of the class
      \texttt{java.io.PrintStream} we have to write:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{invokevirtual java/io/PrintStream/println(I)V}
      \\[0.2cm]
      Before the command \texttt{invokevirtual} is executed, we have to put the arguments of the method
      onto the stack.  For example, if we want to invoke the method \texttt{println} that takes an integer
      argument, we first have to push an object of type \texttt{PrintStream} onto the stack.  Furthermore,
      we need to push an integer onto the stack.

\item The instruction \squoted{\texttt{invokestatic} $m$}
      is used to call the method $m$.  Here $m$ has to  specify the full name of the method.
      Furthermore, $m$ needs to be s static method.
      For example, in order to invoke a  method called \texttt{sum} that resides in the class \texttt{Sum}
      and that takes one integer argument we have to write:
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{invokestatic  Sum/sum(I)I}
      \\[0.2cm]
      In the type specification ``\texttt{sum(I)I}'' the first ``\texttt{I}'' specifies that \texttt{sum}
      takes one integer argument, while the second ``\texttt{I}'' specifies that the method \texttt{sum}
      returns an integer.

      Before the command \texttt{invokestatic} is executed, we have to put the arguments of the method
      onto the stack.  For example, if we want to invoke the method \texttt{sum} described  above, then we
      have to push an integer $n$ onto the stack.  After the method returns, this integer is replaced with the
      return value $\mathtt{sum}(n)$.
\item The instruction \squoted{\texttt{ireturn}}
      returns from the method that is currently invoked.  This method also returns a value to the calling
      procedure.  In order for \texttt{ireturn} to be able to return a value $v$, this value $v$ has to be
      pushed onto the stack before the command \texttt{ireturn} is executed.

      In general, if a method taking $n$ arguments $a_1$, $\cdots$, $a_n$ is to be called, then first the
      arguments $a_1$, $\cdots$, $a_n$ have to be pushed onto the stack.  When the method $m$ is done and
      has computed its result $r$, the arguments $a_1$, $\cdots$, $a_n$ will have been replaced with the
      single value $r$.
\item The instruction \squoted{\texttt{return}}
      returns from the method that is currently invoked.  However, in contrast to the command
      \texttt{ireturn}, this command is used if the method that has been invoked  does not return a result. 
\end{enumerate}

\section{An Example Program}
Figure \ref{fig:sum-jasmin.c} shows the \texttt{C} program 
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Jasmin/sum.c}{\texttt{sum.c}}
that computes the sum
\\[0.2cm]
\hspace*{1.3cm}
$\sum\limits_{i=1}^{6^2} i$.
\\[0.2cm]
The function $\mathtt{sum}(n)$ computes the sum $\sum_{i=1}^{n} i$ and the function
\texttt{main} calls this function with the argument $6 \cdot 6$.  Figure \ref{fig:Sum.jas} on page
\pageref{fig:Sum.jas} shows how this program can be translated 
into the assembler program 
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Jasmin/Sum.jas}{\texttt{Sum.jas}}.
We discuss the implementation of this program next. 


\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    #import "stdio.h"
    
    int sum(int n) {
        int s;
        s = 0;
        while (n != 0) {
            s = s + n;
            n = n - 1;    
        };
        return s;
    }
    int main() {
        printf("%d\n", sum(6*6));
        return 0;
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{A \texttt{C} function to compute  $\sum\limits_{i=1}^{36} i$.}
\label{fig:sum-jasmin.c}
\end{figure}

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    .class public Sum
    .super java/lang/Object
    
    .method public <init>()V
        aload 0
        invokenonvirtual java/lang/Object/<init>()V
        return
    .end method
    
    .method public static main([Ljava/lang/String;)V
        .limit locals 1
        .limit stack  3
        getstatic     java/lang/System/out Ljava/io/PrintStream;
        ldc           6
        dup
        imul
        invokestatic  Sum/sum(I)I
        invokevirtual java/io/PrintStream/println(I)V
        return
    .end method
    
    .method public static sum(I)I
        .limit locals 2
        .limit stack  2
        ldc    0
        istore 1                    ; s = 0;
    loop:
        iload  0                    ; n
        ifeq   finish               ; if (n == 0) goto finish;
        iload  1                    ; s
        iload  0                    ; n
        iadd
        istore  1                   ; s = s + n;
        iload   0                   ; n
        ldc     1
        isub
        istore  0                   ; n = n - 1;
        goto    loop
    finish:
        iload   1
        ireturn                     ; return s;
    .end method
\end{Verbatim}
\vspace*{-0.3cm}
\caption{An assembler program to compute the sum $\sum\limits_{i=1}^{36} i$.}
\label{fig:Sum.jas}
\end{figure}

\begin{enumerate}
\item Line 1 specifies the name of the generated class which is to be \texttt{Sum}.
\item Line 2 specifies that the class \texttt{Sum} is a subclass of the class
      \texttt{java.lang.Object}. 
\item Lines 4 -- 8 initialize the class.  The code used here is the same as in the example printing 
      ``\texttt{Hello World!}''.
\item Line 10 declares the method \texttt{main}.  This method takes an argument which is an array of strings.
      It does not return a value.
\item Line 11 specifies that there is just one local variable.
\item Line 12 specifies that the stack will contain at most 3 temporary values.
\item Line 13 pushes the object \texttt{java.lang.out} onto the stack.
      We need this object later in order to invoke \texttt{println}.
\item Line 14 pushes the number 6 onto the stack.
\item Line 15 duplicates the value 6.  Therefore, after line 15 is executed, the stack contains three
      elements: The object \texttt{java.lang.out},  the number 6, and again the number 6.
\item Line 16 multiplies the two values on top of the stack and replaces them with their product,
      which happens to be 36.
\item Line 17 calls the method \texttt{sum} defined below.  After this call has finished, the number 
      36 on top of the stack is replaced with the value $\mathtt{sum}(36)$.
\item Line 18 prints the value that is on top of the stack.
      This is possible, because the object \texttt{java.lang.out} is directly below the value
      $\texttt{sum}(36)$.
\item Line 22 declares the method sum.  This method takes one integer argument and returns an
      integer as result. 
\item Line 23 specifies that the method \texttt{sum} has two local variables: The first local
      variable is the parameter $n$ and the second local variable corresponds to the variable $s$ in the
      \texttt{C} program.
\item The effect of lines 25 and 26 is to initialize this variable $s$ with the value $0$.
\item Line 28 pushes the local variable $n$ on the stack so that line 29 is able to test whether $n$
      is already $0$.  If $n = 0$, the program branches to the label \texttt{finish} in line 39,
      pushes the result $s$ onto the stack (line 40) and returns.  If $n$ is not yet $0$, the
      execution proceeds to line 30.
\item Line 30 and line 31 push the sum $s$ and the variable $n$ onto the stack.  These
      values are then added in line 32 and the result is written to the local variable $s$ in line 33.
      The combined effect of these instructions is therefore to perform the assignment
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{s = s + n;}
\item The instructions in line 34 up to line 37 implement the assignment 
      \\[0.2cm]
      \hspace*{1.3cm}
      \texttt{n = n - 1;}
\item In line 38 we jump back to the beginning of the loop and test whether $n$ is zero.  
\item The declaration in line 42 terminates the definition of the method \texttt{sum}.
\end{enumerate}

\exerciseEng
\begin{enumerate}[(a)]
\item Implement an assembler program that computes the function \texttt{factorial}, which takes a natural
      number $n$ as input and returns $n!$.  Test your program by printing
      $n!$ for $n = 1, \cdots, 10$.
\item Implement the function \texttt{factorial} in a recursive manner.
\end{enumerate}


\section{Disassembler$^*$}
Sometimes it is useful to transform a file consisting of \textsl{Java} byte code back into something
that looks like assembler code.  After all, a \textsl{Java} class file is a binary file and can
therefore only be viewed via commands like \href{http://en.wikipedia.org/wiki/Od_(Unix)}{\texttt{od}} 
that produce an \emph{octal} or \emph{hexadecimal dump} of the given file.  The command
\href{http://docs.oracle.com/javase/7/docs/technotes/tools/windows/javap.html}{\texttt{javap}} 
is a \emph{disassembler},  i.e.~it takes a \textsl{Java} byte code file and transforms it in
something that looks similar to \textsl{Jasmin} assembler.  For example, Figure \ref{fig:Sum.java}
shows the class \textsl{Java} class
\href{https://github.com/karlstroetmann/Formal-Languages/tree/master/Jasmin/Sum.java}{\texttt{Sum}}
 to compute the sum 
\\[0.2cm]
\hspace*{1.3cm}
$\sum\limits_{i=1}^{36} i$
\\[0.2cm]
written in \textsl{Java}.  If this program is
stored in a file called ``\texttt{Sum.java}'', we can compile it via the following command:
\\[0.2cm]
\hspace*{1.3cm}
\texttt{javac Sum.java}
\\[0.2cm]
This will produce a class file with the name ``\texttt{Sum.class}'' containing the byte code.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.8cm,
                  xrightmargin  = 0.8cm,
                ]
    public class Sum {
        public static void main(String[] args) {
            System.out.println(sum(6 * 6));
        }
    
        static int sum(int n) {
    	int s = 0;
    	for (int i = 0; i <= n; ++i) {
    	    s += i;
    	}
    	return s;
        }
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{A \textsl{Java} program computing $\ds\sum\limits_{i=0}^{6^2} i$.}
\label{fig:Sum.java}
\end{figure}

Next, in order to \emph{decompile} the ``\texttt{.class}'' file, we run the command
\\[0.2cm]
\hspace*{1.3cm}
\texttt{javap -c Sum.class}
\\[0.2cm]
The output of this command is shown in Figure \ref{fig:Sum.class}.  We see that the syntax used by
\texttt{javap} differs a bit from the syntax used by \textsl{Jasmin}.  It is rather unfortunate that
the company developing \textsl{Java} has decided not to make their assembler public.  Still, we can
see that the output produced by \texttt{javap} is quite similar to the input accepted by \texttt{jasmin}.

\begin{figure}[!ht]
\centering
\begin{Verbatim}[ frame         = lines, 
                  framesep      = 0.3cm, 
                  firstnumber   = 1,
                  labelposition = bottomline,
                  numbers       = left,
                  numbersep     = -0.2cm,
                  xleftmargin   = 0.0cm,
                  xrightmargin  = 0.0cm,
                ]
    Compiled from "Sum.java"
    public class Sum {
      public Sum();
        Code:
           0: aload_0       
           1: invokespecial #1           // Method java/lang/Object."<init>":()V
           4: return        
    
      public static void main(java.lang.String[]);
        Code:
           0: getstatic     #2           // Field java/lang/System.out:Ljava/io/PrintStream;
           3: bipush        36
           5: invokestatic  #3           // Method sum:(I)I
           8: invokevirtual #4           // Method java/io/PrintStream.println:(I)V
          11: return        
    
      static int sum(int);
        Code:
           0: iconst_0      
           1: istore_1      
           2: iconst_0      
           3: istore_2      
           4: iload_2       
           5: iload_0       
           6: if_icmpgt     19
           9: iload_1       
          10: iload_2       
          11: iadd          
          12: istore_1      
          13: iinc          2, 1
          16: goto          4
          19: iload_1       
          20: ireturn       
    }
\end{Verbatim}
\vspace*{-0.3cm}
\caption{The output of ``\texttt{javap -c Sum.class}''.}
\label{fig:Sum.class}
\end{figure}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "formal-languages"
%%% End: 
